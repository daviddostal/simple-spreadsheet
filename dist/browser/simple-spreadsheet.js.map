{"version":3,"file":"simple-spreadsheet.js","sources":["../../src/spreadsheet/errors.js","../../src/spreadsheet/tokenStream.js","../../src/spreadsheet/tokenizer.js","../../src/spreadsheet/expressions.js","../../src/spreadsheet/helpers.js","../../src/spreadsheet/parser.js","../../src/spreadsheet/evaluator.js","../../src/spreadsheet/referencesMap.js","../../src/spreadsheet/environment.js","../../src/spreadsheet/spreadsheet.js"],"sourcesContent":["export class NotImplementedError extends Error {\n    constructor(message) { super(message); }\n    toString() { return `Not implemented: ${this.message}` }\n}\n\nexport class SpreadsheetError extends Error { }\n\nexport class ParsingError extends SpreadsheetError {\n    constructor(message) { super(message); }\n    toString() { return `Syntax error: ${this.message}`; }\n}\n\nexport class RuntimeError extends SpreadsheetError {\n    constructor(message) { super(message); }\n    toString() { return `Evaluation error: ${this.message}`; }\n}\n\nexport class ReferencedCellError extends RuntimeError {\n    constructor(cell) {\n        super(`Error in referenced cell: ${cell}`);\n        this.cell = cell;\n    }\n}\n\nexport class CircularReferenceError extends RuntimeError {\n    constructor(cells) {\n        super(`Circular reference detected: ${cells.join(' -> ')}`);\n        this.cells = cells;\n    }\n}\n\nexport class FunctionEvaluationError extends RuntimeError {\n    constructor(functionName, error) {\n        super(`Error in function ${functionName}: ${error}`)\n        this.functionName = functionName;\n        this.error = error;\n    }\n}\n\nexport class RangeReferenceNotAllowedError extends RuntimeError {\n    constructor() { super(`Range references are allowed only as references to functions`); }\n}\n\nexport class UnknownFunctionError extends RuntimeError {\n    constructor(functionName) {\n        super(`Unknown function: ${functionName}`);\n        this.functionName = functionName;\n    }\n}","import { ParsingError } from \"./errors\";\n\nexport default class TokenStream {\n    constructor(tokens) {\n        this._tokens = tokens;\n        this._currentPos = 0;\n    }\n\n    peek() {\n        return this._tokens[this._currentPos] || null;\n    }\n\n    expect(...types) {\n        const token = this.peek();\n        if (token !== null && types.includes(token.type)) {\n            this._currentPos++;\n            return token;\n        }\n        return null;\n    }\n\n    require(...types) {\n        const token = this.expect(...types);\n        if (token === null)\n            throw new ParsingError(`Unexpected ${this.peek().type.description}, expected ${types.map(sym => sym.description).join(' or ')}`);\n        return token;\n    }\n}","import { ParsingError } from './errors';\nimport TokenStream from './tokenStream';\n\nexport const TokenType = Object.freeze({\n    // Note: strings must be unique, because they are used for comparison\n    EOF: Symbol('end of formula'),\n    WHITESPACE: Symbol('whitespace'),\n    PLUS: Symbol('+'),\n    MINUS: Symbol('-'),\n    STAR: Symbol('*'),\n    SLASH: Symbol('/'),\n    LPAREN: Symbol('opening parenthesis'),\n    RPAREN: Symbol('closing parenthesis'),\n    COLON: Symbol(':'),\n    EQUALS: Symbol('='),\n    COMMA: Symbol('comma'),\n    NUMBER: Symbol('number'),\n    STRING: Symbol('string'),\n    IDENTIFIER: Symbol('identifier'),\n});\n\nexport class Tokenizer {\n    constructor() {\n        this._rules = [\n            // NUMBER and IDENTIFIER are used the most so keep them at the top (for performance reasons - it makes a difference, I measured it)\n            // Patterns usually start with ^ so they match the start of the remaining\n            // string, not anywhere in the middle.\n            { pattern: /^\\d+(?:\\.\\d+)?/, type: TokenType.NUMBER },\n            { pattern: /^[a-zA-Z]\\w+/, type: TokenType.IDENTIFIER },\n            { pattern: /^\"(?:[^\"\\\\]|\\\\.)*\"/, type: TokenType.STRING },\n            { pattern: /^$/, type: TokenType.EOF },\n        ];\n\n        this._operators = {\n            ' ': TokenType.WHITESPACE,\n            '\\t': TokenType.WHITESPACE,\n            '\\r': TokenType.WHITESPACE,\n            '\\n': TokenType.WHITESPACE,\n            '+': TokenType.PLUS,\n            '-': TokenType.MINUS,\n            '*': TokenType.STAR,\n            '/': TokenType.SLASH,\n            '(': TokenType.LPAREN,\n            ')': TokenType.RPAREN,\n            '=': TokenType.EQUALS,\n            ':': TokenType.COLON,\n            ',': TokenType.COMMA,\n        }\n    }\n\n    tokenize(text) {\n        const tokens = [];\n        let remaining = text;\n        while (remaining.length > 0) {\n            const token = this._nextToken(remaining);\n            tokens.push(token);\n            remaining = remaining.slice(token.value.length);\n        }\n        tokens.push({ type: TokenType.EOF, value: '' });\n        return new TokenStream(tokens.filter(token => token.type !== TokenType.WHITESPACE));\n    }\n\n    _nextToken(text) {\n        const firstChar = text[0];\n        const operator = this._operators[firstChar];\n        if (operator !== undefined) return { type: operator, value: firstChar };\n\n        for (let rule of this._rules) {\n            const match = text.match(rule.pattern);\n            if (match !== null)\n                return { type: rule.type, value: match[0] };\n        }\n        throw new ParsingError(`Unknown token at '${text}'`);\n    }\n}\n","export class Expression { }\n\nexport class Value extends Expression {\n    constructor(value) { super(); this.value = value; }\n    toString() { return this.value.constructor === String ? `\"${this.value}\"` : `${this.value}`; }\n}\n\nexport class Reference extends Expression {\n    // TODO: Maybe refactor to only hold single property?\n    // Normalize position?\n    constructor(col, row) { super(); this.col = col; this.row = row; }\n    toString() { return `${this.col}${this.row}`; }\n}\n\nexport class BinaryOp extends Expression {\n    constructor(left, op, right) { super(); this.left = left; this.op = op; this.right = right; }\n    toString() { return `(${this.left} ${this.op} ${this.right})`; }\n}\n\nexport class UnaryOp extends Expression {\n    constructor(op, value) { super(); this.op = op; this.value = value; }\n    toString() { return `${this.op}${this.value}`; }\n}\n\nexport class FunctionCall extends Expression {\n    constructor(functionName, args) { super(); this.functionName = functionName; this.args = args; }\n    toString() { return `${this.functionName}(${this.args.join(', ')})`; }\n}\n\nexport class Range extends Expression {\n    constructor(from, to) { super(); this.from = from; this.to = to; }\n    toString() { return `${this.from}:${this.to}`; }\n}","export function positionsInRange(from, to) {\n    const positions = [];\n    // TODO: Use flatMap?\n    for (let col of _range(columnIndex(from.col), columnIndex(to.col)))\n        for (let row of _range(from.row, to.row))\n            positions.push({ col: columnLetter(col), row: row });\n    return positions;\n}\n\nfunction _range(from, to) {\n    return from <= to\n        ? Array.from({ length: to - from + 1 }, (_, i) => i + from)\n        : Array.from({ length: from - to + 1 }, (_, i) => from - i);\n}\n\nexport function parsePosition(position) {\n    const positionParts = position.match(/^([A-Za-z]+)(\\d+)$/);\n    return positionParts &&\n        { col: positionParts[1], row: parseInt(positionParts[2]) };\n}\n\nexport function makePosition(col, row) {\n    return `${col}${row}`;\n}\n\nexport function columnIndex(colLetter) {\n    return colLetter.charCodeAt(0) - 65;\n}\n\nexport function columnLetter(colIndex) {\n    return String.fromCharCode(colIndex + 65);\n}","import { TokenType } from './tokenizer';\nimport { ParsingError, NotImplementedError } from './errors';\nimport { Value, Reference, BinaryOp, UnaryOp, Range, FunctionCall } from './expressions';\nimport * as Helpers from './helpers';\n\nexport default class Parser {\n    constructor(tokenizer) {\n        this._tokenizer = tokenizer;\n        this._tokens = null;\n    }\n\n    // cell => empty | '=' expression EOF | number | string\n    parse(text) {\n        const needsParsing = text !== null && text !== undefined && text.constructor === String;\n        if (!needsParsing)\n            return { parsed: new Value(text), references: [] };\n\n        const isFormula = text[0] === '='; // TODO: add test with and without whitespace\n        if (isFormula) {\n            this._tokens = this._tokenizer.tokenize(text);\n            this._tokens.require(TokenType.EQUALS);\n            const parsed = this._parseExpression();\n            this._tokens.require(TokenType.EOF);\n            const references = this._referencesIn(parsed);\n            return { parsed, references };\n        }\n\n        // number\n        if (text.match(/^[+-]?\\d+(?:\\.\\d+)?$/))\n            return { parsed: new Value(parseFloat(text)), references: [] };\n\n        // string\n        return { parsed: new Value(text), references: [] };\n    }\n\n    // expression => term\n    _parseExpression() {\n        return this._parseTerm();\n    }\n\n    // term => factor (('+'|'-') factor)*\n    _parseTerm() {\n        let left = this._parseFactor();\n        let operation;\n        while ((operation = this._tokens.expect(TokenType.PLUS, TokenType.MINUS)) !== null) {\n            left = new BinaryOp(left, operation.value, this._parseFactor());\n        }\n        return left;\n    }\n\n    // factor => unary (('*'|'/') unary)*\n    _parseFactor() {\n        let left = this._parseRange();\n        let operation;\n        while ((operation = this._tokens.expect(TokenType.STAR, TokenType.SLASH)) !== null) {\n            left = new BinaryOp(left, operation.value, this._parseRange());\n        }\n        return left;\n    }\n\n    // range => unary (':' unary)*\n    _parseRange() {\n        // TODO: Make ranges first-class\n        return this._parseUnary();\n    }\n\n    // unary => ('+'|'-') unary | call\n    _parseUnary() {\n        const operation = this._tokens.expect(TokenType.PLUS, TokenType.MINUS);\n        return operation !== null\n            ? new UnaryOp(operation.value, this._parseUnary())\n            : this._parseValue();\n    }\n\n    // value => number | string | rangeReference | reference | parenthesized | functionCall\n    _parseValue() {\n        if (this._tokens.expect(TokenType.LPAREN))\n            return this._finishParenthesized();\n\n        const number = this._tokens.expect(TokenType.NUMBER)\n        if (number !== null)\n            return new Value(parseFloat(number.value));\n\n        const string = this._tokens.expect(TokenType.STRING);\n        if (string !== null)\n            return this._parseString(string);\n\n\n        const identifier = this._tokens.expect(TokenType.IDENTIFIER);\n        if (identifier !== null) {\n            if (this._tokens.expect(TokenType.COLON))\n                return this._finishRangeReference(identifier);\n\n            if (this._tokens.expect(TokenType.LPAREN))\n                return this._finishFunctionCall(identifier);\n\n            return this._parseReference(identifier.value);\n        }\n        throw new ParsingError(`Unexpected ${this._tokens.peek().type.description}, expected an expression or value`)\n    }\n\n    // parenthesized => '(' expression ')'\n    _finishParenthesized() {\n        const contents = this._parseExpression();\n        this._tokens.require(TokenType.RPAREN);\n        return contents;\n    }\n\n    _parseString(string) {\n        const withoutQuotes = string.value.substring(1, string.value.length - 1);\n        const escapedString = withoutQuotes.replace(/\\\\(.)/g, '$1'); // TODO: check escaped characters are escapable\n        return new Value(escapedString);\n    }\n\n    // rangeReference => IDENTIFIER ':' IDENTIFIER\n    _finishRangeReference(start) {\n        // start identifier and : are already parsed\n        const end = this._tokens.require(TokenType.IDENTIFIER);\n        const from = this._parseReference(start.value);\n        const to = this._parseReference(end.value);\n        return new Range(from, to);\n    }\n\n    // functionCall => IDENTIFIER ('(' arguments ')')*\n    _finishFunctionCall(identifier) {\n        // TODO: Test or remove nested function calls such as FOO()()\n        // Or check for function return types at runtime?\n\n        const args = this._parseArguments();\n        this._tokens.expect(TokenType.RPAREN);\n        return new FunctionCall(identifier.value, args);\n    }\n\n    // reference => [A-Za-z]+\\d+\n    _parseReference(reference) {\n        const position = Helpers.parsePosition(reference);\n        if (position === null)\n            throw new ParsingError(`Invalid format of cell reference: ${reference}`);\n        return new Reference(position.col, position.row);\n    }\n\n    // arguments => (expression (',' expression)*)?\n    _parseArguments() {\n        const args = [];\n        while (this._tokens.peek().type !== TokenType.RPAREN) {\n            if (args.length != 0)\n                this._tokens.require(TokenType.COMMA);\n            args.push(this._parseExpression());\n        }\n        return args;\n    }\n\n    _referencesIn(expression) {\n        switch (expression.constructor) {\n            case Value:\n                return [];\n            case Reference:\n                return [Helpers.makePosition(expression.col, expression.row)];\n            case UnaryOp:\n                return this._referencesIn(expression.value);\n            case BinaryOp:\n                return [...this._referencesIn(expression.left), ...this._referencesIn(expression.right)];\n            case FunctionCall:\n                return expression.args.flatMap(arg => this._referencesIn(arg));\n            case Range:\n                return Helpers.positionsInRange(expression.from, expression.to)\n                    .map(pos => Helpers.makePosition(pos.col, pos.row));\n            default:\n                throw new NotImplementedError(`Unknown expression type: ${typeof expression}`);\n        }\n    }\n}","import { Value, Reference, BinaryOp, FunctionCall, Range, UnaryOp } from './expressions';\nimport { RuntimeError, ParsingError, CircularReferenceError, ReferencedCellError, NotImplementedError, RangeReferenceNotAllowedError, FunctionEvaluationError } from './errors';\nimport * as Helpers from './helpers';\n\nclass CircularRefInternal extends Error {\n    constructor(position, circlePositions) { super(); this.position = position; this.circlePositions = circlePositions; }\n}\n\nexport default class Evaluator {\n    constructor() {\n        this.visitedCellStack = [];\n    }\n\n    evaluateCellAt(position, expression, environment) {\n        if (this.visitedCellStack.includes(position))\n            throw new CircularRefInternal(position, [...this.visitedCellStack, position]);\n\n        this.visitedCellStack.push(position);\n        try {\n            const result = this._evaluateCell(expression, environment);\n            this.visitedCellStack.pop();\n            return result;\n        } catch (ex) {\n            this.visitedCellStack.pop()\n            // Normal errors propagate as usual, but CircularRefInternal is used\n            // only to propagate the exception to the originating cell internally\n            // (so it doesn't get reported just as an error in a referenced cell).\n            // Once the CircularRefInternal reaches back to the originating cell,\n            // we turn it into a normal CircularReferenceError.\n            if (ex instanceof CircularRefInternal && ex.position === position) {\n                throw new CircularReferenceError(ex.circlePositions);\n            } else {\n                throw ex;\n            }\n        }\n    }\n\n    evaluateQuery(expression, environment) {\n        return this._evaluateCell(expression, environment);\n    }\n\n    _evaluateCell(expression, environment) {\n        switch (expression.constructor) {\n            case Value:\n                return expression.value;\n            case Reference:\n                return this._evaluateReference(Helpers.makePosition(expression.col, expression.row), environment);\n            case UnaryOp:\n                return this._evaluateUnary(expression.op, expression.value, environment);\n            case BinaryOp:\n                return this._evaluateBinary(expression.left, expression.op, expression.right, environment);\n            case FunctionCall:\n                return this._evaluateFunction(expression.functionName, expression.args, environment);\n            case Range:\n                throw new RangeReferenceNotAllowedError();\n            default:\n                throw new NotImplementedError(`Unknown expression type: ${typeof expression}`);\n        }\n    }\n\n    _evaluateReference(position, environment) {\n        try {\n            return environment.getValue(position);\n        } catch (ex) {\n            if (ex instanceof ParsingError || ex instanceof RuntimeError)\n                throw new ReferencedCellError(position);\n            else throw ex;\n        }\n    }\n\n    _evaluateExpression(value, environment) {\n        switch (value.constructor) {\n            case Range: return this._evaluateRange(value.from, value.to, environment);\n            default: return this._evaluateCell(value, environment);\n        }\n    }\n\n    _evaluateUnary(op, expression, environment) {\n        const value = this._evaluateCell(expression, environment);\n        switch (op) {\n            case '+': return value;\n            case '-': return -value;\n            default: throw new NotImplementedError(`Unknown unary operator: '${op}'`);\n        }\n    }\n\n    _evaluateBinary(left, op, right, environment) {\n        const leftValue = this._evaluateCell(left, environment);\n        const rightValue = this._evaluateCell(right, environment);\n        switch (op) {\n            case '+': return leftValue + rightValue;\n            case '-': return leftValue - rightValue;\n            case '*': return leftValue * rightValue;\n            case '/': return leftValue / rightValue;\n            default: throw new NotImplementedError(`Unknown binary operator: '${op}'`);\n        }\n    }\n\n    _evaluateFunction(functionName, args, environment) {\n        let func = environment.getFunction(functionName);\n        func = func instanceof Function ? { isMacro: false, function: func } : func;\n        return (func.isMacro === true) ?\n            this._evaluateMacro(functionName, func, args, environment) :\n            this._evaluateSpreadsheetFunction(functionName, func, args, environment);\n    }\n\n    _evaluateSpreadsheetFunction(functionName, func, args, environment) {\n        const argumentValues = args.map(arg => this._evaluateExpression(arg, environment));\n        try {\n            return func.function(...argumentValues);\n        } catch (ex) {\n            throw new FunctionEvaluationError(functionName, ex);\n        }\n    }\n\n    _evaluateMacro(macroName, macro, args, environment) {\n        const argsLazyValues = args.map(arg => () => this._evaluateExpression(arg, environment));\n        try {\n            return macro.function(...argsLazyValues);\n        } catch (ex) {\n            throw new FunctionEvaluationError(macroName, ex);\n        }\n    }\n\n    _evaluateRange(from, to, environment) {\n        return Helpers.positionsInRange(from, to)\n            .map(pos => Helpers.makePosition(pos.col, pos.row))\n            .map(pos => this._evaluateReference(pos, environment));\n    }\n}\n","export default class ReferencesMap {\n    constructor() {\n        this._referencesFrom = new Map();\n        this._referencesTo = new Map();\n    }\n\n    addReferences(positionFrom, referencesTo) {\n        if (!this._referencesFrom.has(positionFrom))\n            this._referencesFrom.set(positionFrom, new Set(referencesTo));\n\n        for (let referenceTo of referencesTo) {\n            this._referencesFrom.get(positionFrom).add(referenceTo);\n\n            if (!this._referencesTo.has(referenceTo))\n                this._referencesTo.set(referenceTo, new Set());\n            this._referencesTo.get(referenceTo).add(positionFrom);\n        }\n    }\n\n    removeReferencesFrom(position) {\n        // TODO: test this code works properly\n        const targetNodes = this._referencesFrom.get(position);\n        if (targetNodes) {\n            for (let target of targetNodes)\n                this._referencesTo.get(target).delete(position);\n            this._referencesFrom.delete(position);\n        }\n    }\n\n    cellsDependingOn(position) {\n        const visited = new Set();\n        const toVisitStack = [position];\n        while (toVisitStack.length > 0) {\n            const current = toVisitStack.pop();\n            visited.add(current);\n            const neighbors = this._referencesTo.has(current) ?\n                [...this._referencesTo.get(current)].filter(n => !visited.has(n)) : [];\n            const newNeighbors = neighbors.filter(n => !visited.has(n));\n            toVisitStack.push(...newNeighbors);\n        }\n        return visited;\n    }\n}\n","import { Tokenizer } from './tokenizer';\nimport Parser from './parser';\nimport Evaluator from './evaluator';\nimport { UnknownFunctionError } from './errors';\nimport ReferencesMap from './referencesMap';\n\nexport class Environment {\n    constructor(cells, functions, cellsChangedListener) {\n        this.cells = cells;\n        this.functions = functions;\n        this.onCellsChanged = cellsChangedListener;\n        this._parser = new Parser(new Tokenizer());\n        this._evaluator = new Evaluator();\n\n        this._expressionsCache = new Map(); // { position => expression tree (AST) }\n        this._valuesCache = new Map(); // { position => value; }\n        this._referencesMap = new ReferencesMap();\n    }\n\n    getText(position) {\n        return this.cells.has(position) ? this.cells.get(position).toString() : \"\";\n    }\n\n    setText(position, value) {\n        this.cells.set(position, value);\n\n        const affectedCells = this._referencesMap.cellsDependingOn(position);\n        for (let pos of affectedCells)\n            this._valuesCache.delete(pos);\n\n        this._expressionsCache.delete(position);\n        this._referencesMap.removeReferencesFrom(position);\n\n        this.onCellsChanged([...affectedCells]); // TODO: should this remain a Set?\n    }\n\n    getExpression(position) {\n        if (this._expressionsCache.has(position))\n            return this._expressionsCache.get(position);\n\n        const text = this.cells.has(position) ? this.cells.get(position) : null;\n        const { parsed, references } = this._parser.parse(text);\n        this._expressionsCache.set(position, parsed);\n        this._referencesMap.addReferences(position, references);\n        return parsed;\n    }\n\n    getValue(position) {\n        if (this._valuesCache.has(position))\n            return this._valuesCache.get(position);\n\n        const result = this._evaluator.evaluateCellAt(position, this.getExpression(position), this);\n        this._valuesCache.set(position, result);\n        return result;\n    }\n\n    evaluateQuery(expression) {\n        const { parsed, _ } = this._parser.parse(expression);\n        return this._evaluator.evaluateQuery(parsed, this);\n    }\n\n    getFunction(name) {\n        if (!this.functions.has(name))\n            throw new UnknownFunctionError(name);\n        return this.functions.get(name);\n    }\n}","import { Environment } from './environment';\nimport * as Helpers from './helpers';\nexport { Helpers };\nexport * from './errors';\n\nexport class Spreadsheet {\n    constructor(cells = new Map(), functions = new Map(), onCellsChanged = (() => { })) {\n        this.cells = cells instanceof Map ? cells : new Map(Object.entries(cells));\n        this.functions = functions instanceof Map ? functions : new Map(Object.entries(functions));\n        this._environment = new Environment(this.cells, this.functions, onCellsChanged);\n    }\n\n    text(position) {\n        return this._environment.getText(position);\n    }\n\n    set(position, text) {\n        this._environment.setText(position, text);\n    }\n\n    value(position) {\n        return this._environment.getValue(position);\n    }\n\n    query(expression) {\n        return this._environment.evaluateQuery(expression);\n    }\n}"],"names":["Helpers.parsePosition","Helpers.makePosition","Helpers.positionsInRange"],"mappings":"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"}