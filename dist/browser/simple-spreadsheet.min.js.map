{"version":3,"file":"simple-spreadsheet.min.js","sources":["../../src/spreadsheet/errors.js","../../src/spreadsheet/tokenStream.js","../../src/spreadsheet/tokenizer.js","../../src/spreadsheet/expressions.js","../../src/spreadsheet/helpers.js","../../src/spreadsheet/parser.js","../../src/spreadsheet/evaluator.js","../../src/spreadsheet/referencesMap.js","../../src/spreadsheet/environment.js","../../src/spreadsheet/spreadsheet.js"],"sourcesContent":["export class NotImplementedError extends Error {\r\n    constructor(message) { super(message); }\r\n    toString() { return `Not implemented: ${this.message}` }\r\n}\r\n\r\nexport class SpreadsheetError extends Error { }\r\n\r\nexport class ParsingError extends SpreadsheetError {\r\n    constructor(message) { super(message); }\r\n    toString() { return `Syntax error: ${this.message}`; }\r\n}\r\n\r\nexport class RuntimeError extends SpreadsheetError {\r\n    constructor(message) { super(message); }\r\n    toString() { return `Evaluation error: ${this.message}`; }\r\n}\r\n\r\nexport class ReferencedCellError extends RuntimeError {\r\n    constructor(cell) {\r\n        super(`Error in referenced cell: ${cell}`);\r\n        this.cell = cell;\r\n    }\r\n}\r\n\r\nexport class CircularReferenceError extends RuntimeError {\r\n    constructor(cells) {\r\n        super(`Circular reference detected: ${cells.join(' -> ')}`);\r\n        this.cells = cells;\r\n    }\r\n}\r\n\r\nexport class FunctionEvaluationError extends RuntimeError {\r\n    constructor(functionName, error) {\r\n        super(`Error in function ${functionName}: ${error}`)\r\n        this.functionName = functionName;\r\n        this.error = error;\r\n    }\r\n}\r\n\r\nexport class RangeReferenceNotAllowedError extends RuntimeError {\r\n    constructor() { super(`Range references are allowed only as references to functions`); }\r\n}\r\n\r\nexport class UnknownFunctionError extends RuntimeError {\r\n    constructor(functionName) {\r\n        super(`Unknown function: ${functionName}`);\r\n        this.functionName = functionName;\r\n    }\r\n}","import { ParsingError } from \"./errors\";\r\n\r\nexport default class TokenStream {\r\n    constructor(tokens) {\r\n        this._tokens = tokens;\r\n        this._currentPos = 0;\r\n    }\r\n\r\n    peek() {\r\n        return this._tokens[this._currentPos] || null;\r\n    }\r\n\r\n    expect(...types) {\r\n        const token = this.peek();\r\n        if (token !== null && types.includes(token.type)) {\r\n            this._currentPos++;\r\n            return token;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    require(...types) {\r\n        const token = this.expect(...types);\r\n        if (token === null)\r\n            throw new ParsingError(`Unexpected ${this.peek().type.description}, expected ${types.map(sym => sym.description).join(' or ')}`);\r\n        return token;\r\n    }\r\n}","import { ParsingError } from './errors';\r\nimport TokenStream from './tokenStream';\r\n\r\nexport const TokenType = Object.freeze({\r\n    // Note: strings must be unique, because they are used for comparison\r\n    EOF: Symbol('end of formula'),\r\n    WHITESPACE: Symbol('whitespace'),\r\n    PLUS: Symbol('+'),\r\n    MINUS: Symbol('-'),\r\n    STAR: Symbol('*'),\r\n    SLASH: Symbol('/'),\r\n    LPAREN: Symbol('opening parenthesis'),\r\n    RPAREN: Symbol('closing parenthesis'),\r\n    COLON: Symbol(':'),\r\n    EQUALS: Symbol('='),\r\n    COMMA: Symbol('comma'),\r\n    NUMBER: Symbol('number'),\r\n    STRING: Symbol('string'),\r\n    IDENTIFIER: Symbol('identifier'),\r\n});\r\n\r\nexport class Tokenizer {\r\n    constructor() {\r\n        this._rules = [\r\n            // NUMBER and IDENTIFIER are used the most so keep them at the top (for performance reasons - it makes a difference, I measured it)\r\n            // Patterns usually start with ^ so they match the start of the remaining\r\n            // string, not anywhere in the middle.\r\n            { pattern: /^\\d+(?:\\.\\d+)?/, type: TokenType.NUMBER },\r\n            { pattern: /^[a-zA-Z]\\w+/, type: TokenType.IDENTIFIER },\r\n            { pattern: /^\"(?:[^\"\\\\]|\\\\.)*\"/, type: TokenType.STRING },\r\n            { pattern: /^$/, type: TokenType.EOF },\r\n        ];\r\n\r\n        this._operators = {\r\n            ' ': TokenType.WHITESPACE,\r\n            '\\t': TokenType.WHITESPACE,\r\n            '\\r': TokenType.WHITESPACE,\r\n            '\\n': TokenType.WHITESPACE,\r\n            '+': TokenType.PLUS,\r\n            '-': TokenType.MINUS,\r\n            '*': TokenType.STAR,\r\n            '/': TokenType.SLASH,\r\n            '(': TokenType.LPAREN,\r\n            ')': TokenType.RPAREN,\r\n            '=': TokenType.EQUALS,\r\n            ':': TokenType.COLON,\r\n            ',': TokenType.COMMA,\r\n        }\r\n    }\r\n\r\n    tokenize(text) {\r\n        const tokens = [];\r\n        let remaining = text;\r\n        while (remaining.length > 0) {\r\n            const token = this._nextToken(remaining);\r\n            tokens.push(token);\r\n            remaining = remaining.slice(token.value.length);\r\n        }\r\n        tokens.push({ type: TokenType.EOF, value: '' });\r\n        return new TokenStream(tokens.filter(token => token.type !== TokenType.WHITESPACE));\r\n    }\r\n\r\n    _nextToken(text) {\r\n        const firstChar = text[0];\r\n        const operator = this._operators[firstChar];\r\n        if (operator !== undefined) return { type: operator, value: firstChar };\r\n\r\n        for (let rule of this._rules) {\r\n            const match = text.match(rule.pattern);\r\n            if (match !== null)\r\n                return { type: rule.type, value: match[0] };\r\n        }\r\n        throw new ParsingError(`Unknown token at '${text}'`);\r\n    }\r\n}\r\n","export class Expression { }\r\n\r\nexport class Value extends Expression {\r\n    constructor(value) { super(); this.value = value; }\r\n    toString() { return this.value.constructor === String ? `\"${this.value}\"` : `${this.value}`; }\r\n}\r\n\r\nexport class Reference extends Expression {\r\n    // TODO: Maybe refactor to only hold single property?\r\n    // Normalize position?\r\n    constructor(col, row) { super(); this.col = col; this.row = row; }\r\n    toString() { return `${this.col}${this.row}`; }\r\n}\r\n\r\nexport class BinaryOp extends Expression {\r\n    constructor(left, op, right) { super(); this.left = left; this.op = op; this.right = right; }\r\n    toString() { return `(${this.left} ${this.op} ${this.right})`; }\r\n}\r\n\r\nexport class UnaryOp extends Expression {\r\n    constructor(op, value) { super(); this.op = op; this.value = value; }\r\n    toString() { return `${this.op}${this.value}`; }\r\n}\r\n\r\nexport class FunctionCall extends Expression {\r\n    constructor(functionName, args) { super(); this.functionName = functionName; this.args = args; }\r\n    toString() { return `${this.functionName}(${this.args.join(', ')})`; }\r\n}\r\n\r\nexport class Range extends Expression {\r\n    constructor(from, to) { super(); this.from = from; this.to = to; }\r\n    toString() { return `${this.from}:${this.to}`; }\r\n}","export function positionsInRange(from, to) {\r\n    const positions = [];\r\n    // TODO: Use flatMap?\r\n    for (let col of _range(columnIndex(from.col), columnIndex(to.col)))\r\n        for (let row of _range(from.row, to.row))\r\n            positions.push({ col: columnLetter(col), row: row });\r\n    return positions;\r\n}\r\n\r\nfunction _range(from, to) {\r\n    return from <= to\r\n        ? Array.from({ length: to - from + 1 }, (_, i) => i + from)\r\n        : Array.from({ length: from - to + 1 }, (_, i) => from - i);\r\n}\r\n\r\nexport function parsePosition(position) {\r\n    const positionParts = position.match(/^([A-Za-z]+)(\\d+)$/);\r\n    return positionParts &&\r\n        { col: positionParts[1], row: parseInt(positionParts[2]) };\r\n}\r\n\r\nexport function makePosition(col, row) {\r\n    return `${col}${row}`;\r\n}\r\n\r\nexport function columnIndex(colLetter) {\r\n    return colLetter.charCodeAt(0) - 65;\r\n}\r\n\r\nexport function columnLetter(colIndex) {\r\n    return String.fromCharCode(colIndex + 65);\r\n}","import { TokenType } from './tokenizer';\r\nimport { ParsingError, NotImplementedError } from './errors';\r\nimport { Value, Reference, BinaryOp, UnaryOp, Range, FunctionCall } from './expressions';\r\nimport * as Helpers from './helpers';\r\n\r\nexport default class Parser {\r\n    constructor(tokenizer) {\r\n        this._tokenizer = tokenizer;\r\n        this._tokens = null;\r\n    }\r\n\r\n    // cell => empty | '=' expression EOF | number | string\r\n    parse(text) {\r\n        const needsParsing = text !== null && text !== undefined && text.constructor === String;\r\n        if (!needsParsing)\r\n            return { parsed: new Value(text), references: [] };\r\n\r\n        const isFormula = text[0] === '='; // TODO: add test with and without whitespace\r\n        if (isFormula) {\r\n            this._tokens = this._tokenizer.tokenize(text);\r\n            this._tokens.require(TokenType.EQUALS);\r\n            const parsed = this._parseExpression();\r\n            this._tokens.require(TokenType.EOF);\r\n            const references = this._referencesIn(parsed);\r\n            return { parsed, references };\r\n        }\r\n\r\n        // number\r\n        if (text.match(/^[+-]?\\d+(?:\\.\\d+)?$/))\r\n            return { parsed: new Value(parseFloat(text)), references: [] };\r\n\r\n        // string\r\n        return { parsed: new Value(text), references: [] };\r\n    }\r\n\r\n    // expression => term\r\n    _parseExpression() {\r\n        return this._parseTerm();\r\n    }\r\n\r\n    // term => factor (('+'|'-') factor)*\r\n    _parseTerm() {\r\n        let left = this._parseFactor();\r\n        let operation;\r\n        while ((operation = this._tokens.expect(TokenType.PLUS, TokenType.MINUS)) !== null) {\r\n            left = new BinaryOp(left, operation.value, this._parseFactor());\r\n        }\r\n        return left;\r\n    }\r\n\r\n    // factor => unary (('*'|'/') unary)*\r\n    _parseFactor() {\r\n        let left = this._parseRange();\r\n        let operation;\r\n        while ((operation = this._tokens.expect(TokenType.STAR, TokenType.SLASH)) !== null) {\r\n            left = new BinaryOp(left, operation.value, this._parseRange());\r\n        }\r\n        return left;\r\n    }\r\n\r\n    // range => unary (':' unary)*\r\n    _parseRange() {\r\n        // TODO: Make ranges first-class\r\n        return this._parseUnary();\r\n    }\r\n\r\n    // unary => ('+'|'-') unary | call\r\n    _parseUnary() {\r\n        const operation = this._tokens.expect(TokenType.PLUS, TokenType.MINUS);\r\n        return operation !== null\r\n            ? new UnaryOp(operation.value, this._parseUnary())\r\n            : this._parseValue();\r\n    }\r\n\r\n    // value => number | string | rangeReference | reference | parenthesized | functionCall\r\n    _parseValue() {\r\n        if (this._tokens.expect(TokenType.LPAREN))\r\n            return this._finishParenthesized();\r\n\r\n        const number = this._tokens.expect(TokenType.NUMBER)\r\n        if (number !== null)\r\n            return new Value(parseFloat(number.value));\r\n\r\n        const string = this._tokens.expect(TokenType.STRING);\r\n        if (string !== null)\r\n            return this._parseString(string);\r\n\r\n\r\n        const identifier = this._tokens.expect(TokenType.IDENTIFIER);\r\n        if (identifier !== null) {\r\n            if (this._tokens.expect(TokenType.COLON))\r\n                return this._finishRangeReference(identifier);\r\n\r\n            if (this._tokens.expect(TokenType.LPAREN))\r\n                return this._finishFunctionCall(identifier);\r\n\r\n            return this._parseReference(identifier.value);\r\n        }\r\n        throw new ParsingError(`Unexpected ${this._tokens.peek().type.description}, expected an expression or value`)\r\n    }\r\n\r\n    // parenthesized => '(' expression ')'\r\n    _finishParenthesized() {\r\n        const contents = this._parseExpression();\r\n        this._tokens.require(TokenType.RPAREN);\r\n        return contents;\r\n    }\r\n\r\n    _parseString(string) {\r\n        const withoutQuotes = string.value.substring(1, string.value.length - 1);\r\n        const escapedString = withoutQuotes.replace(/\\\\(.)/g, '$1'); // TODO: check escaped characters are escapable\r\n        return new Value(escapedString);\r\n    }\r\n\r\n    // rangeReference => IDENTIFIER ':' IDENTIFIER\r\n    _finishRangeReference(start) {\r\n        // start identifier and : are already parsed\r\n        const end = this._tokens.require(TokenType.IDENTIFIER);\r\n        const from = this._parseReference(start.value);\r\n        const to = this._parseReference(end.value);\r\n        return new Range(from, to);\r\n    }\r\n\r\n    // functionCall => IDENTIFIER ('(' arguments ')')*\r\n    _finishFunctionCall(identifier) {\r\n        // TODO: Test or remove nested function calls such as FOO()()\r\n        // Or check for function return types at runtime?\r\n\r\n        const args = this._parseArguments();\r\n        this._tokens.expect(TokenType.RPAREN);\r\n        return new FunctionCall(identifier.value, args);\r\n    }\r\n\r\n    // reference => [A-Za-z]+\\d+\r\n    _parseReference(reference) {\r\n        const position = Helpers.parsePosition(reference);\r\n        if (position === null)\r\n            throw new ParsingError(`Invalid format of cell reference: ${reference}`);\r\n        return new Reference(position.col, position.row);\r\n    }\r\n\r\n    // arguments => (expression (',' expression)*)?\r\n    _parseArguments() {\r\n        const args = [];\r\n        while (this._tokens.peek().type !== TokenType.RPAREN) {\r\n            if (args.length != 0)\r\n                this._tokens.require(TokenType.COMMA);\r\n            args.push(this._parseExpression());\r\n        }\r\n        return args;\r\n    }\r\n\r\n    _referencesIn(expression) {\r\n        switch (expression.constructor) {\r\n            case Value:\r\n                return [];\r\n            case Reference:\r\n                return [Helpers.makePosition(expression.col, expression.row)];\r\n            case UnaryOp:\r\n                return this._referencesIn(expression.value);\r\n            case BinaryOp:\r\n                return [...this._referencesIn(expression.left), ...this._referencesIn(expression.right)];\r\n            case FunctionCall:\r\n                return expression.args.flatMap(arg => this._referencesIn(arg));\r\n            case Range:\r\n                return Helpers.positionsInRange(expression.from, expression.to)\r\n                    .map(pos => Helpers.makePosition(pos.col, pos.row));\r\n            default:\r\n                throw new NotImplementedError(`Unknown expression type: ${typeof expression}`);\r\n        }\r\n    }\r\n}","import { Value, Reference, BinaryOp, FunctionCall, Range, UnaryOp } from './expressions';\r\nimport { RuntimeError, ParsingError, CircularReferenceError, ReferencedCellError, NotImplementedError, RangeReferenceNotAllowedError, FunctionEvaluationError } from './errors';\r\nimport * as Helpers from './helpers';\r\n\r\nclass CircularRefInternal extends Error {\r\n    constructor(position, circlePositions) { super(); this.position = position; this.circlePositions = circlePositions; }\r\n}\r\n\r\nexport default class Evaluator {\r\n    constructor() {\r\n        this.visitedCellStack = [];\r\n    }\r\n\r\n    evaluateCellAt(position, expression, environment) {\r\n        if (this.visitedCellStack.includes(position))\r\n            throw new CircularRefInternal(position, [...this.visitedCellStack, position]);\r\n\r\n        this.visitedCellStack.push(position);\r\n        try {\r\n            const result = this._evaluateCell(expression, environment);\r\n            this.visitedCellStack.pop();\r\n            return result;\r\n        } catch (ex) {\r\n            this.visitedCellStack.pop()\r\n            // Normal errors propagate as usual, but CircularRefInternal is used\r\n            // only to propagate the exception to the originating cell internally\r\n            // (so it doesn't get reported just as an error in a referenced cell).\r\n            // Once the CircularRefInternal reaches back to the originating cell,\r\n            // we turn it into a normal CircularReferenceError.\r\n            if (ex instanceof CircularRefInternal && ex.position === position) {\r\n                throw new CircularReferenceError(ex.circlePositions);\r\n            } else {\r\n                throw ex;\r\n            }\r\n        }\r\n    }\r\n\r\n    evaluateQuery(expression, environment) {\r\n        return this._evaluateCell(expression, environment);\r\n    }\r\n\r\n    _evaluateCell(expression, environment) {\r\n        switch (expression.constructor) {\r\n            case Value:\r\n                return expression.value;\r\n            case Reference:\r\n                return this._evaluateReference(Helpers.makePosition(expression.col, expression.row), environment);\r\n            case UnaryOp:\r\n                return this._evaluateUnary(expression.op, expression.value, environment);\r\n            case BinaryOp:\r\n                return this._evaluateBinary(expression.left, expression.op, expression.right, environment);\r\n            case FunctionCall:\r\n                return this._evaluateFunction(expression.functionName, expression.args, environment);\r\n            case Range:\r\n                throw new RangeReferenceNotAllowedError();\r\n            default:\r\n                throw new NotImplementedError(`Unknown expression type: ${typeof expression}`);\r\n        }\r\n    }\r\n\r\n    _evaluateReference(position, environment) {\r\n        try {\r\n            return environment.getValue(position);\r\n        } catch (ex) {\r\n            if (ex instanceof ParsingError || ex instanceof RuntimeError)\r\n                throw new ReferencedCellError(position);\r\n            else throw ex;\r\n        }\r\n    }\r\n\r\n    _evaluateExpression(value, environment) {\r\n        switch (value.constructor) {\r\n            case Range: return this._evaluateRange(value.from, value.to, environment);\r\n            default: return this._evaluateCell(value, environment);\r\n        }\r\n    }\r\n\r\n    _evaluateUnary(op, expression, environment) {\r\n        const value = this._evaluateCell(expression, environment);\r\n        switch (op) {\r\n            case '+': return value;\r\n            case '-': return -value;\r\n            default: throw new NotImplementedError(`Unknown unary operator: '${op}'`);\r\n        }\r\n    }\r\n\r\n    _evaluateBinary(left, op, right, environment) {\r\n        const leftValue = this._evaluateCell(left, environment);\r\n        const rightValue = this._evaluateCell(right, environment);\r\n        switch (op) {\r\n            case '+': return leftValue + rightValue;\r\n            case '-': return leftValue - rightValue;\r\n            case '*': return leftValue * rightValue;\r\n            case '/': return leftValue / rightValue;\r\n            default: throw new NotImplementedError(`Unknown binary operator: '${op}'`);\r\n        }\r\n    }\r\n\r\n    _evaluateFunction(functionName, args, environment) {\r\n        let func = environment.getFunction(functionName);\r\n        func = func instanceof Function ? { isMacro: false, function: func } : func;\r\n        return (func.isMacro === true) ?\r\n            this._evaluateMacro(functionName, func, args, environment) :\r\n            this._evaluateSpreadsheetFunction(functionName, func, args, environment);\r\n    }\r\n\r\n    _evaluateSpreadsheetFunction(functionName, func, args, environment) {\r\n        const argumentValues = args.map(arg => this._evaluateExpression(arg, environment));\r\n        try {\r\n            return func.function(...argumentValues);\r\n        } catch (ex) {\r\n            throw new FunctionEvaluationError(functionName, ex);\r\n        }\r\n    }\r\n\r\n    _evaluateMacro(macroName, macro, args, environment) {\r\n        const argsLazyValues = args.map(arg => () => this._evaluateExpression(arg, environment));\r\n        try {\r\n            return macro.function(...argsLazyValues);\r\n        } catch (ex) {\r\n            throw new FunctionEvaluationError(macroName, ex);\r\n        }\r\n    }\r\n\r\n    _evaluateRange(from, to, environment) {\r\n        return Helpers.positionsInRange(from, to)\r\n            .map(pos => Helpers.makePosition(pos.col, pos.row))\r\n            .map(pos => this._evaluateReference(pos, environment));\r\n    }\r\n}\r\n","export default class ReferencesMap {\r\n    constructor() {\r\n        this._referencesFrom = new Map(); // { position => Set(referencesFrom) }\r\n        this._referencesTo = new Map(); // { position => Set(referencedBy) }\r\n    }\r\n\r\n    addReferences(positionFrom, referencesTo) {\r\n        if (!this._referencesFrom.has(positionFrom))\r\n            this._referencesFrom.set(positionFrom, new Set(referencesTo));\r\n\r\n        for (let referenceTo of referencesTo) {\r\n            this._referencesFrom.get(positionFrom).add(referenceTo);\r\n\r\n            if (!this._referencesTo.has(referenceTo))\r\n                this._referencesTo.set(referenceTo, new Set());\r\n            this._referencesTo.get(referenceTo).add(positionFrom);\r\n        }\r\n    }\r\n\r\n    removeReferencesFrom(position) {\r\n        // TODO: test this code works properly\r\n        const targetNodes = this._referencesFrom.get(position);\r\n        if (targetNodes) {\r\n            for (let target of targetNodes)\r\n                this._referencesTo.get(target).delete(position);\r\n            this._referencesFrom.delete(position);\r\n        }\r\n    }\r\n\r\n    cellsDependingOn(position) {\r\n        const visited = new Set();\r\n        const toVisitStack = [position];\r\n        while (toVisitStack.length > 0) {\r\n            const current = toVisitStack.pop();\r\n            visited.add(current);\r\n            const neighbors = this._referencesTo.has(current) ?\r\n                [...this._referencesTo.get(current)].filter(n => !visited.has(n)) : [];\r\n            const newNeighbors = neighbors.filter(n => !visited.has(n));\r\n            toVisitStack.push(...newNeighbors);\r\n        }\r\n        return visited;\r\n    }\r\n}\r\n","import { Tokenizer } from './tokenizer';\r\nimport Parser from './parser';\r\nimport Evaluator from './evaluator';\r\nimport { UnknownFunctionError, RuntimeError, ParsingError } from './errors';\r\nimport ReferencesMap from './referencesMap';\r\n\r\nexport class Environment {\r\n    constructor(cells, functions, cellsChangedListener) {\r\n        this.cells = cells; // { position => formula text }\r\n        this.functions = functions; // { name => function or macro }\r\n        this.onCellsChanged = cellsChangedListener;\r\n        this._parser = new Parser(new Tokenizer());\r\n        this._evaluator = new Evaluator();\r\n\r\n        this._expressionsCache = new Map(); // { position => expression tree (AST) }\r\n        this._valuesCache = new Map(); // { position => value; }\r\n        this._errorsCache = new Map(); // { position => error; }\r\n        this._referencesMap = new ReferencesMap(); // tracks references between cells\r\n    }\r\n\r\n    getText(position) {\r\n        return this.cells.has(position) ? this.cells.get(position).toString() : \"\";\r\n    }\r\n\r\n    setText(position, text) {\r\n        this.cells.set(position, text);\r\n\r\n        // affectedCells also contains `position`\r\n        const affectedCells = this._referencesMap.cellsDependingOn(position);\r\n        for (let pos of affectedCells) {\r\n            this._valuesCache.delete(pos);\r\n            this._errorsCache.delete(pos);\r\n        }\r\n\r\n        this._expressionsCache.delete(position);\r\n        this._referencesMap.removeReferencesFrom(position);\r\n\r\n        this.onCellsChanged([...affectedCells]); // TODO: should this remain a Set?\r\n    }\r\n\r\n    getExpression(position) {\r\n        if (this._expressionsCache.has(position))\r\n            return this._expressionsCache.get(position);\r\n\r\n        if (this._errorsCache.has(position))\r\n            throw this._errorsCache.get(position);\r\n\r\n        const text = this.cells.has(position) ? this.cells.get(position) : null;\r\n        try {\r\n            const { parsed, references } = this._parser.parse(text);\r\n            this._expressionsCache.set(position, parsed);\r\n            this._referencesMap.addReferences(position, references);\r\n            return parsed;\r\n        } catch (ex) {\r\n            if (ex instanceof ParsingError)\r\n                this._errorsCache.set(position, ex);\r\n            throw ex;\r\n        }\r\n    }\r\n\r\n    getValue(position) {\r\n        if (this._valuesCache.has(position))\r\n            return this._valuesCache.get(position);\r\n\r\n        if (this._errorsCache.has(position))\r\n            throw this._errorsCache.get(position);\r\n\r\n        try {\r\n            const result = this._evaluator.evaluateCellAt(position, this.getExpression(position), this);\r\n            this._valuesCache.set(position, result);\r\n            return result;\r\n        } catch (ex) {\r\n            if (ex instanceof RuntimeError)\r\n                this._errorsCache.set(position, ex);\r\n            throw ex;\r\n        }\r\n    }\r\n\r\n    evaluateQuery(expression) {\r\n        const { parsed, _ } = this._parser.parse(expression);\r\n        return this._evaluator.evaluateQuery(parsed, this);\r\n    }\r\n\r\n    getFunction(name) {\r\n        if (!this.functions.has(name))\r\n            throw new UnknownFunctionError(name);\r\n        return this.functions.get(name);\r\n    }\r\n}","import { Environment } from './environment';\r\nimport * as Helpers from './helpers';\r\nexport { Helpers };\r\nexport * from './errors';\r\n\r\nexport class Spreadsheet {\r\n    constructor(cells = new Map(), functions = new Map(), onCellsChanged = (() => { })) {\r\n        this.cells = cells instanceof Map ? cells : new Map(Object.entries(cells));\r\n        this.functions = functions instanceof Map ? functions : new Map(Object.entries(functions));\r\n        this._environment = new Environment(this.cells, this.functions, onCellsChanged);\r\n    }\r\n\r\n    text(position) {\r\n        return this._environment.getText(position);\r\n    }\r\n\r\n    set(position, text) {\r\n        this._environment.setText(position, text);\r\n    }\r\n\r\n    value(position) {\r\n        return this._environment.getValue(position);\r\n    }\r\n\r\n    query(expression) {\r\n        return this._environment.evaluateQuery(expression);\r\n    }\r\n}"],"names":["NotImplementedError","Error","[object Object]","message","super","this","SpreadsheetError","ParsingError","RuntimeError","ReferencedCellError","cell","CircularReferenceError","cells","join","FunctionEvaluationError","functionName","error","RangeReferenceNotAllowedError","UnknownFunctionError","TokenStream","tokens","_tokens","_currentPos","types","token","peek","includes","type","expect","description","map","sym","TokenType","Object","freeze","EOF","Symbol","WHITESPACE","PLUS","MINUS","STAR","SLASH","LPAREN","RPAREN","COLON","EQUALS","COMMA","NUMBER","STRING","IDENTIFIER","Tokenizer","_rules","pattern","_operators"," ","\t","\r","\n","+","-","*","/","(",")","=",":",",","text","remaining","length","_nextToken","push","slice","value","filter","firstChar","operator","undefined","rule","match","Expression","Value","constructor","String","Reference","col","row","BinaryOp","left","op","right","UnaryOp","FunctionCall","args","Range","from","to","positionsInRange","positions","_range","columnIndex","columnLetter","Array","_","i","parsePosition","position","positionParts","parseInt","makePosition","colLetter","charCodeAt","colIndex","fromCharCode","Parser","tokenizer","_tokenizer","parsed","references","tokenize","require","_parseExpression","_referencesIn","parseFloat","_parseTerm","operation","_parseFactor","_parseRange","_parseUnary","_parseValue","_finishParenthesized","number","string","_parseString","identifier","_finishRangeReference","_finishFunctionCall","_parseReference","contents","escapedString","substring","replace","start","end","_parseArguments","reference","Helpers.parsePosition","expression","Helpers.makePosition","flatMap","arg","Helpers.positionsInRange","pos","CircularRefInternal","circlePositions","Evaluator","visitedCellStack","environment","result","_evaluateCell","pop","ex","_evaluateReference","_evaluateUnary","_evaluateBinary","_evaluateFunction","getValue","_evaluateRange","leftValue","rightValue","func","getFunction","Function","isMacro","function","_evaluateMacro","_evaluateSpreadsheetFunction","argumentValues","_evaluateExpression","macroName","macro","argsLazyValues","ReferencesMap","_referencesFrom","Map","_referencesTo","positionFrom","referencesTo","has","set","Set","referenceTo","get","add","targetNodes","target","delete","visited","toVisitStack","current","newNeighbors","n","Environment","functions","cellsChangedListener","onCellsChanged","_parser","_evaluator","_expressionsCache","_valuesCache","_errorsCache","_referencesMap","toString","affectedCells","cellsDependingOn","removeReferencesFrom","parse","addReferences","evaluateCellAt","getExpression","evaluateQuery","name","Spreadsheet","entries","_environment","getText","setText"],"mappings":"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"}