{"version":3,"file":"simple-spreadsheet.min.js","sources":["../../src/spreadsheet/errors.js","../../src/spreadsheet/tokenStream.js","../../src/spreadsheet/tokenizer.js","../../src/spreadsheet/expressions.js","../../src/spreadsheet/helpers.js","../../src/spreadsheet/parser.js","../../src/spreadsheet/evaluator.js","../../src/spreadsheet/referencesMap.js","../../src/spreadsheet/environment.js","../../src/spreadsheet/spreadsheet.js"],"sourcesContent":["export class SpreadsheetError extends Error { }\n\nexport class ParsingError extends SpreadsheetError {\n    constructor(message) { super(message); }\n    toString() { return `Syntax error: ${this.message}`; }\n}\n\nexport class RuntimeError extends SpreadsheetError {\n    constructor(message) { super(message); }\n    toString() { return `Evaluation error: ${this.message}`; }\n}\n","import { ParsingError } from \"./errors\";\n\nexport default class TokenStream {\n    constructor(tokens) {\n        this._tokens = tokens;\n        this._currentPos = 0;\n    }\n\n    peek() {\n        return this._tokens[this._currentPos] || null;\n    }\n\n    expect(...types) {\n        const token = this.peek();\n        if (token !== null && types.includes(token.type)) {\n            this._currentPos++;\n            return token;\n        }\n        return null;\n    }\n\n    require(...types) {\n        const token = this.expect(...types);\n        if (token === null)\n            throw new ParsingError(`Unexpected ${this.peek().type.description}, expected ${types.map(sym => sym.description).join(' or ')}`);\n        return token;\n    }\n}","import { ParsingError } from './errors';\nimport TokenStream from './tokenStream';\n\nexport const TokenType = Object.freeze({\n    // Note: strings must be unique, because they are used for comparison\n    EOF: Symbol('end of formula'),\n    WHITESPACE: Symbol('whitespace'),\n    PLUS: Symbol('+'),\n    MINUS: Symbol('-'),\n    STAR: Symbol('*'),\n    SLASH: Symbol('/'),\n    LPAREN: Symbol('opening parenthesis'),\n    RPAREN: Symbol('closing parenthesis'),\n    COLON: Symbol(':'),\n    EQUALS: Symbol('='),\n    COMMA: Symbol('comma'),\n    NUMBER: Symbol('number'),\n    STRING: Symbol('string'),\n    IDENTIFIER: Symbol('identifier'),\n});\n\nexport class Tokenizer {\n    constructor() {\n        this._rules = [\n            // NUMBER and IDENTIFIER are used the most so keep them at the top (for performance reasons - it makes a difference, I measured it)\n            // Patterns usually start with ^ so they match the start of the remaining\n            // string, not anywhere in the middle.\n            { pattern: /^\\d+(?:\\.\\d+)?/, type: TokenType.NUMBER },\n            { pattern: /^[a-zA-Z]\\w+/, type: TokenType.IDENTIFIER },\n            { pattern: /^\"(?:[^\"\\\\]|\\\\.)*\"/, type: TokenType.STRING },\n            { pattern: /^$/, type: TokenType.EOF },\n        ];\n\n        this._operators = {\n            ' ': TokenType.WHITESPACE,\n            '\\t': TokenType.WHITESPACE,\n            '\\r': TokenType.WHITESPACE,\n            '\\n': TokenType.WHITESPACE,\n            '+': TokenType.PLUS,\n            '-': TokenType.MINUS,\n            '*': TokenType.STAR,\n            '/': TokenType.SLASH,\n            '(': TokenType.LPAREN,\n            ')': TokenType.RPAREN,\n            '=': TokenType.EQUALS,\n            ':': TokenType.COLON,\n            ',': TokenType.COMMA,\n        }\n    }\n\n    tokenize(text) {\n        const tokens = [];\n        let remaining = text;\n        while (remaining.length > 0) {\n            const token = this._nextToken(remaining);\n            tokens.push(token);\n            remaining = remaining.slice(token.value.length);\n        }\n        tokens.push({ type: TokenType.EOF, value: '' });\n        return new TokenStream(tokens.filter(token => token.type !== TokenType.WHITESPACE));\n    }\n\n    _nextToken(text) {\n        const firstChar = text[0];\n        const operator = this._operators[firstChar];\n        if (operator !== undefined) return { type: operator, value: firstChar };\n\n        for (let rule of this._rules) {\n            const match = text.match(rule.pattern);\n            if (match !== null)\n                return { type: rule.type, value: match[0] };\n        }\n        throw new ParsingError(`Unknown token at '${text}'`);\n    }\n}\n","export class Expression { }\n\nexport class Value extends Expression {\n    constructor(value) { super(); this.value = value; }\n    toString() { return this.value.constructor === String ? `\"${this.value}\"` : `${this.value}`; }\n}\n\nexport class Reference extends Expression {\n    // TODO: Maybe refactor to only hold single property?\n    // Normalize position?\n    constructor(col, row) { super(); this.col = col; this.row = row; }\n    toString() { return `${this.col}${this.row}`; }\n}\n\nexport class BinaryOp extends Expression {\n    constructor(left, op, right) { super(); this.left = left; this.op = op; this.right = right; }\n    toString() { return `(${this.left} ${this.op} ${this.right})`; }\n}\n\nexport class UnaryOp extends Expression {\n    constructor(op, value) { super(); this.op = op; this.value = value; }\n    toString() { return `${this.op}${this.value}`; }\n}\n\nexport class FunctionCall extends Expression {\n    constructor(functionName, args) { super(); this.functionName = functionName; this.args = args; }\n    toString() { return `${this.functionName}(${this.args.join(', ')})`; }\n}\n\nexport class Range extends Expression {\n    constructor(from, to) { super(); this.from = from; this.to = to; }\n    toString() { return `${this.from}:${this.to}`; }\n}","export function positionsInRange(from, to) {\n    const positions = [];\n    // TODO: Use flatMap?\n    for (let col of _range(columnIndex(from.col), columnIndex(to.col)))\n        for (let row of _range(from.row, to.row))\n            positions.push({ col: columnLetter(col), row: row });\n    return positions;\n}\n\nfunction _range(from, to) {\n    return from <= to\n        ? Array.from({ length: to - from + 1 }, (_, i) => i + from)\n        : Array.from({ length: from - to + 1 }, (_, i) => from - i);\n}\n\nexport function parsePosition(position) {\n    const positionParts = position.match(/^([A-Za-z]+)(\\d+)$/);\n    return positionParts &&\n        { col: positionParts[1], row: parseInt(positionParts[2]) };\n}\n\nexport function makePosition(col, row) {\n    return `${col}${row}`;\n}\n\nexport function columnIndex(colLetter) {\n    return colLetter.charCodeAt(0) - 65;\n}\n\nexport function columnLetter(colIndex) {\n    return String.fromCharCode(colIndex + 65);\n}","import { TokenType } from './tokenizer';\nimport { ParsingError } from './errors';\nimport { Value, Reference, BinaryOp, UnaryOp, Range, FunctionCall } from './expressions';\nimport * as Helpers from './helpers';\n\nexport default class Parser {\n    constructor(tokenizer) {\n        this._tokenizer = tokenizer;\n        this._tokens = null;\n    }\n\n    // cell => empty | '=' expression EOF | number | string\n    parse(text) {\n        // empty cell or other value\n        if (text === null || text === undefined || text.constructor !== String)\n            return { parsed: new Value(text), references: [] };\n\n        // formula\n        if (text.trimStart().startsWith('=')) {\n            this._tokens = this._tokenizer.tokenize(text);\n            this._tokens.require(TokenType.EQUALS);\n            const parsed = this._parseExpression();\n            this._tokens.require(TokenType.EOF);\n            // TODO: improve perf, maybe add to a set directly in _getReferences\n            const references = [...new Set(this._getReferences(parsed))];\n            return { parsed, references };\n        }\n\n        // number\n        if (text.match(/^[+-]?\\d+(?:\\.\\d+)?$/))\n            return { parsed: new Value(parseFloat(text)), references: [] };\n\n        // string\n        return { parsed: new Value(text), references: [] };\n    }\n\n    // expression => term\n    _parseExpression() {\n        return this._parseTerm();\n    }\n\n    // term => factor (('+'|'-') factor)*\n    _parseTerm() {\n        let left = this._parseFactor();\n        let operation;\n        while ((operation = this._tokens.expect(TokenType.PLUS, TokenType.MINUS)) !== null) {\n            left = new BinaryOp(left, operation.value, this._parseFactor());\n        }\n        return left;\n    }\n\n    // factor => unary (('*'|'/') unary)*\n    _parseFactor() {\n        let left = this._parseRange();\n        let operation;\n        while ((operation = this._tokens.expect(TokenType.STAR, TokenType.SLASH)) !== null) {\n            left = new BinaryOp(left, operation.value, this._parseRange());\n        }\n        return left;\n    }\n\n    // range => unary (':' unary)*\n    _parseRange() {\n        // TODO: Make ranges first-class\n        return this._parseUnary();\n    }\n\n    // unary => ('+'|'-') unary | call\n    _parseUnary() {\n        const operation = this._tokens.expect(TokenType.PLUS, TokenType.MINUS);\n        return operation !== null\n            ? new UnaryOp(operation.value, this._parseUnary())\n            : this._parseValue();\n    }\n\n    // value => number | string | rangeReference | reference | parenthesized | functionCall\n    _parseValue() {\n        if (this._tokens.expect(TokenType.LPAREN))\n            return this._finishParenthesized();\n\n        const number = this._tokens.expect(TokenType.NUMBER)\n        if (number !== null)\n            return new Value(parseFloat(number.value));\n\n        const string = this._tokens.expect(TokenType.STRING);\n        if (string !== null)\n            return this._parseString(string);\n\n\n        const identifier = this._tokens.expect(TokenType.IDENTIFIER);\n        if (identifier !== null) {\n            if (this._tokens.expect(TokenType.COLON))\n                return this._finishRangeReference(identifier);\n\n            if (this._tokens.expect(TokenType.LPAREN))\n                return this._finishFunctionCall(identifier);\n\n            return this._parseReference(identifier.value);\n        }\n        throw new ParsingError(`Unexpected ${this._tokens.peek().type.description}, expected an expression or value`)\n    }\n\n    // parenthesized => '(' expression ')'\n    _finishParenthesized() {\n        const contents = this._parseExpression();\n        this._tokens.require(TokenType.RPAREN);\n        return contents;\n    }\n\n    _parseString(string) {\n        const withoutQuotes = string.value.substring(1, string.value.length - 1);\n        const escapedString = withoutQuotes.replace(/\\\\(.)/g, '$1');\n        return new Value(escapedString);\n    }\n\n    // rangeReference => IDENTIFIER ':' IDENTIFIER\n    _finishRangeReference(start) {\n        // start identifier and : are already parsed\n        const end = this._tokens.require(TokenType.IDENTIFIER);\n        const from = this._parseReference(start.value);\n        const to = this._parseReference(end.value);\n        return new Range(from, to);\n    }\n\n    // functionCall => IDENTIFIER ('(' arguments ')')*\n    _finishFunctionCall(identifier) {\n        // TODO: Test or remove nested function calls such as FOO()()\n        // Or check for function return types at runtime?\n\n        const args = this._parseArguments();\n        this._tokens.expect(TokenType.RPAREN);\n        return new FunctionCall(identifier.value, args);\n    }\n\n    // reference => [A-Za-z]+\\d+\n    _parseReference(reference) {\n        const position = Helpers.parsePosition(reference);\n        if (position === null)\n            throw new ParsingError(`Invalid format of cell reference: ${reference}`);\n        return new Reference(position.col, position.row);\n    }\n\n    // arguments => (expression (',' expression)*)?\n    _parseArguments() {\n        const args = [];\n        while (this._tokens.peek().type !== TokenType.RPAREN) {\n            if (args.length != 0)\n                this._tokens.require(TokenType.COMMA);\n            args.push(this._parseExpression());\n        }\n        return args;\n    }\n\n    _getReferences(expression) {\n        switch (expression.constructor) {\n            case Value:\n                return [];\n            case Reference:\n                return [Helpers.makePosition(expression.col, expression.row)];\n            case UnaryOp:\n                return this._getReferences(expression.value);\n            case BinaryOp:\n                return [...this._getReferences(expression.left), ...this._getReferences(expression.right)];\n            case FunctionCall:\n                return expression.args.flatMap(arg => this._getReferences(arg));\n            case Range:\n                return Helpers.positionsInRange(expression.from, expression.to)\n                    .map(pos => Helpers.makePosition(pos.col, pos.row));\n            default:\n                throw new ParsingError(`Unknown expression type: ${typeof expression}`);\n        }\n    }\n}","import { Value, Reference, BinaryOp, FunctionCall, Range, UnaryOp } from './expressions';\nimport { RuntimeError, ParsingError } from './errors';\nimport * as Helpers from './helpers';\n\nclass CircularReferenceError extends Error {\n    constructor(message, cell) { super(message); this.cell = cell; }\n}\n\nexport default class Evaluator {\n    constructor() {\n        this.visitedCellStack = [];\n    }\n\n    evaluateCellAt(position, cell, environment) {\n        if (this.visitedCellStack.includes(position))\n            throw new CircularReferenceError(`Circular reference detected (${this.visitedCellStack.join(' -> ')} -> ${position})`, cell);\n\n        this.visitedCellStack.push(position);\n        try {\n            const result = this._evaluateCell(cell, environment);\n            this.visitedCellStack.pop();\n            return result;\n        } catch (ex) {\n            this.visitedCellStack.pop()\n            // Normal errors propagate as usual, but CircularReferenceError is used\n            // only to propagate the exception to the originating cell internally\n            // (so it doesn't get reported just as an error in a referenced cell).\n            // Once the CircularReferenceError reaches back to the originating cell,\n            // we turn it into a normal RuntimeError.\n            if (ex instanceof CircularReferenceError && ex.cell === cell) {\n                throw new RuntimeError(ex.message);\n            } else {\n                throw ex;\n            }\n        }\n    }\n\n    evaluateQuery(cell, environment) {\n        return this._evaluateCell(cell, environment);\n    }\n\n    _evaluateCell(cell, environment) {\n        switch (cell.constructor) {\n            case Value:\n                return cell.value;\n            case Reference:\n                return this._evaluateReference(Helpers.makePosition(cell.col, cell.row), environment);\n            case UnaryOp:\n                return this._evaluateUnary(cell.op, cell.value, environment);\n            case BinaryOp:\n                return this._evaluateBinary(cell.left, cell.op, cell.right, environment);\n            case FunctionCall:\n                return this._evaluateFunction(cell.functionName, cell.args, environment);\n            case Range:\n                throw new RuntimeError(`Range references are allowed only as arguments of functions`);\n            default:\n                throw new RuntimeError(`Unknown expression type: ${typeof cell}`);\n        }\n    }\n\n    _evaluateReference(position, environment) {\n        try {\n            return environment.getValue(position);\n        } catch (e) {\n            if (e instanceof ParsingError || e instanceof RuntimeError)\n                throw new RuntimeError(`Error in referenced cell ${position}`);\n            else throw e;\n        }\n    }\n\n    _evaluateExpression(value, environment) {\n        switch (value.constructor) {\n            case Range: return this._evaluateRange(value.from, value.to, environment);\n            default: return this._evaluateCell(value, environment);\n        }\n    }\n\n    _evaluateUnary(op, expression, environment) {\n        const value = this._evaluateCell(expression, environment);\n        switch (op) {\n            case '+': return value;\n            case '-': return -value;\n            default: throw new RuntimeError(`Unknown unary operator: '${op}'`);\n        }\n    }\n\n    _evaluateBinary(left, op, right, environment) {\n        const leftValue = this._evaluateCell(left, environment);\n        const rightValue = this._evaluateCell(right, environment);\n        switch (op) {\n            case '+': return leftValue + rightValue;\n            case '-': return leftValue - rightValue;\n            case '*': return leftValue * rightValue;\n            case '/': return leftValue / rightValue;\n            default: throw new RuntimeError(`Unknown binary operator: '${op}'`);\n        }\n    }\n\n    _evaluateFunction(functionName, args, environment) {\n        let func = environment.getFunction(functionName);\n        func = func instanceof Function ? { isMacro: false, function: func } : func;\n        return (func.isMacro === true) ?\n            this._evaluateMacro(functionName, func, args, environment) :\n            this._evaluateSpreadsheetFunction(functionName, func, args, environment);\n    }\n\n    _evaluateSpreadsheetFunction(functionName, func, args, environment) {\n        const argumentValues = this._evaluateArguments(functionName, args, environment);\n        try {\n            return func.function(...argumentValues);\n        } catch (ex) {\n            throw new RuntimeError(`Error in function ${functionName}: ${ex}`);\n        }\n    }\n\n    _evaluateArguments(functionName, args, environment) {\n        let evaluatedArgs = [];\n        for (let i = 0; i < args.length; i++) {\n            try {\n                evaluatedArgs.push(this._evaluateExpression(args[i], environment));\n            } catch (ex) {\n                throw new RuntimeError(`Error in function argument ${i + 1} in function ${functionName}: ${ex}`);\n            }\n        }\n        return evaluatedArgs;\n    }\n\n    _evaluateMacro(macroName, macro, args, environment) {\n        const argsLazyValues = args.map(arg => () => this._evaluateExpression(arg, environment));\n        try {\n            return macro.function(...argsLazyValues);\n        } catch (ex) {\n            throw new RuntimeError(`Error in macro ${macroName}: ${ex}`);\n        }\n    }\n\n    _evaluateRange(from, to, environment) {\n        return Helpers.positionsInRange(from, to)\n            .map(pos => Helpers.makePosition(pos.col, pos.row))\n            .map(pos => this._evaluateReference(pos, environment));\n    }\n}\n","export default class ReferencesMap {\n    constructor() {\n        this._referencesFrom = new Map();\n        this._referencesTo = new Map();\n    }\n\n    getReferencesFrom(position) { return this._referencesFrom.get(position); }\n    getReferencesTo(position) { return this._referencesTo.get(position); }\n\n    addReference(positionFrom, referenceTo) {\n        if (!this._referencesFrom.has(positionFrom))\n            this._referencesFrom.set(positionFrom, []);\n        this._referencesFrom.get(positionFrom).push(referenceTo);\n\n        if (!this._referencesTo.has(referenceTo))\n            this._referencesTo.set(referenceTo, []);\n        this._referencesTo.get(referenceTo).push(positionFrom);\n    }\n\n    removeReferencesFrom(position) {\n        const targetNodes = this._referencesFrom.get(position);\n        for (let target of targetNodes) {\n            const valueIndex = this._referencesTo.get(target).indexOf(position);\n            if (valueIndex > -1) this._referencesTo.get(target).splice(valueIndex, 1);\n        }\n        this._referencesFrom.delete(position);\n    }\n\n    getAffectedCells(position) {\n        // TODO: maybe optimize using stack and for loop?\n        const referencesTo = this.getReferencesTo(position);\n        if (!referencesTo) return [];\n\n        const recursiveReferences = referencesTo.flatMap(this.getAffectedCells.bind(this));\n        return [...referencesTo, ...recursiveReferences];\n    }\n}\n","import { Tokenizer } from './tokenizer';\nimport Parser from './parser';\nimport Evaluator from './evaluator';\nimport { RuntimeError } from './errors';\nimport ReferencesMap from './referencesMap';\n\nexport class Environment {\n    constructor(cells, functions, cellsChangedListener) {\n        this.cells = cells;\n        this.functions = functions;\n        this.onCellsChanged = cellsChangedListener;\n        this._parser = new Parser(new Tokenizer());\n        this._evaluator = new Evaluator();\n\n        this._expressionsCache = new Map(); // { position => expression tree (AST) }\n        this._valuesCache = new Map(); // { position => value; }\n        this._referencesMap = new ReferencesMap();\n    }\n\n    getText(position) {\n        return this.cells.has(position) ? this.cells.get(position).toString() : \"\";\n    }\n\n    setText(position, value) {\n        this.cells.set(position, value);\n\n        const affectedCells = [position, ...this._referencesMap.getAffectedCells(position)];\n        for (let pos of affectedCells)\n            this._valuesCache.delete(pos);\n\n        this._expressionsCache.delete(position);\n        if (this._referencesMap.getReferencesFrom(position))\n            this._referencesMap.removeReferencesFrom(position);\n\n        this.onCellsChanged(affectedCells);\n    }\n\n    getExpression(position) {\n        if (this._expressionsCache.has(position))\n            return this._expressionsCache.get(position);\n\n        const text = this.cells.has(position) ? this.cells.get(position) : null;\n        const { parsed, references } = this._parser.parse(text);\n        this._expressionsCache.set(position, parsed);\n\n        for (let reference of references)\n            this._referencesMap.addReference(position, reference);\n\n        return parsed;\n    }\n\n    getValue(position) {\n        if (this._valuesCache.has(position))\n            return this._valuesCache.get(position);\n\n        const result = this._evaluator.evaluateCellAt(position, this.getExpression(position), this);\n        this._valuesCache.set(position, result);\n        return result;\n    }\n\n    evaluateQuery(expression) {\n        const { parsed, _ } = this._parser.parse(expression);\n        return this._evaluator.evaluateQuery(parsed, this);\n    }\n\n    getFunction(name) {\n        if (!this.functions.has(name))\n            throw new RuntimeError(`Unknown function: ${name}`);\n        return this.functions.get(name);\n    }\n}","import { Environment } from './environment';\nimport * as Helpers from './helpers';\nexport { Helpers };\nexport { SpreadsheetError, RuntimeError, ParsingError } from './errors';\n\nexport class Spreadsheet {\n    constructor(cells = new Map(), functions = new Map(), onCellsChanged = (() => { })) {\n        // TODO: confirm this.cells are updated\n        // TODO: test cells\n        this.cells = cells instanceof Map ? cells : new Map(Object.entries(cells))\n        // TODO: test functions\n        this.functions = functions instanceof Map ? functions : new Map(Object.entries(functions))\n        this._environment = new Environment(this.cells, this.functions, onCellsChanged);\n    }\n\n    text(position) {\n        return this._environment.getText(position);\n    }\n\n    set(position, text) {\n        this._environment.setText(position, text);\n    }\n\n    value(position) {\n        return this._environment.getValue(position);\n    }\n\n    query(expression) {\n        return this._environment.evaluateQuery(expression);\n    }\n}"],"names":["SpreadsheetError","Error","ParsingError","[object Object]","message","super","this","RuntimeError","TokenStream","tokens","_tokens","_currentPos","types","token","peek","includes","type","expect","description","map","sym","join","TokenType","Object","freeze","EOF","Symbol","WHITESPACE","PLUS","MINUS","STAR","SLASH","LPAREN","RPAREN","COLON","EQUALS","COMMA","NUMBER","STRING","IDENTIFIER","Tokenizer","_rules","pattern","_operators"," ","\t","\r","\n","+","-","*","/","(",")","=",":",",","text","remaining","length","_nextToken","push","slice","value","filter","firstChar","operator","undefined","rule","match","Expression","Value","constructor","String","Reference","col","row","BinaryOp","left","op","right","UnaryOp","FunctionCall","functionName","args","Range","from","to","positionsInRange","positions","_range","columnIndex","columnLetter","Array","_","i","parsePosition","position","positionParts","parseInt","makePosition","colLetter","charCodeAt","colIndex","fromCharCode","Parser","tokenizer","_tokenizer","parsed","references","trimStart","startsWith","tokenize","require","_parseExpression","Set","_getReferences","parseFloat","_parseTerm","operation","_parseFactor","_parseRange","_parseUnary","_parseValue","_finishParenthesized","number","string","_parseString","identifier","_finishRangeReference","_finishFunctionCall","_parseReference","contents","escapedString","substring","replace","start","end","_parseArguments","reference","Helpers.parsePosition","expression","Helpers.makePosition","flatMap","arg","Helpers.positionsInRange","pos","CircularReferenceError","cell","Evaluator","visitedCellStack","environment","result","_evaluateCell","pop","ex","_evaluateReference","_evaluateUnary","_evaluateBinary","_evaluateFunction","getValue","e","_evaluateRange","leftValue","rightValue","func","getFunction","Function","isMacro","function","_evaluateMacro","_evaluateSpreadsheetFunction","argumentValues","_evaluateArguments","evaluatedArgs","_evaluateExpression","macroName","macro","argsLazyValues","ReferencesMap","_referencesFrom","Map","_referencesTo","get","positionFrom","referenceTo","has","set","targetNodes","target","valueIndex","indexOf","splice","delete","referencesTo","getReferencesTo","recursiveReferences","getAffectedCells","bind","Environment","cells","functions","cellsChangedListener","onCellsChanged","_parser","_evaluator","_expressionsCache","_valuesCache","_referencesMap","toString","affectedCells","getReferencesFrom","removeReferencesFrom","parse","addReference","evaluateCellAt","getExpression","evaluateQuery","name","Spreadsheet","entries","_environment","getText","setText"],"mappings":"0BAAO,MAAMA,yBAAyBC,OAE/B,MAAMC,qBAAqBF,iBAC9BG,YAAYC,GAAWC,MAAMD,GAC7BD,WAAa,uBAAwBG,KAAKF,WAGvC,MAAMG,qBAAqBP,iBAC9BG,YAAYC,GAAWC,MAAMD,GAC7BD,WAAa,2BAA4BG,KAAKF,WCPnC,MAAMI,YACjBL,YAAYM,GACRH,KAAKI,QAAUD,EACfH,KAAKK,YAAc,EAGvBR,OACI,OAAOG,KAAKI,QAAQJ,KAAKK,cAAgB,KAG7CR,UAAUS,GACN,MAAMC,EAAQP,KAAKQ,OACnB,OAAc,OAAVD,GAAkBD,EAAMG,SAASF,EAAMG,OACvCV,KAAKK,cACEE,GAEJ,KAGXV,WAAWS,GACP,MAAMC,EAAQP,KAAKW,UAAUL,GAC7B,GAAc,OAAVC,EACA,MAAM,IAAIX,2BAA2BI,KAAKQ,OAAOE,KAAKE,yBAAyBN,EAAMO,IAAIC,GAAOA,EAAIF,aAAaG,KAAK,WAC1H,OAAOR,GCtBR,MAAMS,EAAYC,OAAOC,OAAO,CAEnCC,IAAKC,OAAO,kBACZC,WAAYD,OAAO,cACnBE,KAAMF,OAAO,KACbG,MAAOH,OAAO,KACdI,KAAMJ,OAAO,KACbK,MAAOL,OAAO,KACdM,OAAQN,OAAO,uBACfO,OAAQP,OAAO,uBACfQ,MAAOR,OAAO,KACdS,OAAQT,OAAO,KACfU,MAAOV,OAAO,SACdW,OAAQX,OAAO,UACfY,OAAQZ,OAAO,UACfa,WAAYb,OAAO,gBAGhB,MAAMc,UACTrC,cACIG,KAAKmC,OAAS,CAIV,CAAEC,QAAS,iBAAkB1B,KAAMM,EAAUe,QAC7C,CAAEK,QAAS,eAAgB1B,KAAMM,EAAUiB,YAC3C,CAAEG,QAAS,qBAAsB1B,KAAMM,EAAUgB,QACjD,CAAEI,QAAS,KAAM1B,KAAMM,EAAUG,MAGrCnB,KAAKqC,WAAa,CACdC,IAAKtB,EAAUK,WACfkB,KAAMvB,EAAUK,WAChBmB,KAAMxB,EAAUK,WAChBoB,KAAMzB,EAAUK,WAChBqB,IAAK1B,EAAUM,KACfqB,IAAK3B,EAAUO,MACfqB,IAAK5B,EAAUQ,KACfqB,IAAK7B,EAAUS,MACfqB,IAAK9B,EAAUU,OACfqB,IAAK/B,EAAUW,OACfqB,IAAKhC,EAAUa,OACfoB,IAAKjC,EAAUY,MACfsB,IAAKlC,EAAUc,OAIvBjC,SAASsD,GACL,MAAMhD,EAAS,GACf,IAAIiD,EAAYD,EAChB,KAAOC,EAAUC,OAAS,GAAG,CACzB,MAAM9C,EAAQP,KAAKsD,WAAWF,GAC9BjD,EAAOoD,KAAKhD,GACZ6C,EAAYA,EAAUI,MAAMjD,EAAMkD,MAAMJ,QAG5C,OADAlD,EAAOoD,KAAK,CAAE7C,KAAMM,EAAUG,IAAKsC,MAAO,KACnC,IAAIvD,YAAYC,EAAOuD,OAAOnD,GAASA,EAAMG,OAASM,EAAUK,aAG3ExB,WAAWsD,GACP,MAAMQ,EAAYR,EAAK,GACjBS,EAAW5D,KAAKqC,WAAWsB,GACjC,QAAiBE,IAAbD,EAAwB,MAAO,CAAElD,KAAMkD,EAAUH,MAAOE,GAE5D,IAAK,IAAIG,KAAQ9D,KAAKmC,OAAQ,CAC1B,MAAM4B,EAAQZ,EAAKY,MAAMD,EAAK1B,SAC9B,GAAc,OAAV2B,EACA,MAAO,CAAErD,KAAMoD,EAAKpD,KAAM+C,MAAOM,EAAM,IAE/C,MAAM,IAAInE,kCAAkCuD,OCxE7C,MAAMa,YAEN,MAAMC,cAAcD,WACvBnE,YAAY4D,GAAS1D,QAASC,KAAKyD,MAAQA,EAC3C5D,WAAa,OAAOG,KAAKyD,MAAMS,cAAgBC,WAAanE,KAAKyD,YAAczD,KAAKyD,SAGjF,MAAMW,kBAAkBJ,WAG3BnE,YAAYwE,EAAKC,GAAOvE,QAASC,KAAKqE,IAAMA,EAAKrE,KAAKsE,IAAMA,EAC5DzE,WAAa,SAAUG,KAAKqE,MAAMrE,KAAKsE,OAGpC,MAAMC,iBAAiBP,WAC1BnE,YAAY2E,EAAMC,EAAIC,GAAS3E,QAASC,KAAKwE,KAAOA,EAAMxE,KAAKyE,GAAKA,EAAIzE,KAAK0E,MAAQA,EACrF7E,WAAa,UAAWG,KAAKwE,QAAQxE,KAAKyE,MAAMzE,KAAK0E,UAGlD,MAAMC,gBAAgBX,WACzBnE,YAAY4E,EAAIhB,GAAS1D,QAASC,KAAKyE,GAAKA,EAAIzE,KAAKyD,MAAQA,EAC7D5D,WAAa,SAAUG,KAAKyE,KAAKzE,KAAKyD,SAGnC,MAAMmB,qBAAqBZ,WAC9BnE,YAAYgF,EAAcC,GAAQ/E,QAASC,KAAK6E,aAAeA,EAAc7E,KAAK8E,KAAOA,EACzFjF,WAAa,SAAUG,KAAK6E,gBAAgB7E,KAAK8E,KAAK/D,KAAK,UAGxD,MAAMgE,cAAcf,WACvBnE,YAAYmF,EAAMC,GAAMlF,QAASC,KAAKgF,KAAOA,EAAMhF,KAAKiF,GAAKA,EAC7DpF,WAAa,SAAUG,KAAKgF,QAAQhF,KAAKiF,MC/BtC,SAASC,EAAiBF,EAAMC,GACnC,MAAME,EAAY,GAElB,IAAK,IAAId,KAAOe,EAAOC,EAAYL,EAAKX,KAAMgB,EAAYJ,EAAGZ,MACzD,IAAK,IAAIC,KAAOc,EAAOJ,EAAKV,IAAKW,EAAGX,KAChCa,EAAU5B,KAAK,CAAEc,IAAKiB,EAAajB,GAAMC,IAAKA,IACtD,OAAOa,EAGX,SAASC,EAAOJ,EAAMC,GAClB,OAAOD,GAAQC,EACTM,MAAMP,KAAK,CAAE3B,OAAQ4B,EAAKD,EAAO,GAAK,CAACQ,EAAGC,IAAMA,EAAIT,GACpDO,MAAMP,KAAK,CAAE3B,OAAQ2B,EAAOC,EAAK,GAAK,CAACO,EAAGC,IAAMT,EAAOS,GAG1D,SAASC,EAAcC,GAC1B,MAAMC,EAAgBD,EAAS5B,MAAM,sBACrC,OAAO6B,GACH,CAAEvB,IAAKuB,EAAc,GAAItB,IAAKuB,SAASD,EAAc,KAGtD,SAASE,EAAazB,EAAKC,GAC9B,SAAUD,IAAMC,IAGb,SAASe,EAAYU,GACxB,OAAOA,EAAUC,WAAW,GAAK,GAG9B,SAASV,EAAaW,GACzB,OAAO9B,OAAO+B,aAAaD,EAAW,gHCzBrBE,OACjBtG,YAAYuG,GACRpG,KAAKqG,WAAaD,EAClBpG,KAAKI,QAAU,KAInBP,MAAMsD,GAEF,GAAIA,MAAAA,GAAuCA,EAAKe,cAAgBC,OAC5D,MAAO,CAAEmC,OAAQ,IAAIrC,MAAMd,GAAOoD,WAAY,IAGlD,GAAIpD,EAAKqD,YAAYC,WAAW,KAAM,CAClCzG,KAAKI,QAAUJ,KAAKqG,WAAWK,SAASvD,GACxCnD,KAAKI,QAAQuG,QAAQ3F,EAAUa,QAC/B,MAAMyE,EAAStG,KAAK4G,mBAIpB,OAHA5G,KAAKI,QAAQuG,QAAQ3F,EAAUG,KAGxB,CAAEmF,OAAAA,EAAQC,WADE,IAAI,IAAIM,IAAI7G,KAAK8G,eAAeR,MAKvD,OAAInD,EAAKY,MAAM,wBACJ,CAAEuC,OAAQ,IAAIrC,MAAM8C,WAAW5D,IAAQoD,WAAY,IAGvD,CAAED,OAAQ,IAAIrC,MAAMd,GAAOoD,WAAY,IAIlD1G,mBACI,OAAOG,KAAKgH,aAIhBnH,aACI,IACIoH,EADAzC,EAAOxE,KAAKkH,eAEhB,KAA8E,QAAtED,EAAYjH,KAAKI,QAAQO,OAAOK,EAAUM,KAAMN,EAAUO,SAC9DiD,EAAO,IAAID,SAASC,EAAMyC,EAAUxD,MAAOzD,KAAKkH,gBAEpD,OAAO1C,EAIX3E,eACI,IACIoH,EADAzC,EAAOxE,KAAKmH,cAEhB,KAA8E,QAAtEF,EAAYjH,KAAKI,QAAQO,OAAOK,EAAUQ,KAAMR,EAAUS,SAC9D+C,EAAO,IAAID,SAASC,EAAMyC,EAAUxD,MAAOzD,KAAKmH,eAEpD,OAAO3C,EAIX3E,cAEI,OAAOG,KAAKoH,cAIhBvH,cACI,MAAMoH,EAAYjH,KAAKI,QAAQO,OAAOK,EAAUM,KAAMN,EAAUO,OAChE,OAAqB,OAAd0F,EACD,IAAItC,QAAQsC,EAAUxD,MAAOzD,KAAKoH,eAClCpH,KAAKqH,cAIfxH,cACI,GAAIG,KAAKI,QAAQO,OAAOK,EAAUU,QAC9B,OAAO1B,KAAKsH,uBAEhB,MAAMC,EAASvH,KAAKI,QAAQO,OAAOK,EAAUe,QAC7C,GAAe,OAAXwF,EACA,OAAO,IAAItD,MAAM8C,WAAWQ,EAAO9D,QAEvC,MAAM+D,EAASxH,KAAKI,QAAQO,OAAOK,EAAUgB,QAC7C,GAAe,OAAXwF,EACA,OAAOxH,KAAKyH,aAAaD,GAG7B,MAAME,EAAa1H,KAAKI,QAAQO,OAAOK,EAAUiB,YACjD,GAAmB,OAAfyF,EACA,OAAI1H,KAAKI,QAAQO,OAAOK,EAAUY,OACvB5B,KAAK2H,sBAAsBD,GAElC1H,KAAKI,QAAQO,OAAOK,EAAUU,QACvB1B,KAAK4H,oBAAoBF,GAE7B1H,KAAK6H,gBAAgBH,EAAWjE,OAE3C,MAAM,IAAI7D,2BAA2BI,KAAKI,QAAQI,OAAOE,KAAKE,gDAIlEf,uBACI,MAAMiI,EAAW9H,KAAK4G,mBAEtB,OADA5G,KAAKI,QAAQuG,QAAQ3F,EAAUW,QACxBmG,EAGXjI,aAAa2H,GACT,MACMO,EADgBP,EAAO/D,MAAMuE,UAAU,EAAGR,EAAO/D,MAAMJ,OAAS,GAClC4E,QAAQ,SAAU,MACtD,OAAO,IAAIhE,MAAM8D,GAIrBlI,sBAAsBqI,GAElB,MAAMC,EAAMnI,KAAKI,QAAQuG,QAAQ3F,EAAUiB,YACrC+C,EAAOhF,KAAK6H,gBAAgBK,EAAMzE,OAClCwB,EAAKjF,KAAK6H,gBAAgBM,EAAI1E,OACpC,OAAO,IAAIsB,MAAMC,EAAMC,GAI3BpF,oBAAoB6H,GAIhB,MAAM5C,EAAO9E,KAAKoI,kBAElB,OADApI,KAAKI,QAAQO,OAAOK,EAAUW,QACvB,IAAIiD,aAAa8C,EAAWjE,MAAOqB,GAI9CjF,gBAAgBwI,GACZ,MAAM1C,EAAW2C,EAAsBD,GACvC,GAAiB,OAAb1C,EACA,MAAM,IAAI/F,kDAAkDyI,KAChE,OAAO,IAAIjE,UAAUuB,EAAStB,IAAKsB,EAASrB,KAIhDzE,kBACI,MAAMiF,EAAO,GACb,KAAO9E,KAAKI,QAAQI,OAAOE,OAASM,EAAUW,QACvB,GAAfmD,EAAKzB,QACLrD,KAAKI,QAAQuG,QAAQ3F,EAAUc,OACnCgD,EAAKvB,KAAKvD,KAAK4G,oBAEnB,OAAO9B,EAGXjF,eAAe0I,GACX,OAAQA,EAAWrE,aACf,KAAKD,MACD,MAAO,GACX,KAAKG,UACD,MAAO,CAACoE,EAAqBD,EAAWlE,IAAKkE,EAAWjE,MAC5D,KAAKK,QACD,OAAO3E,KAAK8G,eAAeyB,EAAW9E,OAC1C,KAAKc,SACD,MAAO,IAAIvE,KAAK8G,eAAeyB,EAAW/D,SAAUxE,KAAK8G,eAAeyB,EAAW7D,QACvF,KAAKE,aACD,OAAO2D,EAAWzD,KAAK2D,QAAQC,GAAO1I,KAAK8G,eAAe4B,IAC9D,KAAK3D,MACD,OAAO4D,EAAyBJ,EAAWvD,KAAMuD,EAAWtD,IACvDpE,IAAI+H,GAAOJ,EAAqBI,EAAIvE,IAAKuE,EAAItE,MACtD,QACI,MAAM,IAAI1E,gDAAgD2I,OCrK1E,MAAMM,+BAA+BlJ,MACjCE,YAAYC,EAASgJ,GAAQ/I,MAAMD,GAAUE,KAAK8I,KAAOA,GAG9C,MAAMC,UACjBlJ,cACIG,KAAKgJ,iBAAmB,GAG5BnJ,eAAe8F,EAAUmD,EAAMG,GAC3B,GAAIjJ,KAAKgJ,iBAAiBvI,SAASkF,GAC/B,MAAM,IAAIkD,uDAAuD7I,KAAKgJ,iBAAiBjI,KAAK,cAAc4E,KAAamD,GAE3H9I,KAAKgJ,iBAAiBzF,KAAKoC,GAC3B,IACI,MAAMuD,EAASlJ,KAAKmJ,cAAcL,EAAMG,GAExC,OADAjJ,KAAKgJ,iBAAiBI,MACfF,EACT,MAAOG,GAOL,MANArJ,KAAKgJ,iBAAiBI,MAMlBC,aAAcR,wBAA0BQ,EAAGP,OAASA,EAC9C,IAAI7I,aAAaoJ,EAAGvJ,SAEpBuJ,GAKlBxJ,cAAciJ,EAAMG,GAChB,OAAOjJ,KAAKmJ,cAAcL,EAAMG,GAGpCpJ,cAAciJ,EAAMG,GAChB,OAAQH,EAAK5E,aACT,KAAKD,MACD,OAAO6E,EAAKrF,MAChB,KAAKW,UACD,OAAOpE,KAAKsJ,mBAAmBd,EAAqBM,EAAKzE,IAAKyE,EAAKxE,KAAM2E,GAC7E,KAAKtE,QACD,OAAO3E,KAAKuJ,eAAeT,EAAKrE,GAAIqE,EAAKrF,MAAOwF,GACpD,KAAK1E,SACD,OAAOvE,KAAKwJ,gBAAgBV,EAAKtE,KAAMsE,EAAKrE,GAAIqE,EAAKpE,MAAOuE,GAChE,KAAKrE,aACD,OAAO5E,KAAKyJ,kBAAkBX,EAAKjE,aAAciE,EAAKhE,KAAMmE,GAChE,KAAKlE,MACD,MAAM,IAAI9E,aAAa,+DAC3B,QACI,MAAM,IAAIA,gDAAgD6I,MAItEjJ,mBAAmB8F,EAAUsD,GACzB,IACI,OAAOA,EAAYS,SAAS/D,GAC9B,MAAOgE,GACL,MAAIA,aAAa/J,cAAgB+J,aAAa1J,aACpC,IAAIA,yCAAyC0F,KAC5CgE,GAInB9J,oBAAoB4D,EAAOwF,GACvB,OAAQxF,EAAMS,aACV,KAAKa,MAAO,OAAO/E,KAAK4J,eAAenG,EAAMuB,KAAMvB,EAAMwB,GAAIgE,GAC7D,QAAS,OAAOjJ,KAAKmJ,cAAc1F,EAAOwF,IAIlDpJ,eAAe4E,EAAI8D,EAAYU,GAC3B,MAAMxF,EAAQzD,KAAKmJ,cAAcZ,EAAYU,GAC7C,OAAQxE,GACJ,IAAK,IAAK,OAAOhB,EACjB,IAAK,IAAK,OAAQA,EAClB,QAAS,MAAM,IAAIxD,yCAAyCwE,OAIpE5E,gBAAgB2E,EAAMC,EAAIC,EAAOuE,GAC7B,MAAMY,EAAY7J,KAAKmJ,cAAc3E,EAAMyE,GACrCa,EAAa9J,KAAKmJ,cAAczE,EAAOuE,GAC7C,OAAQxE,GACJ,IAAK,IAAK,OAAOoF,EAAYC,EAC7B,IAAK,IAAK,OAAOD,EAAYC,EAC7B,IAAK,IAAK,OAAOD,EAAYC,EAC7B,IAAK,IAAK,OAAOD,EAAYC,EAC7B,QAAS,MAAM,IAAI7J,0CAA0CwE,OAIrE5E,kBAAkBgF,EAAcC,EAAMmE,GAClC,IAAIc,EAAOd,EAAYe,YAAYnF,GAEnC,OAAyB,KADzBkF,EAAOA,aAAgBE,SAAW,CAAEC,SAAS,EAAOC,SAAUJ,GAASA,GAC1DG,QACTlK,KAAKoK,eAAevF,EAAckF,EAAMjF,EAAMmE,GAC9CjJ,KAAKqK,6BAA6BxF,EAAckF,EAAMjF,EAAMmE,GAGpEpJ,6BAA6BgF,EAAckF,EAAMjF,EAAMmE,GACnD,MAAMqB,EAAiBtK,KAAKuK,mBAAmB1F,EAAcC,EAAMmE,GACnE,IACI,OAAOc,EAAKI,YAAYG,GAC1B,MAAOjB,GACL,MAAM,IAAIpJ,kCAAkC4E,MAAiBwE,MAIrExJ,mBAAmBgF,EAAcC,EAAMmE,GACnC,IAAIuB,EAAgB,GACpB,IAAK,IAAI/E,EAAI,EAAGA,EAAIX,EAAKzB,OAAQoC,IAC7B,IACI+E,EAAcjH,KAAKvD,KAAKyK,oBAAoB3F,EAAKW,GAAIwD,IACvD,MAAOI,GACL,MAAM,IAAIpJ,2CAA2CwF,EAAI,iBAAiBZ,MAAiBwE,KAGnG,OAAOmB,EAGX3K,eAAe6K,EAAWC,EAAO7F,EAAMmE,GACnC,MAAM2B,EAAiB9F,EAAKjE,IAAI6H,GAAO,IAAM1I,KAAKyK,oBAAoB/B,EAAKO,IAC3E,IACI,OAAO0B,EAAMR,YAAYS,GAC3B,MAAOvB,GACL,MAAM,IAAIpJ,+BAA+ByK,MAAcrB,MAI/DxJ,eAAemF,EAAMC,EAAIgE,GACrB,OAAON,EAAyB3D,EAAMC,GACjCpE,IAAI+H,GAAOJ,EAAqBI,EAAIvE,IAAKuE,EAAItE,MAC7CzD,IAAI+H,GAAO5I,KAAKsJ,mBAAmBV,EAAKK,KC3ItC,MAAM4B,cACjBhL,cACIG,KAAK8K,gBAAkB,IAAIC,IAC3B/K,KAAKgL,cAAgB,IAAID,IAG7BlL,kBAAkB8F,GAAY,OAAO3F,KAAK8K,gBAAgBG,IAAItF,GAC9D9F,gBAAgB8F,GAAY,OAAO3F,KAAKgL,cAAcC,IAAItF,GAE1D9F,aAAaqL,EAAcC,GAClBnL,KAAK8K,gBAAgBM,IAAIF,IAC1BlL,KAAK8K,gBAAgBO,IAAIH,EAAc,IAC3ClL,KAAK8K,gBAAgBG,IAAIC,GAAc3H,KAAK4H,GAEvCnL,KAAKgL,cAAcI,IAAID,IACxBnL,KAAKgL,cAAcK,IAAIF,EAAa,IACxCnL,KAAKgL,cAAcC,IAAIE,GAAa5H,KAAK2H,GAG7CrL,qBAAqB8F,GACjB,MAAM2F,EAActL,KAAK8K,gBAAgBG,IAAItF,GAC7C,IAAK,IAAI4F,KAAUD,EAAa,CAC5B,MAAME,EAAaxL,KAAKgL,cAAcC,IAAIM,GAAQE,QAAQ9F,GACtD6F,GAAc,GAAGxL,KAAKgL,cAAcC,IAAIM,GAAQG,OAAOF,EAAY,GAE3ExL,KAAK8K,gBAAgBa,OAAOhG,GAGhC9F,iBAAiB8F,GAEb,MAAMiG,EAAe5L,KAAK6L,gBAAgBlG,GAC1C,IAAKiG,EAAc,MAAO,GAE1B,MAAME,EAAsBF,EAAanD,QAAQzI,KAAK+L,iBAAiBC,KAAKhM,OAC5E,MAAO,IAAI4L,KAAiBE,IC5B7B,MAAMG,YACTpM,YAAYqM,EAAOC,EAAWC,GAC1BpM,KAAKkM,MAAQA,EACblM,KAAKmM,UAAYA,EACjBnM,KAAKqM,eAAiBD,EACtBpM,KAAKsM,QAAU,IAAInG,OAAO,IAAIjE,WAC9BlC,KAAKuM,WAAa,IAAIxD,UAEtB/I,KAAKwM,kBAAoB,IAAIzB,IAC7B/K,KAAKyM,aAAe,IAAI1B,IACxB/K,KAAK0M,eAAiB,IAAI7B,cAG9BhL,QAAQ8F,GACJ,OAAO3F,KAAKkM,MAAMd,IAAIzF,GAAY3F,KAAKkM,MAAMjB,IAAItF,GAAUgH,WAAa,GAG5E9M,QAAQ8F,EAAUlC,GACdzD,KAAKkM,MAAMb,IAAI1F,EAAUlC,GAEzB,MAAMmJ,EAAgB,CAACjH,KAAa3F,KAAK0M,eAAeX,iBAAiBpG,IACzE,IAAK,IAAIiD,KAAOgE,EACZ5M,KAAKyM,aAAad,OAAO/C,GAE7B5I,KAAKwM,kBAAkBb,OAAOhG,GAC1B3F,KAAK0M,eAAeG,kBAAkBlH,IACtC3F,KAAK0M,eAAeI,qBAAqBnH,GAE7C3F,KAAKqM,eAAeO,GAGxB/M,cAAc8F,GACV,GAAI3F,KAAKwM,kBAAkBpB,IAAIzF,GAC3B,OAAO3F,KAAKwM,kBAAkBvB,IAAItF,GAEtC,MAAMxC,EAAOnD,KAAKkM,MAAMd,IAAIzF,GAAY3F,KAAKkM,MAAMjB,IAAItF,GAAY,MAC7DW,OAAEA,EAAMC,WAAEA,GAAevG,KAAKsM,QAAQS,MAAM5J,GAClDnD,KAAKwM,kBAAkBnB,IAAI1F,EAAUW,GAErC,IAAK,IAAI+B,KAAa9B,EAClBvG,KAAK0M,eAAeM,aAAarH,EAAU0C,GAE/C,OAAO/B,EAGXzG,SAAS8F,GACL,GAAI3F,KAAKyM,aAAarB,IAAIzF,GACtB,OAAO3F,KAAKyM,aAAaxB,IAAItF,GAEjC,MAAMuD,EAASlJ,KAAKuM,WAAWU,eAAetH,EAAU3F,KAAKkN,cAAcvH,GAAW3F,MAEtF,OADAA,KAAKyM,aAAapB,IAAI1F,EAAUuD,GACzBA,EAGXrJ,cAAc0I,GACV,MAAMjC,OAAEA,EAAMd,EAAEA,GAAMxF,KAAKsM,QAAQS,MAAMxE,GACzC,OAAOvI,KAAKuM,WAAWY,cAAc7G,EAAQtG,MAGjDH,YAAYuN,GACR,IAAKpN,KAAKmM,UAAUf,IAAIgC,GACpB,MAAM,IAAInN,kCAAkCmN,KAChD,OAAOpN,KAAKmM,UAAUlB,IAAImC,4FC/DrBC,YACTxN,YAAYqM,EAAQ,IAAInB,IAAOoB,EAAY,IAAIpB,IAAOsB,YAGlDrM,KAAKkM,MAAQA,aAAiBnB,IAAMmB,EAAQ,IAAInB,IAAI9J,OAAOqM,QAAQpB,IAEnElM,KAAKmM,UAAYA,aAAqBpB,IAAMoB,EAAY,IAAIpB,IAAI9J,OAAOqM,QAAQnB,IAC/EnM,KAAKuN,aAAe,IAAItB,YAAYjM,KAAKkM,MAAOlM,KAAKmM,UAAWE,GAGpExM,KAAK8F,GACD,OAAO3F,KAAKuN,aAAaC,QAAQ7H,GAGrC9F,IAAI8F,EAAUxC,GACVnD,KAAKuN,aAAaE,QAAQ9H,EAAUxC,GAGxCtD,MAAM8F,GACF,OAAO3F,KAAKuN,aAAa7D,SAAS/D,GAGtC9F,MAAM0I,GACF,OAAOvI,KAAKuN,aAAaJ,cAAc5E"}