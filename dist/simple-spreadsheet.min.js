!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e=e||self).SimpleSpreadsheet={})}(this,function(e){"use strict";class SpreadsheetError extends Error{}class ParsingError extends SpreadsheetError{constructor(e){super(e)}toString(){return`Syntax error: ${this.message}`}}class RuntimeError extends SpreadsheetError{constructor(e){super(e)}toString(){return`Evaluation error: ${this.message}`}}class TokenStream{constructor(e){this._tokens=e,this._currentPos=0}peek(){return this._tokens[this._currentPos]||null}expect(...e){const t=this.peek();return null!==t&&e.includes(t.type)?(this._currentPos++,t):null}require(...e){const t=this.expect(...e);if(null===t)throw new ParsingError(`Expected ${e.join(" or ")}, got ${this.peek().type} instead.`);return t}}const t=Object.freeze({EOF:"EOF",WHITESPACE:"WHITESPACE",PLUS:"PLUS",MINUS:"MINUS",STAR:"STAR",SLASH:"SLASH",LPAREN:"LPAREN",RPAREN:"RPAREN",COLON:"COLON",EQUALS:"EQUALS",COMMA:"COMMA",NUMBER:"NUMBER",STRING:"STRING",REFERENCE:"REFERENCE",IDENTIFIER:"IDENTIFIER"});class Tokenizer{constructor(){this._rules=[{pattern:/^\d+(?:\.\d+)?/,type:t.NUMBER},{pattern:/^[A-Za-z]+\d+/,type:t.REFERENCE},{pattern:/^[a-zA-Z]\w+/,type:t.IDENTIFIER},{pattern:/^\s+/,type:t.WHITESPACE},{pattern:/^\+/,type:t.PLUS},{pattern:/^\-/,type:t.MINUS},{pattern:/^\*/,type:t.STAR},{pattern:/^\//,type:t.SLASH},{pattern:/^\(/,type:t.LPAREN},{pattern:/^\)/,type:t.RPAREN},{pattern:/^=/,type:t.EQUALS},{pattern:/^:/,type:t.COLON},{pattern:/^,/,type:t.COMMA},{pattern:/^\"(?:[^"\\]|\\.)*\"/,type:t.STRING},{pattern:/^$/,type:t.EOF}]}tokenize(e){const r=[];let n=e;for(;n.length>0;){const e=this._nextToken(n);r.push(e),n=n.slice(e.value.length)}return r.push({type:t.EOF,value:""}),new TokenStream(r.filter(e=>e.type!==t.WHITESPACE))}_nextToken(e){for(let t of this._rules){const r=e.match(t.pattern);if(null!==r)return{type:t.type,value:r[0]}}throw new ParsingError(`Unknown token at '${e}'`)}}class Expression{}class Value extends Expression{constructor(e){super(),this.value=e}toString(){return this.value.constructor===String?`"${this.value}"`:`${this.value}`}}class CellReference extends Expression{constructor(e){super(),this.position=e}toString(){return`CellReference(${this.position})`}}class Reference extends Expression{constructor(e){super(),this.name=e}toString(){return`Reference(${this.name})`}}class BinaryOp extends Expression{constructor(e,t,r){super(),this.left=e,this.op=t,this.right=r}toString(){return`BinaryOp(${this.left} ${this.op} ${this.right})`}}class UnaryOp extends Expression{constructor(e,t){super(),this.op=e,this.value=t}toString(){return`UnaryOp(${this.op} ${this.value})`}}class FunctionCall extends Expression{constructor(e,t){super(),this.functionValue=e,this.args=t}toString(){return`FunctionCall(${this.functionValue}, [${this.args.join(", ")}])`}}class Range extends Expression{constructor(e,t){super(),this.from=e,this.to=t}toString(){return`Range(${this.from}, ${this.to})`}}function r(e,t){const r=[],o=s(e),l=s(t);for(let e of n(i(o.col),i(l.col)))for(let t of n(o.row,l.row))r.push({col:a(e),row:t});return r}function n(e,t){return e<=t?Array.from({length:t-e+1},(t,r)=>r+e):Array.from({length:e-t+1},(t,r)=>e-r)}function s(e){const t=e.match(/^([A-Za-z]+)(\d+)$/);return t&&{col:t[1],row:parseInt(t[2])}}function o(e,t){return`${e}${t}`}function i(e){return e.charCodeAt(0)-65}function a(e){return String.fromCharCode(e+65)}var l=Object.freeze({positionsInRange:r,parsePosition:s,makePosition:o,columnIndex:i,columnLetter:a});class Parser{constructor(e){this._tokenizer=e,this._tokens=null}parse(e){if(null==e||e.constructor!==String)return{parsed:new Value(e),references:[]};if(e.trimStart().startsWith("=")){this._tokens=this._tokenizer.tokenize(e),this._tokens.require(t.EQUALS);const r=this._parseExpression();return this._tokens.require(t.EOF),{parsed:r,references:[...new Set(this._getCellReferences(r))]}}return e.match(/^[+-]?\d+(?:\.\d+)?$/)?{parsed:new Value(parseFloat(e)),references:[]}:{parsed:new Value(e),references:[]}}_parseExpression(){return this._parseTerm()}_parseTerm(){let e,r=this._parseFactor();for(;null!==(e=this._tokens.expect(t.PLUS,t.MINUS));)r=new BinaryOp(r,e.value,this._parseFactor());return r}_parseFactor(){let e,r=this._parseRange();for(;null!==(e=this._tokens.expect(t.STAR,t.SLASH));)r=new BinaryOp(r,e.value,this._parseRange());return r}_parseRange(){return this._parseUnary()}_parseUnary(){const e=this._tokens.expect(t.PLUS,t.MINUS);return null!==e?new UnaryOp(e.value,this._parseUnary()):this._parseCall()}_parseCall(){let e=this._parseValue();for(;this._tokens.expect(t.LPAREN);){const r=this._parseArguments();this._tokens.expect(t.RPAREN),e=new FunctionCall(e,r)}return e}_parseValue(){const e=this._tokens.expect(t.NUMBER);if(null!==e)return this._parseNumber(e);const r=this._tokens.expect(t.STRING);if(null!==r)return this._parseString(r);const n=this._tokens.expect(t.REFERENCE);if(null!=n&&this._tokens.expect(t.COLON))return this._finishRangeReference(n);if(null!=n)return this._parseCellReference(n);const s=this._tokens.expect(t.IDENTIFIER);if(null!==s)return new Reference(s.value);if(this._tokens.expect(t.LPAREN))return this._finishParenthesized();throw new ParsingError(`Unexpected ${this._tokens.peek().type}, expected an expression or value`)}_finishParenthesized(){const e=this._parseExpression();return this._tokens.require(t.RPAREN),e}_parseNumber(e){return new Value(parseFloat(e.value))}_parseString(e){const t=e.value.substring(1,e.value.length-1).replace(/\\(.)/g,"$1");return new Value(t)}_finishRangeReference(e){const r=this._tokens.require(t.REFERENCE),n=new CellReference(e.value),s=new CellReference(r.value);return new Range(n,s)}_parseCellReference(e){const t=s(e.value),r=o(t.col,t.row);return new CellReference(r)}_parseArguments(){const e=[];for(;this._tokens.peek().type!==t.RPAREN;)0!=e.length&&this._tokens.require(t.COMMA),e.push(this._parseExpression());return e}_getCellReferences(e){switch(e.constructor){case Value:return[];case CellReference:return[e.position];case Reference:return[];case UnaryOp:return this._getCellReferences(e.value);case BinaryOp:return[...this._getCellReferences(e.left),...this._getCellReferences(e.right)];case FunctionCall:return e.args.flatMap(e=>this._getCellReferences(e));case Range:return r(e.from.position,e.to.position).map(e=>o(e.col,e.row));default:throw new ParsingError(`Unknown expression type: ${typeof e}`)}}}class Evaluator{constructor(){this.visitedCellStack=[]}evaluateCellAt(e,t,r){if(this.visitedCellStack.includes(e))throw new RuntimeError(`Circular reference detected (${this.visitedCellStack.join(" -> ")} -> ${e})`);this.visitedCellStack.push(e);const n=this._evaluateCell(t,r);return this.visitedCellStack.pop(),n}evaluateQuery(e,t){return this._evaluateCell(e,t)}_evaluateCell(e,t){switch(e.constructor){case Value:return e.value;case CellReference:return this._evaluateCellReference(e.position,t);case Reference:return t.getGlobal(e.name,t);case UnaryOp:return this._evaluateUnary(e.op,e.value,t);case BinaryOp:return this._evaluateBinary(e.left,e.op,e.right,t);case FunctionCall:return this._evaluateFunction(e.functionValue,e.args,t);case Range:throw new RuntimeError("Range references are allowed only as arguments of functions");default:throw new RuntimeError(`Unknown expression type: ${typeof e}`)}}_evaluateCellReference(e,t){try{return t.getValue(e)}catch(t){throw t instanceof ParsingError?new RuntimeError(`Error in referenced cell: ${e}`):t}}_evaluateExpression(e,t){switch(e.constructor){case Range:return this._evaluateRange(e.from,e.to,t);default:return this._evaluateCell(e,t)}}_evaluateUnary(e,t,r){const n=this._evaluateCell(t,r);switch(e){case"+":return n;case"-":return-n;default:throw new RuntimeError(`Unknown unary operator: '${e}'`)}}_evaluateBinary(e,t,r,n){const s=this._evaluateCell(e,n),o=this._evaluateCell(r,n);switch(t){case"+":return s+o;case"-":return s-o;case"*":return s*o;case"/":return s/o;default:throw new RuntimeError(`Unknown binary operator: '${t}'`)}}_evaluateFunction(e,t,r){const n=this._evaluateCell(e,r);if("function"!=typeof n)throw new RuntimeError(`'${e}' is called like a function, but is not a function.`);const s=t.map(e=>this._evaluateExpression(e,r));try{return n(...s)}catch(t){throw new RuntimeError(`Error in function ${e}: ${t}`)}}_evaluateRange(e,t,n){return r(e.position,t.position).map(e=>o(e.col,e.row)).map(e=>this._evaluateCellReference(e,n))}}class ReferencesMap{constructor(){this._referencesFrom={},this._referencesTo={}}getReferencesFrom(e){return this._referencesFrom[e]}getReferencesTo(e){return this._referencesTo[e]}addReference(e,t){this._referencesFrom[e]||(this._referencesFrom[e]=[]),this._referencesFrom[e].push(t),this._referencesTo[t]||(this._referencesTo[t]=[]),this._referencesTo[t].push(e)}removeReferencesFrom(e){const t=this._referencesFrom[e];for(let r of t){const t=this._referencesTo[r].indexOf(e);t>-1&&this._referencesTo[r].splice(t,1)}delete this._referencesFrom[e]}getAffectedCells(e){const t=this.getReferencesTo(e);if(!t)return[];const r=t.flatMap(this.getAffectedCells.bind(this));return[...t,...r]}}class Environment{constructor(e={},t={},r=(()=>{})){this.cells=e,this.globals=t,this.cellsChangedListener=r,this._parser=new Parser(new Tokenizer),this._evaluator=new Evaluator,this._expressionsCache={},this._valuesCache={},this._referencesMap=new ReferencesMap}getText(e){return this.cells.hasOwnProperty(e)?this.cells[e].toString():""}setText(e,t){this.cells[e]=t;const r=[e,...this._referencesMap.getAffectedCells(e)];for(let e of r)delete this._valuesCache[e];delete this._expressionsCache[e],this._referencesMap.getReferencesFrom(e)&&this._referencesMap.removeReferencesFrom(e),this.cellsChangedListener(r)}getExpression(e){if(this._expressionsCache.hasOwnProperty(e))return this._expressionsCache[e];const t=this.cells.hasOwnProperty(e)?this.cells[e]:null,{parsed:r,references:n}=this._parser.parse(t);this._expressionsCache[e]=r;for(let t of n)this._referencesMap.addReference(e,t);return r}getValue(e){if(this._valuesCache.hasOwnProperty(e))return this._valuesCache[e];const t=this._evaluator.evaluateCellAt(e,this.getExpression(e),this);return this._valuesCache[e]=t,t}evaluateQuery(e){const{parsed:t,_:r}=this._parser.parse(e);return this._evaluator.evaluateQuery(t,this)}getGlobal(e){if(void 0===this.globals[e])throw new RuntimeError(`Unknown global value: ${e}`);return this.globals[e]}}const u={SUM:(...e)=>{let t=0;for(let r of e.flat())if("number"==typeof r)t+=r;else if(null!=r)throw new Error(`${typeof r} is not a valid argument to SUM(). Expected number, number[], null or undefined.`);return t},AVERAGE:(...e)=>{let t=0,r=0;for(let n of e.flat())if("number"==typeof n)t+=n,r++;else if(null!=n)throw new Error(`${typeof n} is not a valid argument to AVERAGE().`);return t/r}};e.Helpers=l,e.ParsingError=ParsingError,e.RuntimeError=RuntimeError,e.Spreadsheet=class Spreadsheet{constructor(e={},t=u,r){this.cells=e,this._environment=new Environment(this.cells,t,r)}text(e){return this._environment.getText(e)}set(e,t){this._environment.setText(e,t)}value(e){return this._environment.getValue(e)}query(e){return this._environment.evaluateQuery(e)}},e.SpreadsheetError=SpreadsheetError,e.builtinValues=u,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=simple-spreadsheet.min.js.map
