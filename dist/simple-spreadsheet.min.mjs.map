{"version":3,"file":"simple-spreadsheet.min.mjs","sources":["../src/errors.js","../src/tokenStream.js","../src/tokenizer.js","../src/expressions.js","../src/helpers.js","../src/parser.js","../src/evaluator.js","../src/referencesMap.js","../src/environment.js","../src/functions.js","../src/spreadsheet.js"],"sourcesContent":["export class SpreadsheetError extends Error { }\n\nexport class ParsingError extends SpreadsheetError {\n    constructor(message) { super(message); }\n    toString() { return `Syntax error: ${this.message}`; }\n}\n\nexport class RuntimeError extends SpreadsheetError {\n    constructor(message) { super(message); }\n    toString() { return `Evaluation error: ${this.message}`; }\n}\n","import { ParsingError } from \"./errors\";\n\nexport default class TokenStream {\n    constructor(tokens) {\n        this._tokens = tokens;\n        this._currentPos = 0;\n    }\n\n    peek() {\n        return this._tokens[this._currentPos] || null;\n    }\n\n    expect(...types) {\n        const token = this.peek();\n        if (token !== null && types.includes(token.type)) {\n            this._currentPos++;\n            return token;\n        }\n        return null;\n    }\n\n    require(...types) {\n        const token = this.expect(...types);\n        if (token === null)\n            throw new ParsingError(`Unexpected ${this.peek().type}, expected ${types.join(' or ')}.`);\n        return token;\n    }\n}","import { ParsingError } from './errors';\nimport TokenStream from './tokenStream';\n\nexport const TokenType = Object.freeze({\n    // Note: strings must be unique, because they are used for comparison\n    EOF: 'end of formula',\n    WHITESPACE: 'whitespace',\n    PLUS: '+',\n    MINUS: '-',\n    STAR: '*',\n    SLASH: '/',\n    LPAREN: 'opening parenthesis',\n    RPAREN: 'closing parenthesis',\n    COLON: ':',\n    EQUALS: '=',\n    COMMA: 'comma',\n    NUMBER: 'number',\n    STRING: 'string',\n    IDENTIFIER: 'identifier',\n});\n\nexport class Tokenizer {\n    constructor() {\n        this._rules = [\n            // NUMBER and IDENTIFIER are used the most so keep them at the top (for performance reasons - it makes a difference, I measured it)\n            // Patterns usually start with ^ so they match the start of the remaining\n            // string, not anywhere in the middle.\n            { pattern: /^\\d+(?:\\.\\d+)?/, type: TokenType.NUMBER },\n            // { pattern: /^[A-Za-z]+\\d+/, type: TokenType.REFERENCE },\n            { pattern: /^[a-zA-Z]\\w+/, type: TokenType.IDENTIFIER },\n            { pattern: /^\\s+/, type: TokenType.WHITESPACE },\n            { pattern: /^\\+/, type: TokenType.PLUS },\n            { pattern: /^\\-/, type: TokenType.MINUS },\n            { pattern: /^\\*/, type: TokenType.STAR },\n            { pattern: /^\\//, type: TokenType.SLASH },\n            { pattern: /^\\(/, type: TokenType.LPAREN },\n            { pattern: /^\\)/, type: TokenType.RPAREN },\n            { pattern: /^=/, type: TokenType.EQUALS },\n            { pattern: /^:/, type: TokenType.COLON },\n            { pattern: /^,/, type: TokenType.COMMA },\n            { pattern: /^\\\"(?:[^\"\\\\]|\\\\.)*\\\"/, type: TokenType.STRING },\n            { pattern: /^$/, type: TokenType.EOF },\n        ];\n    }\n\n    tokenize(text) {\n        const tokens = [];\n        let remaining = text;\n        while (remaining.length > 0) {\n            const token = this._nextToken(remaining);\n            tokens.push(token);\n            remaining = remaining.slice(token.value.length);\n        }\n        tokens.push({ type: TokenType.EOF, value: '' });\n        return new TokenStream(tokens.filter(token => token.type !== TokenType.WHITESPACE));\n    }\n\n    _nextToken(text) {\n        for (let rule of this._rules) {\n            const match = text.match(rule.pattern);\n            if (match !== null)\n                return { type: rule.type, value: match[0] };\n        }\n        throw new ParsingError(`Unknown token at '${text}'`);\n    }\n}\n","export class Expression { }\n\nexport class Value extends Expression {\n    constructor(value) { super(); this.value = value; }\n    toString() { return this.value.constructor === String ? `\"${this.value}\"` : `${this.value}`; }\n}\n\nexport class Reference extends Expression {\n    // TODO: Maybe refactor to only hold single property?\n    // Normalize position?\n    constructor(col, row) { super(); this.col = col; this.row = row; }\n    toString() { return `${this.col}${this.row}`; }\n}\n\nexport class BinaryOp extends Expression {\n    constructor(left, op, right) { super(); this.left = left; this.op = op; this.right = right; }\n    toString() { return `(${this.left} ${this.op} ${this.right})`; }\n}\n\nexport class UnaryOp extends Expression {\n    constructor(op, value) { super(); this.op = op; this.value = value; }\n    toString() { return `${this.op}${this.value}`; }\n}\n\nexport class FunctionCall extends Expression {\n    constructor(functionName, args) { super(); this.functionName = functionName; this.args = args; }\n    toString() { return `${this.functionName}(${this.args.join(', ')})`; }\n}\n\nexport class Range extends Expression {\n    constructor(from, to) { super(); this.from = from; this.to = to; }\n    toString() { return `${this.from}:${this.to}`; }\n}","export function positionsInRange(from, to) {\n    const positions = [];\n    // TODO: Use flatMap?\n    for (let col of _range(columnIndex(from.col), columnIndex(to.col)))\n        for (let row of _range(from.row, to.row))\n            positions.push({ col: columnLetter(col), row: row });\n    return positions;\n}\n\nfunction _range(from, to) {\n    return from <= to\n        ? Array.from({ length: to - from + 1 }, (_, i) => i + from)\n        : Array.from({ length: from - to + 1 }, (_, i) => from - i);\n}\n\nexport function parsePosition(position) {\n    const positionParts = position.match(/^([A-Za-z]+)(\\d+)$/);\n    return positionParts &&\n        { col: positionParts[1], row: parseInt(positionParts[2]) };\n}\n\nexport function makePosition(col, row) {\n    return `${col}${row}`;\n}\n\nexport function columnIndex(colLetter) {\n    return colLetter.charCodeAt(0) - 65;\n}\n\nexport function columnLetter(colIndex) {\n    return String.fromCharCode(colIndex + 65);\n}","import { TokenType } from './tokenizer';\nimport { ParsingError } from './errors';\nimport { Value, Reference, BinaryOp, UnaryOp, Range, FunctionCall } from './expressions';\nimport * as Helpers from './helpers';\n\nexport default class Parser {\n    constructor(tokenizer) {\n        this._tokenizer = tokenizer;\n        this._tokens = null;\n    }\n\n    // cell => empty | '=' expression EOF | number | string\n    parse(text) {\n        // empty cell or other value\n        if (text === null || text === undefined || text.constructor !== String)\n            return { parsed: new Value(text), references: [] };\n\n        // formula\n        if (text.trimStart().startsWith('=')) {\n            this._tokens = this._tokenizer.tokenize(text);\n            this._tokens.require(TokenType.EQUALS);\n            const parsed = this._parseExpression();\n            this._tokens.require(TokenType.EOF);\n            const references = [...new Set(this._getReferences(parsed))];\n            return { parsed, references };\n        }\n\n        // number\n        if (text.match(/^[+-]?\\d+(?:\\.\\d+)?$/))\n            return { parsed: new Value(parseFloat(text)), references: [] };\n\n        // string\n        return { parsed: new Value(text), references: [] };\n    }\n\n    // expression => term\n    _parseExpression() {\n        return this._parseTerm();\n    }\n\n    // term => factor (('+'|'-') factor)*\n    _parseTerm() {\n        let left = this._parseFactor();\n        let operation;\n        while ((operation = this._tokens.expect(TokenType.PLUS, TokenType.MINUS)) !== null) {\n            left = new BinaryOp(left, operation.value, this._parseFactor());\n        }\n        return left;\n    }\n\n    // factor => unary (('*'|'/') unary)*\n    _parseFactor() {\n        let left = this._parseRange();\n        let operation;\n        while ((operation = this._tokens.expect(TokenType.STAR, TokenType.SLASH)) !== null) {\n            left = new BinaryOp(left, operation.value, this._parseRange());\n        }\n        return left;\n    }\n\n    // range => unary (':' unary)*\n    _parseRange() {\n        // TODO: Make ranges first-class\n        return this._parseUnary();\n    }\n\n    // unary => ('+'|'-') unary | call\n    _parseUnary() {\n        const operation = this._tokens.expect(TokenType.PLUS, TokenType.MINUS);\n        return operation !== null\n            ? new UnaryOp(operation.value, this._parseUnary())\n            : this._parseValue();\n    }\n\n    // value => number | string | rangeReference | reference | parenthesized | functionCall\n    _parseValue() {\n        if (this._tokens.expect(TokenType.LPAREN))\n            return this._finishParenthesized();\n\n        const number = this._tokens.expect(TokenType.NUMBER)\n        if (number !== null)\n            return new Value(parseFloat(number.value));\n\n        const string = this._tokens.expect(TokenType.STRING);\n        if (string !== null)\n            return this._parseString(string);\n\n\n        const identifier = this._tokens.expect(TokenType.IDENTIFIER);\n        if (identifier !== null) {\n            if (this._tokens.expect(TokenType.COLON))\n                return this._finishRangeReference(identifier);\n\n            if (this._tokens.expect(TokenType.LPAREN))\n                return this._finishFunctionCall(identifier);\n\n            return this._parseReference(identifier.value);\n        }\n        throw new ParsingError(`Unexpected ${this._tokens.peek().type}, expected an expression or value`)\n    }\n\n    // parenthesized => '(' expression ')'\n    _finishParenthesized() {\n        const contents = this._parseExpression();\n        this._tokens.require(TokenType.RPAREN);\n        return contents;\n    }\n\n    _parseString(string) {\n        const withoutQuotes = string.value.substring(1, string.value.length - 1);\n        const escapedString = withoutQuotes.replace(/\\\\(.)/g, '$1');\n        return new Value(escapedString);\n    }\n\n    // rangeReference => IDENTIFIER ':' IDENTIFIER\n    _finishRangeReference(start) {\n        // start identifier and : are already parsed\n        const end = this._tokens.require(TokenType.IDENTIFIER);\n        const from = this._parseReference(start.value);\n        const to = this._parseReference(end.value);\n        return new Range(from, to);\n    }\n\n    // functionCall => IDENTIFIER ('(' arguments ')')*\n    _finishFunctionCall(identifier) {\n        // TODO: Test or remove nested function calls such as FOO()()\n        // Or check for function return types at runtime?\n\n        // let value = identifier.value;\n        // do {\n        //     const args = this._parseArguments();\n        //     this._tokens.expect(TokenType.RPAREN);\n        //     value = new FunctionCall(value, args);\n        // } while (this._tokens.expect(TokenType.LPAREN))\n        // return value;\n\n        const args = this._parseArguments();\n        this._tokens.expect(TokenType.RPAREN);\n        return new FunctionCall(identifier.value, args);\n    }\n\n    // reference => [A-Za-z]+\\d+\n    _parseReference(reference) {\n        const position = Helpers.parsePosition(reference);\n        if (position === null)\n            throw new ParsingError(`Invalid format of cell reference: ${reference}`);\n        return new Reference(position.col, position.row);\n    }\n\n    // arguments => (expression (',' expression)*)?\n    _parseArguments() {\n        const args = [];\n        while (this._tokens.peek().type !== TokenType.RPAREN) {\n            if (args.length != 0)\n                this._tokens.require(TokenType.COMMA);\n            args.push(this._parseExpression());\n        }\n        return args;\n    }\n\n    _getReferences(expression) {\n        switch (expression.constructor) {\n            case Value:\n                return [];\n            case Reference:\n                return [Helpers.makePosition(expression.col, expression.row)];\n            case UnaryOp:\n                return this._getReferences(expression.value);\n            case BinaryOp:\n                return [...this._getReferences(expression.left), ...this._getReferences(expression.right)];\n            case FunctionCall:\n                return expression.args.flatMap(arg => this._getReferences(arg));\n            case Range:\n                return Helpers.positionsInRange(expression.from, expression.to)\n                    .map(pos => Helpers.makePosition(pos.col, pos.row));\n            default:\n                throw new ParsingError(`Unknown expression type: ${typeof expression}`);\n        }\n    }\n}","import { Value, Reference, BinaryOp, FunctionCall, Range, UnaryOp } from './expressions';\nimport { RuntimeError, ParsingError } from './errors';\nimport * as Helpers from './helpers';\n\nclass CircularReferenceError extends Error {\n    constructor(message, cell) { super(message); this.cell = cell; }\n}\n\nexport default class Evaluator {\n    constructor() {\n        this.visitedCellStack = [];\n    }\n\n    evaluateCellAt(position, cell, environment) {\n        if (this.visitedCellStack.includes(position))\n            throw new CircularReferenceError(`Circular reference detected (${this.visitedCellStack.join(' -> ')} -> ${position})`, cell);\n\n        this.visitedCellStack.push(position);\n        try {\n            const result = this._evaluateCell(cell, environment);\n            this.visitedCellStack.pop();\n            return result;\n        } catch (ex) {\n            this.visitedCellStack.pop()\n            // Normal errors propagate as usual, but CircularReferenceError is used\n            // only to propagate the exception to the originating cell internally\n            // (so it doesn't get reported just as an error in a referenced cell).\n            // Once the CircularReferenceError reaches back to the originating cell,\n            // we turn it into a normal RuntimeError.\n            if (ex instanceof CircularReferenceError && ex.cell === cell) {\n                throw new RuntimeError(ex.message);\n            } else {\n                throw ex;\n            }\n        }\n    }\n\n    evaluateQuery(cell, environment) {\n        return this._evaluateCell(cell, environment);\n    }\n\n    _evaluateCell(cell, environment) {\n        switch (cell.constructor) {\n            case Value:\n                return cell.value;\n            case Reference:\n                return this._evaluateReference(Helpers.makePosition(cell.col, cell.row), environment);\n            case UnaryOp:\n                return this._evaluateUnary(cell.op, cell.value, environment);\n            case BinaryOp:\n                return this._evaluateBinary(cell.left, cell.op, cell.right, environment);\n            case FunctionCall:\n                return this._evaluateFunction(cell.functionName, cell.args, environment);\n            case Range:\n                throw new RuntimeError(`Range references are allowed only as arguments of functions`);\n            default:\n                throw new RuntimeError(`Unknown expression type: ${typeof cell}`);\n        }\n    }\n\n    _evaluateReference(position, environment) {\n        try {\n            return environment.getValue(position);\n        } catch (e) {\n            if (e instanceof ParsingError || e instanceof RuntimeError)\n                throw new RuntimeError(`Error in referenced cell ${position}`);\n            else throw e;\n        }\n    }\n\n    _evaluateExpression(value, environment) {\n        switch (value.constructor) {\n            case Range: return this._evaluateRange(value.from, value.to, environment);\n            default: return this._evaluateCell(value, environment);\n        }\n    }\n\n    _evaluateUnary(op, expression, environment) {\n        const value = this._evaluateCell(expression, environment);\n        switch (op) {\n            case '+': return value;\n            case '-': return -value;\n            default: throw new RuntimeError(`Unknown unary operator: '${op}'`);\n        }\n    }\n\n    _evaluateBinary(left, op, right, environment) {\n        const leftValue = this._evaluateCell(left, environment);\n        const rightValue = this._evaluateCell(right, environment);\n        switch (op) {\n            case '+': return leftValue + rightValue;\n            case '-': return leftValue - rightValue;\n            case '*': return leftValue * rightValue;\n            case '/': return leftValue / rightValue;\n            default: throw new RuntimeError(`Unknown binary operator: '${op}'`);\n        }\n    }\n\n    _evaluateFunction(functionName, args, environment) {\n        const func = environment.getFunction(functionName);\n        try {\n            // TODO: Report different error for arguments and function application\n            // And also test both cases :-)\n            const argumentValues = args.map(arg => this._evaluateExpression(arg, environment));\n            return func(...argumentValues);\n        } catch (ex) {\n            throw new RuntimeError(`Error in function ${functionName}: ${ex}`);\n        }\n    }\n\n    _evaluateRange(from, to, environment) {\n        return Helpers.positionsInRange(from, to)\n            .map(pos => Helpers.makePosition(pos.col, pos.row))\n            .map(pos => this._evaluateReference(pos, environment));\n    }\n}\n","export default class ReferencesMap {\n    constructor() {\n        this._referencesFrom = {};\n        this._referencesTo = {};\n    }\n\n    getReferencesFrom(position) { return this._referencesFrom[position]; }\n    getReferencesTo(position) { return this._referencesTo[position]; }\n\n    addReference(positionFrom, referenceTo) {\n        if (!this._referencesFrom[positionFrom])\n            this._referencesFrom[positionFrom] = [];\n        this._referencesFrom[positionFrom].push(referenceTo);\n\n        if (!this._referencesTo[referenceTo])\n            this._referencesTo[referenceTo] = [];\n        this._referencesTo[referenceTo].push(positionFrom);\n    }\n\n    removeReferencesFrom(position) {\n        const targetNodes = this._referencesFrom[position];\n        for (let target of targetNodes) {\n            const valueIndex = this._referencesTo[target].indexOf(position);\n            if (valueIndex > -1) this._referencesTo[target].splice(valueIndex, 1);\n        }\n        delete this._referencesFrom[position];\n    }\n\n    getAffectedCells(position) {\n        // TODO: maybe optimize using stack and for loop\n        const referencesTo = this.getReferencesTo(position);\n        if (!referencesTo) return [];\n\n        const recursiveReferences = referencesTo.flatMap(this.getAffectedCells.bind(this));\n        return [...referencesTo, ...recursiveReferences];\n    }\n}","import { Tokenizer } from './tokenizer';\nimport Parser from './parser';\nimport Evaluator from './evaluator';\nimport { RuntimeError } from './errors';\nimport ReferencesMap from './referencesMap';\n\nexport class Environment {\n    constructor(cells = {}, builtinFunctions = {}, cellsChangedListener = (() => { })) {\n        this.cells = cells;\n        this.functions = builtinFunctions;\n        this.cellsChangedListener = cellsChangedListener;\n        this._parser = new Parser(new Tokenizer());\n        this._evaluator = new Evaluator();\n\n        this._expressionsCache = {}; // position => expression tree\n        this._valuesCache = {}; // position => value;\n        this._referencesMap = new ReferencesMap();\n    }\n\n    getText(position) {\n        return this.cells.hasOwnProperty(position) ? this.cells[position].toString() : \"\";\n    }\n\n    setText(position, value) {\n        this.cells[position] = value;\n\n        const affectedCells = [position, ...this._referencesMap.getAffectedCells(position)];\n        for (let pos of affectedCells)\n            delete this._valuesCache[pos];\n\n        delete this._expressionsCache[position];\n        if (this._referencesMap.getReferencesFrom(position))\n            this._referencesMap.removeReferencesFrom(position);\n\n        this.cellsChangedListener(affectedCells);\n    }\n\n    getExpression(position) {\n        if (this._expressionsCache.hasOwnProperty(position))\n            return this._expressionsCache[position];\n\n        const text = this.cells.hasOwnProperty(position) ? this.cells[position] : null;\n        const { parsed, references } = this._parser.parse(text);\n        this._expressionsCache[position] = parsed;\n\n        for (let reference of references)\n            this._referencesMap.addReference(position, reference);\n\n        return parsed;\n    }\n\n    getValue(position) {\n        if (this._valuesCache.hasOwnProperty(position))\n            return this._valuesCache[position];\n\n        const result = this._evaluator.evaluateCellAt(position, this.getExpression(position), this);\n        this._valuesCache[position] = result;\n        return result;\n    }\n\n    evaluateQuery(expression) {\n        const { parsed, _ } = this._parser.parse(expression);\n        return this._evaluator.evaluateQuery(parsed, this);\n    }\n\n    getFunction(name) {\n        if (this.functions[name] === undefined)\n            throw new RuntimeError(`Unknown function: ${name}`);\n        return this.functions[name];\n    }\n};","export const builtinFunctions = {\n    SUM: (...args) => {\n        let sum = 0;\n        for (let arg of args.flat()) {\n            if (typeof (arg) === 'number')\n                sum += arg;\n            else if (!(arg === null || arg === undefined))\n                throw new Error(`${typeof (arg)} is not a valid argument to SUM(). Expected number, number[], null or undefined.`);\n        }\n        return sum;\n    },\n\n    AVERAGE: (...args) => {\n        let sum = 0;\n        let count = 0;\n        for (let arg of args.flat()) {\n            if (typeof (arg) === 'number') {\n                sum += arg;\n                count++;\n            } else if (!(arg === null || arg === undefined)) {\n                throw new Error(`${typeof (arg)} is not a valid argument to AVERAGE().`);\n            }\n        }\n        return sum / count;\n    },\n};","import { Environment } from './environment';\nimport { builtinFunctions } from './functions';\nimport * as Helpers from './helpers';\nexport { Helpers };\nexport { SpreadsheetError, RuntimeError, ParsingError } from './errors';\nexport { builtinFunctions };\n\nexport class Spreadsheet {\n    constructor(cells = {}, functions = builtinFunctions, cellsChangedListener) {\n        // TODO: confirm this.cells are updated\n        this.cells = cells;\n        this._environment = new Environment(this.cells, functions, cellsChangedListener);\n    }\n\n    text(position) {\n        return this._environment.getText(position);\n    }\n\n    set(position, text) {\n        this._environment.setText(position, text);\n    }\n\n    value(position) {\n        return this._environment.getValue(position);\n    }\n\n    query(expression) {\n        return this._environment.evaluateQuery(expression);\n    }\n}"],"names":["SpreadsheetError","Error","ParsingError","[object Object]","message","super","this","RuntimeError","TokenStream","tokens","_tokens","_currentPos","types","token","peek","includes","type","expect","join","TokenType","Object","freeze","EOF","WHITESPACE","PLUS","MINUS","STAR","SLASH","LPAREN","RPAREN","COLON","EQUALS","COMMA","NUMBER","STRING","IDENTIFIER","Tokenizer","_rules","pattern","text","remaining","length","_nextToken","push","slice","value","filter","rule","match","Expression","Value","constructor","String","Reference","col","row","BinaryOp","left","op","right","UnaryOp","FunctionCall","functionName","args","Range","from","to","positionsInRange","positions","_range","columnIndex","columnLetter","Array","_","i","parsePosition","position","positionParts","parseInt","makePosition","colLetter","charCodeAt","colIndex","fromCharCode","Parser","tokenizer","_tokenizer","parsed","references","trimStart","startsWith","tokenize","require","_parseExpression","Set","_getReferences","parseFloat","_parseTerm","operation","_parseFactor","_parseRange","_parseUnary","_parseValue","_finishParenthesized","number","string","_parseString","identifier","_finishRangeReference","_finishFunctionCall","_parseReference","contents","escapedString","substring","replace","start","end","_parseArguments","reference","Helpers.parsePosition","expression","Helpers.makePosition","flatMap","arg","Helpers.positionsInRange","map","pos","CircularReferenceError","cell","Evaluator","visitedCellStack","environment","result","_evaluateCell","pop","ex","_evaluateReference","_evaluateUnary","_evaluateBinary","_evaluateFunction","getValue","e","_evaluateRange","leftValue","rightValue","func","getFunction","_evaluateExpression","ReferencesMap","_referencesFrom","_referencesTo","positionFrom","referenceTo","targetNodes","target","valueIndex","indexOf","splice","referencesTo","getReferencesTo","recursiveReferences","getAffectedCells","bind","Environment","cells","builtinFunctions","cellsChangedListener","functions","_parser","_evaluator","_expressionsCache","_valuesCache","_referencesMap","hasOwnProperty","toString","affectedCells","getReferencesFrom","removeReferencesFrom","parse","addReference","evaluateCellAt","getExpression","evaluateQuery","name","undefined","SUM","sum","flat","AVERAGE","count","Spreadsheet","_environment","getText","setText"],"mappings":"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"}