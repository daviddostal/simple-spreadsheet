{"version":3,"file":"simple-spreadsheet.min.mjs","sources":["../src/errors.js","../src/tokenizer.js","../src/expressions.js","../src/parser.js","../src/evaluator.js","../src/environment.js","../src/functions.js","../src/spreadsheet.js"],"sourcesContent":["export class SpreadsheetError extends Error { }\r\n\r\nexport class ParsingError extends SpreadsheetError {\r\n    constructor(message) { super(message); }\r\n    toString() { return `Syntax error: ${this.message}`; }\r\n}\r\n\r\nexport class RuntimeError extends SpreadsheetError {\r\n    constructor(message) { super(message); }\r\n    toString() { return `Evaluation error: ${this.message}`; }\r\n}\r\n","import { ParsingError } from './errors';\r\n\r\nexport const TokenType = Object.freeze({\r\n    EOF: 'EOF',\r\n    WHITESPACE: 'WHITESPACE',\r\n    PLUS: 'PLUS',\r\n    MINUS: 'MINUS',\r\n    STAR: 'STAR',\r\n    SLASH: 'SLASH',\r\n    LPAREN: 'LPAREN',\r\n    RPAREN: 'RPAREN',\r\n    COLON: 'COLON',\r\n    EQUALS: 'EQUALS',\r\n    COMMA: 'COMMA',\r\n    NUMBER: 'NUMBER',\r\n    STRING: 'STRING',\r\n    IDENTIFIER: 'IDENTIFIER',\r\n});\r\n\r\nexport class Tokenizer {\r\n    constructor(rules = {\r\n        '$': TokenType.EOF,\r\n        '\\\\s+': TokenType.WHITESPACE,\r\n        '\\\\+': TokenType.PLUS,\r\n        '-': TokenType.MINUS,\r\n        '\\\\*': TokenType.STAR,\r\n        '\\\\/': TokenType.SLASH,\r\n        '\\\\(': TokenType.LPAREN,\r\n        '\\\\)': TokenType.RPAREN,\r\n        '=': TokenType.EQUALS,\r\n        ':': TokenType.COLON,\r\n        ',': TokenType.COMMA,\r\n        '\\\\d+(?:\\\\.\\\\d+)?': TokenType.NUMBER,\r\n        '\\\\\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\\\\\"': TokenType.STRING,\r\n        '[a-zA-Z]\\\\w+': TokenType.IDENTIFIER,\r\n    }) {\r\n        this.rules = rules;\r\n    }\r\n\r\n    begin(str) {\r\n        this.remaining = str;\r\n        return this;\r\n    }\r\n\r\n    next() {\r\n        const next = this.peek();\r\n        this.remaining = this.remaining.slice(next.value.length);\r\n        return next;\r\n    }\r\n\r\n    peek() {\r\n        for (let rule in this.rules) {\r\n            const match = this.remaining.match(new RegExp('^' + rule));\r\n            if (match !== null) {\r\n                return { type: this.rules[rule], value: match[0] };\r\n            }\r\n        }\r\n        throw new ParsingError(`Unknown token '${this.remaining}'`);\r\n    }\r\n\r\n    rest() {\r\n        const rest = this.remaining;\r\n        this.remaining = \"\";\r\n        return rest;\r\n    }\r\n}","export class Expression { }\r\n\r\nexport class Value extends Expression {\r\n    constructor(value) { super(); this.value = value; }\r\n    toString() { return this.value.constructor === String ? `\"${this.value}\"` : `${this.value}`; }\r\n}\r\n\r\nexport class Reference extends Expression {\r\n    constructor(col, row) { super(); this.col = col; this.row = row; }\r\n    get position() { return `${this.col}${this.row}`; }\r\n    toString() { return `Reference(${this.col}${this.row})`; }\r\n}\r\n\r\nexport class BinaryOp extends Expression {\r\n    constructor(left, op, right) { super(); this.left = left; this.op = op; this.right = right; }\r\n    toString() { return `BinaryOp(${this.left} ${this.op} ${this.right})`; }\r\n}\r\n\r\nexport class UnaryOp extends Expression {\r\n    constructor(op, value) { super(); this.op = op; this.value = value; }\r\n    toString() { return `UnaryOp(${this.op} ${this.value})`; }\r\n}\r\n\r\nexport class FunctionCall extends Expression {\r\n    constructor(functionName, args) { super(); this.functionName = functionName; this.args = args; }\r\n    toString() { return `FunctionCall(${this.functionName}, ${this.args.join(', ')})`; }\r\n}\r\n\r\nexport class Range extends Expression {\r\n    constructor(from, to) { super(); this.from = from; this.to = to; }\r\n    toString() { return `Range(${this.from}, ${this.to})`; }\r\n}","import { TokenType } from './tokenizer';\r\nimport { ParsingError } from './errors';\r\nimport { Value, Reference, BinaryOp, UnaryOp, Range, FunctionCall } from './expressions';\r\n\r\nexport default class Parser {\r\n    constructor(tokenizer) {\r\n        this.tokens = tokenizer;\r\n    }\r\n\r\n    parse(text) {\r\n        if (text === null || text === undefined || text.constructor !== String)\r\n            return new Value(text); // if there is nothing to parse, return the value.\r\n\r\n        this.tokens.begin(text);\r\n        const result = this.parseCell();\r\n        return result;\r\n    }\r\n\r\n    // Cell -> Expression | simple value (string or number)\r\n    parseCell() {\r\n        if (this.tokens.remaining.startsWith('=')) {\r\n            this._expectAny(TokenType.EQUALS);\r\n            const result = this.parseExpression();\r\n            this._require(TokenType.EOF);\r\n            return result;\r\n        } else {\r\n            const value = this.tokens.rest();\r\n            if (value.match(/^[+-]?\\d+(?:\\.\\d+)?$/)) return new Value(parseFloat(value));\r\n            else return new Value(value);\r\n        }\r\n    }\r\n\r\n    // Expression -> Factor\r\n    parseExpression() {\r\n        return this.parseTerm();\r\n    }\r\n\r\n    // Term -> Factor ([+-] Factor)*\r\n    parseTerm() {\r\n        let left = this.parseFactor();\r\n        let operation;\r\n        while ((operation = this._expectAny(TokenType.PLUS, TokenType.MINUS)) !== null) {\r\n            left = new BinaryOp(left, operation.value, this.parseFactor());\r\n        }\r\n        return left;\r\n    }\r\n\r\n    // Factor -> Unary ([*/] Unary)*\r\n    parseFactor() {\r\n        let left = this.parseUnary();\r\n        let operation;\r\n        while ((operation = this._expectAny(TokenType.STAR, TokenType.SLASH)) !== null) {\r\n            left = new BinaryOp(left, operation.value, this.parseUnary());\r\n        }\r\n        return left;\r\n    }\r\n\r\n    // Unary -> [+-] Unary | Value\r\n    parseUnary() {\r\n        let operation = this._expectAny(TokenType.PLUS, TokenType.MINUS);\r\n        return operation !== null\r\n            ? new UnaryOp(operation.value, this.parseUnary())\r\n            : this.parseValue();\r\n    }\r\n\r\n    // Value -> Identifier | number | string | ( Expression ) | RangeReference\r\n    parseValue() {\r\n        // Parenthesized expression\r\n        if (this._expectAny(TokenType.LPAREN)) {\r\n            const contents = this.parseExpression();\r\n            this._require(TokenType.RPAREN);\r\n            return contents;\r\n        }\r\n\r\n        // Number\r\n        const number = this._expectAny(TokenType.NUMBER)\r\n        if (number !== null) { return new Value(parseFloat(number.value)); }\r\n\r\n        // String\r\n        const string = this._expectAny(TokenType.STRING);\r\n        if (string !== null) {\r\n            const withoutQuotes = string.value.substring(1, string.value.length - 1);\r\n            const escapedString = withoutQuotes.replace(/\\\\(.)/g, '$1');\r\n            return new Value(escapedString);\r\n        }\r\n\r\n        const identifier = this._require(TokenType.IDENTIFIER);\r\n        // Range\r\n        if (identifier !== null && this._expectAny(TokenType.COLON)) {\r\n            const endIdentifier = this._require(TokenType.IDENTIFIER);\r\n            const from = this._parseReference(identifier.value);\r\n            const to = this._parseReference(endIdentifier.value);\r\n            return new Range(from, to);\r\n        }\r\n\r\n        // Function call\r\n        if (this._expectAny(TokenType.LPAREN)) {\r\n            let value = identifier.value;\r\n            do {\r\n                const args = this.parseArguments();\r\n                value = new FunctionCall(value, args);\r\n            } while (this._expectAny(TokenType.LPAREN))\r\n            return value;\r\n        }\r\n\r\n        // Reference\r\n        return this._parseReference(identifier.value);\r\n    }\r\n\r\n    // Reference -> [A-Za-z]+\\d+\r\n    _parseReference(reference) {\r\n        const referenceParts = reference.match(/^([A-Za-z]+)(\\d+)$/);\r\n        if (referenceParts === null)\r\n            throw new ParsingError(`Invalid format of cell reference: ${reference}`);\r\n        return new Reference(referenceParts[1], parseInt(referenceParts[2]));\r\n    }\r\n\r\n    // Arguments -> (Expression (, Expression)*)?\r\n    parseArguments() {\r\n        const args = [];\r\n        while (!this._expectAny(TokenType.RPAREN)) {\r\n            if (args.length != 0)\r\n                this._require(TokenType.COMMA);\r\n            args.push(this.parseExpression());\r\n        }\r\n        return args;\r\n    }\r\n\r\n    _expectAny(...types) {\r\n        const current = this._next();\r\n        if (types.includes(current.type)) {\r\n            this.tokens.next();\r\n            return current;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    _require(type) {\r\n        const next = this._expectAny(type);\r\n        if (next === null)\r\n            throw new ParsingError(`Expected ${type}, got ${this.tokens.peek().type} instead`);\r\n        else\r\n            return next;\r\n    }\r\n\r\n    _next() {\r\n        let current = this.tokens.peek();\r\n        while (current.type === TokenType.WHITESPACE) {\r\n            this.tokens.next();\r\n            current = this.tokens.peek();\r\n        }\r\n        return current;\r\n    }\r\n}","import { Value, Reference, BinaryOp, FunctionCall, Range, UnaryOp } from './expressions';\r\nimport { RuntimeError, ParsingError } from './errors';\r\n\r\nexport default class Evaluator {\r\n    evaluateCell(cell, environment) {\r\n        switch (cell.constructor) {\r\n            case Value:\r\n                return cell.value;\r\n            case Reference:\r\n                return this.evaluateReference(cell.position, environment);\r\n            case UnaryOp:\r\n                return this.evaluateUnary(cell.op, cell.value, environment);\r\n            case BinaryOp:\r\n                return this.evaluateBinary(cell.left, cell.op, cell.right, environment);\r\n            case FunctionCall:\r\n                return this.evaluateFunction(cell.functionName, cell.args, environment);\r\n            case Range:\r\n                throw new RuntimeError(`Range references are allowed only as arguments of functions`);\r\n            default:\r\n                throw new RuntimeError(`Unknown expression type: ${typeof cell}`);\r\n        }\r\n    }\r\n\r\n    evaluateReference(position, environment) {\r\n        try {\r\n            const entry = environment.getExpression(position) || new Value(null);\r\n            return this.evaluateCell(entry, environment);\r\n        } catch (e) {\r\n            if (e instanceof ParsingError)\r\n                throw new RuntimeError(`Error in referenced cell: ${position}`);\r\n            else throw e;\r\n        }\r\n    }\r\n\r\n    evaluateExpression(value, environment) {\r\n        switch (value.constructor) {\r\n            case Range: return this.evaluateRange(value.from, value.to, environment);\r\n            default: return this.evaluateCell(value, environment);\r\n        }\r\n    }\r\n\r\n    evaluateUnary(op, expression, environment) {\r\n        const value = this.evaluateCell(expression, environment);\r\n        switch (op) {\r\n            case '+': return value;\r\n            case '-': return -value;\r\n            default: throw new RuntimeError(`Unknown unary operator: '${op}'`);\r\n        }\r\n    }\r\n\r\n    evaluateBinary(left, op, right, environment) {\r\n        const leftValue = this.evaluateCell(left, environment);\r\n        const rightValue = this.evaluateCell(right, environment);\r\n        switch (op) {\r\n            case '+': return leftValue + rightValue;\r\n            case '-': return leftValue - rightValue;\r\n            case '*': return leftValue * rightValue;\r\n            case '/': return leftValue / rightValue;\r\n            default: throw new RuntimeError(`Unknown binary operator: '${op}'`);\r\n        }\r\n    }\r\n\r\n    evaluateFunction(functionName, args, environment) {\r\n        const argumentValues = args.map(arg => this.evaluateExpression(arg, environment));\r\n        const func = environment.getFunction(functionName);\r\n        try {\r\n            return func(...argumentValues);\r\n        } catch (ex) {\r\n            throw new RuntimeError(`Error in function ${functionName}: ${ex}`);\r\n        }\r\n    }\r\n\r\n    evaluateRange(from, to, environment) {\r\n        const cells = this._cellsInRange(from, to);\r\n        const cellValues = cells.map(cell => this.evaluateCell(cell, environment));\r\n        return cellValues;\r\n    }\r\n\r\n    _cellsInRange(from, to) {\r\n        const cells = [];\r\n        for (let col of this._range(from.col.charCodeAt(0), to.col.charCodeAt(0)))\r\n            for (let row of this._range(from.row, to.row))\r\n                cells.push(new Reference(String.fromCharCode(col), row));\r\n        return cells;\r\n    }\r\n\r\n    _range(from, to) {\r\n        return from <= to\r\n            ? Array.from({ length: to - from + 1 }, (_, i) => i + from)\r\n            : Array.from({ length: from - to + 1 }, (_, i) => from - i);\r\n    }\r\n}\r\n","import { Tokenizer } from './tokenizer';\r\nimport Parser from './parser';\r\nimport Evaluator from './evaluator';\r\nimport { RuntimeError } from './errors';\r\n\r\nexport class Environment {\r\n    constructor(cells = {}, builtinFunctions = {}) {\r\n        this.cells = cells;\r\n        this.functions = builtinFunctions;\r\n        this._parser = new Parser(new Tokenizer());\r\n        this._evaluator = new Evaluator();\r\n    }\r\n\r\n    getText(position) {\r\n        return this.cells.hasOwnProperty(position) ? this.cells[position].toString() : \"\";\r\n    }\r\n\r\n    getExpression(position) {\r\n        const value = this.cells.hasOwnProperty(position) ? this.cells[position] : null;\r\n        return this._parser.parse(value);\r\n    }\r\n\r\n    getValue(position) {\r\n        return this._evaluator.evaluateCell(this.getExpression(position), this);\r\n    }\r\n\r\n    getFunction(name) {\r\n        if (this.functions[name] === undefined)\r\n            throw new RuntimeError(`Unknown function: ${name} is not a function`);\r\n        return this.functions[name];\r\n    }\r\n};","export const builtinFunctions = {\r\n    SUM: (...values) => values.flat().reduce((a, b) => a + b, 0),\r\n    AVERAGE: (...values) => values.flat().reduce((a, b) => a + b, 0) / values.flat().length,\r\n};","import { Environment } from './environment';\r\nimport { builtinFunctions } from './functions';\r\nexport { SpreadsheetError, RuntimeError, ParsingError } from './errors';\r\nexport { builtinFunctions };\r\n\r\nexport class Spreadsheet {\r\n    constructor(cells = {}, functions = builtinFunctions) {\r\n        this.cells = cells;\r\n        this.builtinFunctions = functions;\r\n        this.environment = new Environment(this.cells, this.builtinFunctions);\r\n    }\r\n\r\n    text(position) {\r\n        return this.environment.getText(position);\r\n    }\r\n\r\n    value(position) {\r\n        return this.environment.getValue(position);\r\n    }\r\n}"],"names":["SpreadsheetError","Error","ParsingError","[object Object]","message","super","this","RuntimeError","TokenType","Object","freeze","EOF","WHITESPACE","PLUS","MINUS","STAR","SLASH","LPAREN","RPAREN","COLON","EQUALS","COMMA","NUMBER","STRING","IDENTIFIER","Tokenizer","rules","$","\\s+","\\+","-","\\*","\\/","\\(","\\)","=",":",",","\\d+(?:\\.\\d+)?","\\\"(?:[^\"\\\\]|\\\\.)*\\\"","[a-zA-Z]\\w+","str","remaining","next","peek","slice","value","length","rule","match","RegExp","type","rest","Expression","Value","constructor","String","Reference","col","row","position","BinaryOp","left","op","right","UnaryOp","FunctionCall","functionName","args","join","Range","from","to","Parser","tokenizer","tokens","text","begin","parseCell","startsWith","_expectAny","result","parseExpression","_require","parseFloat","parseTerm","operation","parseFactor","parseUnary","parseValue","contents","number","string","escapedString","substring","replace","identifier","endIdentifier","_parseReference","parseArguments","reference","referenceParts","parseInt","push","types","current","_next","includes","Evaluator","cell","environment","evaluateReference","evaluateUnary","evaluateBinary","evaluateFunction","entry","getExpression","evaluateCell","e","evaluateRange","expression","leftValue","rightValue","argumentValues","map","arg","evaluateExpression","func","getFunction","ex","_cellsInRange","cells","_range","charCodeAt","fromCharCode","Array","_","i","Environment","builtinFunctions","functions","_parser","_evaluator","hasOwnProperty","toString","parse","name","undefined","SUM","values","flat","reduce","a","b","AVERAGE","Spreadsheet","getText","getValue"],"mappings":"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"}