"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class NotImplementedError extends Error{constructor(e){super(e)}toString(){return`Not implemented: ${this.message}`}}class SpreadsheetError extends Error{}class ParsingError extends SpreadsheetError{constructor(e){super(e)}toString(){return`Syntax error: ${this.message}`}}class RuntimeError extends SpreadsheetError{constructor(e){super(e)}toString(){return`Evaluation error: ${this.message}`}}class ReferencedCellError extends RuntimeError{constructor(e){super(`Error in referenced cell: ${e}`),this.cell=e}}class CircularReferenceError extends RuntimeError{constructor(e){super(`Circular reference detected: ${e.join(" -> ")}`),this.cells=e}}class FunctionEvaluationError extends RuntimeError{constructor(e,t){super(`Error in function ${e}: ${t}`),this.functionName=e,this.error=t}}class RangeReferenceNotAllowedError extends RuntimeError{constructor(){super("Range references are allowed only as references to functions")}}class TokenStream{constructor(e){this._tokens=e,this._currentPos=0}peek(){return this._tokens[this._currentPos]||null}expect(...e){const t=this.peek();return null!==t&&e.includes(t.type)?(this._currentPos++,t):null}require(...e){const t=this.expect(...e);if(null===t)throw new ParsingError(`Unexpected ${this.peek().type.description}, expected ${e.map(e=>e.description).join(" or ")}`);return t}}const TokenType=Object.freeze({EOF:Symbol("end of formula"),WHITESPACE:Symbol("whitespace"),PLUS:Symbol("+"),MINUS:Symbol("-"),STAR:Symbol("*"),SLASH:Symbol("/"),LPAREN:Symbol("opening parenthesis"),RPAREN:Symbol("closing parenthesis"),COLON:Symbol(":"),EQUALS:Symbol("="),COMMA:Symbol("comma"),NUMBER:Symbol("number"),STRING:Symbol("string"),IDENTIFIER:Symbol("identifier")});class Tokenizer{constructor(){this._rules=[{pattern:/^\d+(?:\.\d+)?/,type:TokenType.NUMBER},{pattern:/^[a-zA-Z]\w+/,type:TokenType.IDENTIFIER},{pattern:/^"(?:[^"\\]|\\.)*"/,type:TokenType.STRING},{pattern:/^$/,type:TokenType.EOF}],this._operators={" ":TokenType.WHITESPACE,"\t":TokenType.WHITESPACE,"\r":TokenType.WHITESPACE,"\n":TokenType.WHITESPACE,"+":TokenType.PLUS,"-":TokenType.MINUS,"*":TokenType.STAR,"/":TokenType.SLASH,"(":TokenType.LPAREN,")":TokenType.RPAREN,"=":TokenType.EQUALS,":":TokenType.COLON,",":TokenType.COMMA}}tokenize(e){const t=[];let r=e;for(;r.length>0;){const e=this._nextToken(r);t.push(e),r=r.slice(e.value.length)}return t.push({type:TokenType.EOF,value:""}),new TokenStream(t.filter(e=>e.type!==TokenType.WHITESPACE))}_nextToken(e){const t=e[0],r=this._operators[t];if(void 0!==r)return{type:r,value:t};for(let t of this._rules){const r=e.match(t.pattern);if(null!==r)return{type:t.type,value:r[0]}}throw new ParsingError(`Unknown token at '${e}'`)}}class Expression{}class Value extends Expression{constructor(e){super(),this.value=e}toString(){return this.value.constructor===String?`"${this.value}"`:`${this.value}`}}class Reference extends Expression{constructor(e,t){super(),this.col=e,this.row=t}toString(){return`${this.col}${this.row}`}}class BinaryOp extends Expression{constructor(e,t,r){super(),this.left=e,this.op=t,this.right=r}toString(){return`(${this.left} ${this.op} ${this.right})`}}class UnaryOp extends Expression{constructor(e,t){super(),this.op=e,this.value=t}toString(){return`${this.op}${this.value}`}}class FunctionCall extends Expression{constructor(e,t){super(),this.functionName=e,this.args=t}toString(){return`${this.functionName}(${this.args.join(", ")})`}}class Range extends Expression{constructor(e,t){super(),this.from=e,this.to=t}toString(){return`${this.from}:${this.to}`}}function positionsInRange(e,t){const r=[];for(let n of _range(columnIndex(e.col),columnIndex(t.col)))for(let s of _range(e.row,t.row))r.push({col:columnLetter(n),row:s});return r}function _range(e,t){return e<=t?Array.from({length:t-e+1},(t,r)=>r+e):Array.from({length:e-t+1},(t,r)=>e-r)}function parsePosition(e){const t=e.match(/^([A-Za-z]+)(\d+)$/);return t&&{col:t[1],row:parseInt(t[2])}}function makePosition(e,t){return`${e}${t}`}function columnIndex(e){return e.charCodeAt(0)-65}function columnLetter(e){return String.fromCharCode(e+65)}var helpers=Object.freeze({positionsInRange:positionsInRange,parsePosition:parsePosition,makePosition:makePosition,columnIndex:columnIndex,columnLetter:columnLetter});class Parser{constructor(e){this._tokenizer=e,this._tokens=null}parse(e){if(!(null!=e&&e.constructor===String))return{parsed:new Value(e),references:[]};if("="===e[0]){this._tokens=this._tokenizer.tokenize(e),this._tokens.require(TokenType.EQUALS);const t=this._parseExpression();return this._tokens.require(TokenType.EOF),{parsed:t,references:this._referencesIn(t)}}return e.match(/^[+-]?\d+(?:\.\d+)?$/)?{parsed:new Value(parseFloat(e)),references:[]}:{parsed:new Value(e),references:[]}}_parseExpression(){return this._parseTerm()}_parseTerm(){let e,t=this._parseFactor();for(;null!==(e=this._tokens.expect(TokenType.PLUS,TokenType.MINUS));)t=new BinaryOp(t,e.value,this._parseFactor());return t}_parseFactor(){let e,t=this._parseRange();for(;null!==(e=this._tokens.expect(TokenType.STAR,TokenType.SLASH));)t=new BinaryOp(t,e.value,this._parseRange());return t}_parseRange(){return this._parseUnary()}_parseUnary(){const e=this._tokens.expect(TokenType.PLUS,TokenType.MINUS);return null!==e?new UnaryOp(e.value,this._parseUnary()):this._parseValue()}_parseValue(){if(this._tokens.expect(TokenType.LPAREN))return this._finishParenthesized();const e=this._tokens.expect(TokenType.NUMBER);if(null!==e)return new Value(parseFloat(e.value));const t=this._tokens.expect(TokenType.STRING);if(null!==t)return this._parseString(t);const r=this._tokens.expect(TokenType.IDENTIFIER);if(null!==r)return this._tokens.expect(TokenType.COLON)?this._finishRangeReference(r):this._tokens.expect(TokenType.LPAREN)?this._finishFunctionCall(r):this._parseReference(r.value);throw new ParsingError(`Unexpected ${this._tokens.peek().type.description}, expected an expression or value`)}_finishParenthesized(){const e=this._parseExpression();return this._tokens.require(TokenType.RPAREN),e}_parseString(e){const t=e.value.substring(1,e.value.length-1).replace(/\\(.)/g,"$1");return new Value(t)}_finishRangeReference(e){const t=this._tokens.require(TokenType.IDENTIFIER),r=this._parseReference(e.value),n=this._parseReference(t.value);return new Range(r,n)}_finishFunctionCall(e){const t=this._parseArguments();return this._tokens.expect(TokenType.RPAREN),new FunctionCall(e.value,t)}_parseReference(e){const t=parsePosition(e);if(null===t)throw new ParsingError(`Invalid format of cell reference: ${e}`);return new Reference(t.col,t.row)}_parseArguments(){const e=[];for(;this._tokens.peek().type!==TokenType.RPAREN;)0!=e.length&&this._tokens.require(TokenType.COMMA),e.push(this._parseExpression());return e}_referencesIn(e){switch(e.constructor){case Value:return[];case Reference:return[makePosition(e.col,e.row)];case UnaryOp:return this._referencesIn(e.value);case BinaryOp:return[...this._referencesIn(e.left),...this._referencesIn(e.right)];case FunctionCall:return e.args.flatMap(e=>this._referencesIn(e));case Range:return positionsInRange(e.from,e.to).map(e=>makePosition(e.col,e.row));default:throw new NotImplementedError(`Unknown expression type: ${typeof e}`)}}}class CircularRefInternal extends Error{constructor(e,t){super(e),this.position=t}}class Evaluator{constructor(){this.visitedCellStack=[]}evaluateCellAt(e,t,r){if(this.visitedCellStack.includes(e))throw new CircularRefInternal(`Circular reference detected (${this.visitedCellStack.join(" -> ")} -> ${e})`,e);this.visitedCellStack.push(e);try{const n=this._evaluateCell(t,r);return this.visitedCellStack.pop(),n}catch(t){throw this.visitedCellStack.pop(),t instanceof CircularRefInternal&&t.position===e?new CircularReferenceError([...this.visitedCellStack,e]):t}}evaluateQuery(e,t){return this._evaluateCell(e,t)}_evaluateCell(e,t){switch(e.constructor){case Value:return e.value;case Reference:return this._evaluateReference(makePosition(e.col,e.row),t);case UnaryOp:return this._evaluateUnary(e.op,e.value,t);case BinaryOp:return this._evaluateBinary(e.left,e.op,e.right,t);case FunctionCall:return this._evaluateFunction(e.functionName,e.args,t);case Range:throw new RangeReferenceNotAllowedError;default:throw new NotImplementedError(`Unknown expression type: ${typeof e}`)}}_evaluateReference(e,t){try{return t.getValue(e)}catch(t){throw t instanceof ParsingError||t instanceof RuntimeError?new ReferencedCellError(e):t}}_evaluateExpression(e,t){switch(e.constructor){case Range:return this._evaluateRange(e.from,e.to,t);default:return this._evaluateCell(e,t)}}_evaluateUnary(e,t,r){const n=this._evaluateCell(t,r);switch(e){case"+":return n;case"-":return-n;default:throw new NotImplementedError(`Unknown unary operator: '${e}'`)}}_evaluateBinary(e,t,r,n){const s=this._evaluateCell(e,n),o=this._evaluateCell(r,n);switch(t){case"+":return s+o;case"-":return s-o;case"*":return s*o;case"/":return s/o;default:throw new NotImplementedError(`Unknown binary operator: '${t}'`)}}_evaluateFunction(e,t,r){let n=r.getFunction(e);return!0===(n=n instanceof Function?{isMacro:!1,function:n}:n).isMacro?this._evaluateMacro(e,n,t,r):this._evaluateSpreadsheetFunction(e,n,t,r)}_evaluateSpreadsheetFunction(e,t,r,n){const s=r.map(e=>this._evaluateExpression(e,n));try{return t.function(...s)}catch(t){throw new FunctionEvaluationError(e,t)}}_evaluateMacro(e,t,r,n){const s=r.map(e=>()=>this._evaluateExpression(e,n));try{return t.function(...s)}catch(t){throw new FunctionEvaluationError(e,t)}}_evaluateRange(e,t,r){return positionsInRange(e,t).map(e=>makePosition(e.col,e.row)).map(e=>this._evaluateReference(e,r))}}class ReferencesMap{constructor(){this._referencesFrom=new Map,this._referencesTo=new Map}addReferences(e,t){this._referencesFrom.has(e)||this._referencesFrom.set(e,new Set(t));for(let r of t)this._referencesFrom.get(e).add(r),this._referencesTo.has(r)||this._referencesTo.set(r,new Set),this._referencesTo.get(r).add(e)}removeReferencesFrom(e){const t=this._referencesFrom.get(e);if(t){for(let r of t)this._referencesTo.get(r).delete(e);this._referencesFrom.delete(e)}}cellsDependingOn(e){const t=new Set,r=[e];for(;r.length>0;){const e=r.pop();t.add(e);const n=(this._referencesTo.has(e)?[...this._referencesTo.get(e)].filter(e=>!t.has(e)):[]).filter(e=>!t.has(e));r.push(...n)}return t}}class Environment{constructor(e,t,r){this.cells=e,this.functions=t,this.onCellsChanged=r,this._parser=new Parser(new Tokenizer),this._evaluator=new Evaluator,this._expressionsCache=new Map,this._valuesCache=new Map,this._referencesMap=new ReferencesMap}getText(e){return this.cells.has(e)?this.cells.get(e).toString():""}setText(e,t){this.cells.set(e,t);const r=this._referencesMap.cellsDependingOn(e);for(let e of r)this._valuesCache.delete(e);this._expressionsCache.delete(e),this._referencesMap.removeReferencesFrom(e),this.onCellsChanged([...r])}getExpression(e){if(this._expressionsCache.has(e))return this._expressionsCache.get(e);const t=this.cells.has(e)?this.cells.get(e):null,{parsed:r,references:n}=this._parser.parse(t);return this._expressionsCache.set(e,r),this._referencesMap.addReferences(e,n),r}getValue(e){if(this._valuesCache.has(e))return this._valuesCache.get(e);const t=this._evaluator.evaluateCellAt(e,this.getExpression(e),this);return this._valuesCache.set(e,t),t}evaluateQuery(e){const{parsed:t,_:r}=this._parser.parse(e);return this._evaluator.evaluateQuery(t,this)}getFunction(e){if(!this.functions.has(e))throw new RuntimeError(`Unknown function: ${e}`);return this.functions.get(e)}}class Spreadsheet{constructor(e=new Map,t=new Map,r=(()=>{})){this.cells=e instanceof Map?e:new Map(Object.entries(e)),this.functions=t instanceof Map?t:new Map(Object.entries(t)),this._environment=new Environment(this.cells,this.functions,r)}text(e){return this._environment.getText(e)}set(e,t){this._environment.setText(e,t)}value(e){return this._environment.getValue(e)}query(e){return this._environment.evaluateQuery(e)}}exports.Helpers=helpers,exports.ParsingError=ParsingError,exports.RuntimeError=RuntimeError,exports.Spreadsheet=Spreadsheet,exports.SpreadsheetError=SpreadsheetError;
//# sourceMappingURL=simple-spreadsheet.min.js.map
