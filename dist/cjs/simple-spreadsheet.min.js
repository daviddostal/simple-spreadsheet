"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class NotImplementedError extends Error{constructor(e){super(e)}toString(){return`Not implemented: ${this.message}`}}class SpreadsheetError extends Error{}class ParsingError extends SpreadsheetError{constructor(e){super(e)}toString(){return`Syntax error: ${this.message}`}}class RuntimeError extends SpreadsheetError{constructor(e){super(e)}toString(){return`Evaluation error: ${this.message}`}}class ReferencedCellError extends RuntimeError{constructor(e){super(`Error in referenced cell: ${e}`),this.cell=e}}class CircularReferenceError extends RuntimeError{constructor(e){super(`Circular reference detected: ${e.join(" -> ")}`),this.cells=e}}class FunctionEvaluationError extends RuntimeError{constructor(e,r){super(`Error in function ${e}: ${r}`),this.functionName=e,this.error=r}}class RangeReferenceNotAllowedError extends RuntimeError{constructor(){super("Range references are allowed only as references to functions")}}class UnknownFunctionError extends RuntimeError{constructor(e){super(`Unknown function: ${e}`),this.functionName=e}}class TokenStream{constructor(e){this._tokens=e,this._currentPos=0}peek(){return this._tokens[this._currentPos]||null}expect(...e){const r=this.peek();return null!==r&&e.includes(r.type)?(this._currentPos++,r):null}require(...e){const r=this.expect(...e);if(null===r)throw new ParsingError(`Unexpected ${this.peek().type.description}, expected ${e.map((e=>e.description)).join(" or ")}`);return r}}const e=Object.freeze({EOF:Symbol("end of formula"),WHITESPACE:Symbol("whitespace"),PLUS:Symbol("+"),MINUS:Symbol("-"),STAR:Symbol("*"),SLASH:Symbol("/"),LPAREN:Symbol("opening parenthesis"),RPAREN:Symbol("closing parenthesis"),COLON:Symbol(":"),EQUALS:Symbol("="),COMMA:Symbol("comma"),NUMBER:Symbol("number"),STRING:Symbol("string"),IDENTIFIER:Symbol("identifier")});class Tokenizer{constructor(){this._rules=[{pattern:/^\d+(?:\.\d+)?/,type:e.NUMBER},{pattern:/^[a-zA-Z]\w+/,type:e.IDENTIFIER},{pattern:/^"(?:[^"\\]|\\.)*"/,type:e.STRING},{pattern:/^$/,type:e.EOF}],this._operators={" ":e.WHITESPACE,"\t":e.WHITESPACE,"\r":e.WHITESPACE,"\n":e.WHITESPACE,"+":e.PLUS,"-":e.MINUS,"*":e.STAR,"/":e.SLASH,"(":e.LPAREN,")":e.RPAREN,"=":e.EQUALS,":":e.COLON,",":e.COMMA}}tokenize(r){const t=[];let n=r;for(;n.length>0;){const e=this._nextToken(n);t.push(e),n=n.slice(e.value.length)}return t.push({type:e.EOF,value:""}),new TokenStream(t.filter((r=>r.type!==e.WHITESPACE)))}_nextToken(e){const r=e[0],t=this._operators[r];if(void 0!==t)return{type:t,value:r};for(let r of this._rules){const t=e.match(r.pattern);if(null!==t)return{type:r.type,value:t[0]}}throw new ParsingError(`Unknown token at '${e}'`)}}class Expression{}class Value extends Expression{constructor(e){super(),this.value=e}toString(){return this.value.constructor===String?`"${this.value}"`:`${this.value}`}}class Reference extends Expression{constructor(e,r){super(),this.col=e,this.row=r}toString(){return`${this.col}${this.row}`}}class BinaryOp extends Expression{constructor(e,r,t){super(),this.left=e,this.op=r,this.right=t}toString(){return`(${this.left} ${this.op} ${this.right})`}}class UnaryOp extends Expression{constructor(e,r){super(),this.op=e,this.value=r}toString(){return`${this.op}${this.value}`}}class FunctionCall extends Expression{constructor(e,r){super(),this.functionName=e,this.args=r}toString(){return`${this.functionName}(${this.args.join(", ")})`}}class Range extends Expression{constructor(e,r){super(),this.from=e,this.to=r}toString(){return`${this.from}:${this.to}`}}function r(e,r){const n=[];for(let s of t(o(e.col),o(r.col)))for(let o of t(e.row,r.row))n.push({col:i(s),row:o});return n}function t(e,r){return e<=r?Array.from({length:r-e+1},((r,t)=>t+e)):Array.from({length:e-r+1},((r,t)=>e-t))}function n(e){const r=e.match(/^([A-Za-z]+)(\d+)$/);return r&&{col:r[1],row:parseInt(r[2])}}function s(e,r){return`${e}${r}`}function o(e){return e.charCodeAt(0)-65}function i(e){return String.fromCharCode(e+65)}var a=Object.freeze({__proto__:null,positionsInRange:r,parsePosition:n,makePosition:s,columnIndex:o,columnLetter:i});class Parser{constructor(e){this._tokenizer=e,this._tokens=null}parse(r){if(!(null!=r&&r.constructor===String))return{parsed:new Value(r),references:[]};if("="===r[0]){this._tokens=this._tokenizer.tokenize(r),this._tokens.require(e.EQUALS);const t=this._parseExpression();this._tokens.require(e.EOF);return{parsed:t,references:this._referencesIn(t)}}return r.match(/^[+-]?\d+(?:\.\d+)?$/)?{parsed:new Value(parseFloat(r)),references:[]}:{parsed:new Value(r),references:[]}}_parseExpression(){return this._parseTerm()}_parseTerm(){let r,t=this._parseFactor();for(;null!==(r=this._tokens.expect(e.PLUS,e.MINUS));)t=new BinaryOp(t,r.value,this._parseFactor());return t}_parseFactor(){let r,t=this._parseRange();for(;null!==(r=this._tokens.expect(e.STAR,e.SLASH));)t=new BinaryOp(t,r.value,this._parseRange());return t}_parseRange(){return this._parseUnary()}_parseUnary(){const r=this._tokens.expect(e.PLUS,e.MINUS);return null!==r?new UnaryOp(r.value,this._parseUnary()):this._parseValue()}_parseValue(){if(this._tokens.expect(e.LPAREN))return this._finishParenthesized();const r=this._tokens.expect(e.NUMBER);if(null!==r)return new Value(parseFloat(r.value));const t=this._tokens.expect(e.STRING);if(null!==t)return this._parseString(t);const n=this._tokens.expect(e.IDENTIFIER);if(null!==n)return this._tokens.expect(e.COLON)?this._finishRangeReference(n):this._tokens.expect(e.LPAREN)?this._finishFunctionCall(n):this._parseReference(n.value);throw new ParsingError(`Unexpected ${this._tokens.peek().type.description}, expected an expression or value`)}_finishParenthesized(){const r=this._parseExpression();return this._tokens.require(e.RPAREN),r}_parseString(e){const r=e.value.substring(1,e.value.length-1).replace(/\\(.)/g,"$1");return new Value(r)}_finishRangeReference(r){const t=this._tokens.require(e.IDENTIFIER),n=this._parseReference(r.value),s=this._parseReference(t.value);return new Range(n,s)}_finishFunctionCall(r){const t=this._parseArguments();return this._tokens.expect(e.RPAREN),new FunctionCall(r.value,t)}_parseReference(e){const r=n(e);if(null===r)throw new ParsingError(`Invalid format of cell reference: ${e}`);return new Reference(r.col,r.row)}_parseArguments(){const r=[];for(;this._tokens.peek().type!==e.RPAREN;)0!=r.length&&this._tokens.require(e.COMMA),r.push(this._parseExpression());return r}_referencesIn(e){switch(e.constructor){case Value:return[];case Reference:return[s(e.col,e.row)];case UnaryOp:return this._referencesIn(e.value);case BinaryOp:return[...this._referencesIn(e.left),...this._referencesIn(e.right)];case FunctionCall:return e.args.flatMap((e=>this._referencesIn(e)));case Range:return r(e.from,e.to).map((e=>s(e.col,e.row)));default:throw new NotImplementedError("Unknown expression type: "+typeof e)}}}class CircularRefInternal extends Error{constructor(e,r){super(),this.position=e,this.circlePositions=r}}class Evaluator{constructor(){this.visitedCellStack=[]}evaluateCellAt(e,r,t){if(this.visitedCellStack.includes(e))throw new CircularRefInternal(e,[...this.visitedCellStack,e]);this.visitedCellStack.push(e);try{const e=this._evaluateCell(r,t);return this.visitedCellStack.pop(),e}catch(r){throw this.visitedCellStack.pop(),r instanceof CircularRefInternal&&r.position===e?new CircularReferenceError(r.circlePositions):r}}evaluateQuery(e,r){return this._evaluateCell(e,r)}_evaluateCell(e,r){switch(e.constructor){case Value:return e.value;case Reference:return this._evaluateReference(s(e.col,e.row),r);case UnaryOp:return this._evaluateUnary(e.op,e.value,r);case BinaryOp:return this._evaluateBinary(e.left,e.op,e.right,r);case FunctionCall:return this._evaluateFunction(e.functionName,e.args,r);case Range:throw new RangeReferenceNotAllowedError;default:throw new NotImplementedError("Unknown expression type: "+typeof e)}}_evaluateReference(e,r){try{return r.getValue(e)}catch(r){throw r instanceof ParsingError||r instanceof RuntimeError?new ReferencedCellError(e):r}}_evaluateExpression(e,r){switch(e.constructor){case Range:return this._evaluateRange(e.from,e.to,r);default:return this._evaluateCell(e,r)}}_evaluateUnary(e,r,t){const n=this._evaluateCell(r,t);switch(e){case"+":return n;case"-":return-n;default:throw new NotImplementedError(`Unknown unary operator: '${e}'`)}}_evaluateBinary(e,r,t,n){const s=this._evaluateCell(e,n),o=this._evaluateCell(t,n);switch(r){case"+":return s+o;case"-":return s-o;case"*":return s*o;case"/":return s/o;default:throw new NotImplementedError(`Unknown binary operator: '${r}'`)}}_evaluateFunction(e,r,t){let n=t.getFunction(e);return n=n instanceof Function?{isMacro:!1,function:n}:n,!0===n.isMacro?this._evaluateMacro(e,n,r,t):this._evaluateSpreadsheetFunction(e,n,r,t)}_evaluateSpreadsheetFunction(e,r,t,n){const s=t.map((e=>this._evaluateExpression(e,n)));try{return r.function(...s)}catch(r){throw new FunctionEvaluationError(e,r)}}_evaluateMacro(e,r,t,n){const s=t.map((e=>()=>this._evaluateExpression(e,n)));try{return r.function(...s)}catch(r){throw new FunctionEvaluationError(e,r)}}_evaluateRange(e,t,n){return r(e,t).map((e=>s(e.col,e.row))).map((e=>this._evaluateReference(e,n)))}}class ReferencesMap{constructor(){this._referencesFrom=new Map,this._referencesTo=new Map}addReferences(e,r){this._referencesFrom.has(e)||this._referencesFrom.set(e,new Set(r));for(let t of r)this._referencesFrom.get(e).add(t),this._referencesTo.has(t)||this._referencesTo.set(t,new Set),this._referencesTo.get(t).add(e)}removeReferencesFrom(e){const r=this._referencesFrom.get(e);if(r){for(let t of r)this._referencesTo.get(t).delete(e);this._referencesFrom.delete(e)}}cellsDependingOn(e){const r=new Set,t=[e];for(;t.length>0;){const e=t.pop();r.add(e);const n=(this._referencesTo.has(e)?[...this._referencesTo.get(e)].filter((e=>!r.has(e))):[]).filter((e=>!r.has(e)));t.push(...n)}return r}}class Environment{constructor(e,r,t){this.cells=e,this.functions=r,this.onCellsChanged=t,this._parser=new Parser(new Tokenizer),this._evaluator=new Evaluator,this._expressionsCache=new Map,this._valuesCache=new Map,this._errorsCache=new Map,this._referencesMap=new ReferencesMap}getText(e){return this.cells.has(e)?this.cells.get(e).toString():""}setText(e,r){this.cells.set(e,r);const t=this._referencesMap.cellsDependingOn(e);for(let e of t)this._valuesCache.delete(e),this._errorsCache.delete(e);this._expressionsCache.delete(e),this._referencesMap.removeReferencesFrom(e),this.onCellsChanged([...t])}getExpression(e){if(this._expressionsCache.has(e))return this._expressionsCache.get(e);if(this._errorsCache.has(e))throw this._errorsCache.get(e);const r=this.cells.has(e)?this.cells.get(e):null;try{const{parsed:t,references:n}=this._parser.parse(r);return this._expressionsCache.set(e,t),this._referencesMap.addReferences(e,n),t}catch(r){throw r instanceof ParsingError&&this._errorsCache.set(e,r),r}}getValue(e){if(this._valuesCache.has(e))return this._valuesCache.get(e);if(this._errorsCache.has(e))throw this._errorsCache.get(e);try{const r=this._evaluator.evaluateCellAt(e,this.getExpression(e),this);return this._valuesCache.set(e,r),r}catch(r){throw r instanceof RuntimeError&&this._errorsCache.set(e,r),r}}evaluateQuery(e){const{parsed:r,_:t}=this._parser.parse(e);return this._evaluator.evaluateQuery(r,this)}getFunction(e){if(!this.functions.has(e))throw new UnknownFunctionError(e);return this.functions.get(e)}}exports.CircularReferenceError=CircularReferenceError,exports.FunctionEvaluationError=FunctionEvaluationError,exports.Helpers=a,exports.NotImplementedError=NotImplementedError,exports.ParsingError=ParsingError,exports.RangeReferenceNotAllowedError=RangeReferenceNotAllowedError,exports.ReferencedCellError=ReferencedCellError,exports.RuntimeError=RuntimeError,exports.Spreadsheet=class Spreadsheet{constructor(e=new Map,r=new Map,t=(()=>{})){this.cells=e instanceof Map?e:new Map(Object.entries(e)),this.functions=r instanceof Map?r:new Map(Object.entries(r)),this._environment=new Environment(this.cells,this.functions,t)}text(e){return this._environment.getText(e)}set(e,r){this._environment.setText(e,r)}value(e){return this._environment.getValue(e)}query(e){return this._environment.evaluateQuery(e)}},exports.SpreadsheetError=SpreadsheetError,exports.UnknownFunctionError=UnknownFunctionError;
//# sourceMappingURL=simple-spreadsheet.min.js.map
