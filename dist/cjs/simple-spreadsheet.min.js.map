{"version":3,"file":"simple-spreadsheet.min.js","sources":["../../src/spreadsheet/errors.js","../../src/spreadsheet/tokenStream.js","../../src/spreadsheet/tokenizer.js","../../src/spreadsheet/expressions.js","../../src/spreadsheet/helpers.js","../../src/spreadsheet/parser.js","../../src/spreadsheet/evaluator.js","../../src/spreadsheet/referencesMap.js","../../src/spreadsheet/environment.js","../../src/spreadsheet/spreadsheet.js"],"sourcesContent":["export class NotImplementedError extends Error {\n    constructor(message) { super(message); }\n    toString() { return `Not implemented: ${this.message}` }\n}\n\nexport class SpreadsheetError extends Error { }\n\nexport class ParsingError extends SpreadsheetError {\n    constructor(message) { super(message); }\n    toString() { return `Syntax error: ${this.message}`; }\n}\n\nexport class RuntimeError extends SpreadsheetError {\n    constructor(message) { super(message); }\n    toString() { return `Evaluation error: ${this.message}`; }\n}\n\nexport class ReferencedCellError extends RuntimeError {\n    constructor(cell) {\n        super(`Error in referenced cell: ${cell}`);\n        this.cell = cell;\n    }\n}\n\nexport class CircularReferenceError extends RuntimeError {\n    constructor(cells) {\n        super(`Circular reference detected: ${cells.join(' -> ')}`);\n        this.cells = cells;\n    }\n}\n\nexport class FunctionEvaluationError extends RuntimeError {\n    constructor(functionName, error) {\n        super(`Error in function ${functionName}: ${error}`)\n        this.functionName = functionName;\n        this.error = error;\n    }\n}\n\nexport class RangeReferenceNotAllowedError extends RuntimeError {\n    constructor() { super(`Range references are allowed only as references to functions`); }\n}\n","import { ParsingError } from \"./errors\";\n\nexport default class TokenStream {\n    constructor(tokens) {\n        this._tokens = tokens;\n        this._currentPos = 0;\n    }\n\n    peek() {\n        return this._tokens[this._currentPos] || null;\n    }\n\n    expect(...types) {\n        const token = this.peek();\n        if (token !== null && types.includes(token.type)) {\n            this._currentPos++;\n            return token;\n        }\n        return null;\n    }\n\n    require(...types) {\n        const token = this.expect(...types);\n        if (token === null)\n            throw new ParsingError(`Unexpected ${this.peek().type.description}, expected ${types.map(sym => sym.description).join(' or ')}`);\n        return token;\n    }\n}","import { ParsingError } from './errors';\nimport TokenStream from './tokenStream';\n\nexport const TokenType = Object.freeze({\n    // Note: strings must be unique, because they are used for comparison\n    EOF: Symbol('end of formula'),\n    WHITESPACE: Symbol('whitespace'),\n    PLUS: Symbol('+'),\n    MINUS: Symbol('-'),\n    STAR: Symbol('*'),\n    SLASH: Symbol('/'),\n    LPAREN: Symbol('opening parenthesis'),\n    RPAREN: Symbol('closing parenthesis'),\n    COLON: Symbol(':'),\n    EQUALS: Symbol('='),\n    COMMA: Symbol('comma'),\n    NUMBER: Symbol('number'),\n    STRING: Symbol('string'),\n    IDENTIFIER: Symbol('identifier'),\n});\n\nexport class Tokenizer {\n    constructor() {\n        this._rules = [\n            // NUMBER and IDENTIFIER are used the most so keep them at the top (for performance reasons - it makes a difference, I measured it)\n            // Patterns usually start with ^ so they match the start of the remaining\n            // string, not anywhere in the middle.\n            { pattern: /^\\d+(?:\\.\\d+)?/, type: TokenType.NUMBER },\n            { pattern: /^[a-zA-Z]\\w+/, type: TokenType.IDENTIFIER },\n            { pattern: /^\"(?:[^\"\\\\]|\\\\.)*\"/, type: TokenType.STRING },\n            { pattern: /^$/, type: TokenType.EOF },\n        ];\n\n        this._operators = {\n            ' ': TokenType.WHITESPACE,\n            '\\t': TokenType.WHITESPACE,\n            '\\r': TokenType.WHITESPACE,\n            '\\n': TokenType.WHITESPACE,\n            '+': TokenType.PLUS,\n            '-': TokenType.MINUS,\n            '*': TokenType.STAR,\n            '/': TokenType.SLASH,\n            '(': TokenType.LPAREN,\n            ')': TokenType.RPAREN,\n            '=': TokenType.EQUALS,\n            ':': TokenType.COLON,\n            ',': TokenType.COMMA,\n        }\n    }\n\n    tokenize(text) {\n        const tokens = [];\n        let remaining = text;\n        while (remaining.length > 0) {\n            const token = this._nextToken(remaining);\n            tokens.push(token);\n            remaining = remaining.slice(token.value.length);\n        }\n        tokens.push({ type: TokenType.EOF, value: '' });\n        return new TokenStream(tokens.filter(token => token.type !== TokenType.WHITESPACE));\n    }\n\n    _nextToken(text) {\n        const firstChar = text[0];\n        const operator = this._operators[firstChar];\n        if (operator !== undefined) return { type: operator, value: firstChar };\n\n        for (let rule of this._rules) {\n            const match = text.match(rule.pattern);\n            if (match !== null)\n                return { type: rule.type, value: match[0] };\n        }\n        throw new ParsingError(`Unknown token at '${text}'`);\n    }\n}\n","export class Expression { }\n\nexport class Value extends Expression {\n    constructor(value) { super(); this.value = value; }\n    toString() { return this.value.constructor === String ? `\"${this.value}\"` : `${this.value}`; }\n}\n\nexport class Reference extends Expression {\n    // TODO: Maybe refactor to only hold single property?\n    // Normalize position?\n    constructor(col, row) { super(); this.col = col; this.row = row; }\n    toString() { return `${this.col}${this.row}`; }\n}\n\nexport class BinaryOp extends Expression {\n    constructor(left, op, right) { super(); this.left = left; this.op = op; this.right = right; }\n    toString() { return `(${this.left} ${this.op} ${this.right})`; }\n}\n\nexport class UnaryOp extends Expression {\n    constructor(op, value) { super(); this.op = op; this.value = value; }\n    toString() { return `${this.op}${this.value}`; }\n}\n\nexport class FunctionCall extends Expression {\n    constructor(functionName, args) { super(); this.functionName = functionName; this.args = args; }\n    toString() { return `${this.functionName}(${this.args.join(', ')})`; }\n}\n\nexport class Range extends Expression {\n    constructor(from, to) { super(); this.from = from; this.to = to; }\n    toString() { return `${this.from}:${this.to}`; }\n}","export function positionsInRange(from, to) {\n    const positions = [];\n    // TODO: Use flatMap?\n    for (let col of _range(columnIndex(from.col), columnIndex(to.col)))\n        for (let row of _range(from.row, to.row))\n            positions.push({ col: columnLetter(col), row: row });\n    return positions;\n}\n\nfunction _range(from, to) {\n    return from <= to\n        ? Array.from({ length: to - from + 1 }, (_, i) => i + from)\n        : Array.from({ length: from - to + 1 }, (_, i) => from - i);\n}\n\nexport function parsePosition(position) {\n    const positionParts = position.match(/^([A-Za-z]+)(\\d+)$/);\n    return positionParts &&\n        { col: positionParts[1], row: parseInt(positionParts[2]) };\n}\n\nexport function makePosition(col, row) {\n    return `${col}${row}`;\n}\n\nexport function columnIndex(colLetter) {\n    return colLetter.charCodeAt(0) - 65;\n}\n\nexport function columnLetter(colIndex) {\n    return String.fromCharCode(colIndex + 65);\n}","import { TokenType } from './tokenizer';\nimport { ParsingError, NotImplementedError } from './errors';\nimport { Value, Reference, BinaryOp, UnaryOp, Range, FunctionCall } from './expressions';\nimport * as Helpers from './helpers';\n\nexport default class Parser {\n    constructor(tokenizer) {\n        this._tokenizer = tokenizer;\n        this._tokens = null;\n    }\n\n    // cell => empty | '=' expression EOF | number | string\n    parse(text) {\n        const needsParsing = text !== null && text !== undefined && text.constructor === String;\n        if (!needsParsing)\n            return { parsed: new Value(text), references: [] };\n\n        const isFormula = text[0] === '='; // TODO: add test with and without whitespace\n        if (isFormula) {\n            this._tokens = this._tokenizer.tokenize(text);\n            this._tokens.require(TokenType.EQUALS);\n            const parsed = this._parseExpression();\n            this._tokens.require(TokenType.EOF);\n            const references = this._referencesIn(parsed);\n            return { parsed, references };\n        }\n\n        // number\n        if (text.match(/^[+-]?\\d+(?:\\.\\d+)?$/))\n            return { parsed: new Value(parseFloat(text)), references: [] };\n\n        // string\n        return { parsed: new Value(text), references: [] };\n    }\n\n    // expression => term\n    _parseExpression() {\n        return this._parseTerm();\n    }\n\n    // term => factor (('+'|'-') factor)*\n    _parseTerm() {\n        let left = this._parseFactor();\n        let operation;\n        while ((operation = this._tokens.expect(TokenType.PLUS, TokenType.MINUS)) !== null) {\n            left = new BinaryOp(left, operation.value, this._parseFactor());\n        }\n        return left;\n    }\n\n    // factor => unary (('*'|'/') unary)*\n    _parseFactor() {\n        let left = this._parseRange();\n        let operation;\n        while ((operation = this._tokens.expect(TokenType.STAR, TokenType.SLASH)) !== null) {\n            left = new BinaryOp(left, operation.value, this._parseRange());\n        }\n        return left;\n    }\n\n    // range => unary (':' unary)*\n    _parseRange() {\n        // TODO: Make ranges first-class\n        return this._parseUnary();\n    }\n\n    // unary => ('+'|'-') unary | call\n    _parseUnary() {\n        const operation = this._tokens.expect(TokenType.PLUS, TokenType.MINUS);\n        return operation !== null\n            ? new UnaryOp(operation.value, this._parseUnary())\n            : this._parseValue();\n    }\n\n    // value => number | string | rangeReference | reference | parenthesized | functionCall\n    _parseValue() {\n        if (this._tokens.expect(TokenType.LPAREN))\n            return this._finishParenthesized();\n\n        const number = this._tokens.expect(TokenType.NUMBER)\n        if (number !== null)\n            return new Value(parseFloat(number.value));\n\n        const string = this._tokens.expect(TokenType.STRING);\n        if (string !== null)\n            return this._parseString(string);\n\n\n        const identifier = this._tokens.expect(TokenType.IDENTIFIER);\n        if (identifier !== null) {\n            if (this._tokens.expect(TokenType.COLON))\n                return this._finishRangeReference(identifier);\n\n            if (this._tokens.expect(TokenType.LPAREN))\n                return this._finishFunctionCall(identifier);\n\n            return this._parseReference(identifier.value);\n        }\n        throw new ParsingError(`Unexpected ${this._tokens.peek().type.description}, expected an expression or value`)\n    }\n\n    // parenthesized => '(' expression ')'\n    _finishParenthesized() {\n        const contents = this._parseExpression();\n        this._tokens.require(TokenType.RPAREN);\n        return contents;\n    }\n\n    _parseString(string) {\n        const withoutQuotes = string.value.substring(1, string.value.length - 1);\n        const escapedString = withoutQuotes.replace(/\\\\(.)/g, '$1'); // TODO: check escaped characters are escapable\n        return new Value(escapedString);\n    }\n\n    // rangeReference => IDENTIFIER ':' IDENTIFIER\n    _finishRangeReference(start) {\n        // start identifier and : are already parsed\n        const end = this._tokens.require(TokenType.IDENTIFIER);\n        const from = this._parseReference(start.value);\n        const to = this._parseReference(end.value);\n        return new Range(from, to);\n    }\n\n    // functionCall => IDENTIFIER ('(' arguments ')')*\n    _finishFunctionCall(identifier) {\n        // TODO: Test or remove nested function calls such as FOO()()\n        // Or check for function return types at runtime?\n\n        const args = this._parseArguments();\n        this._tokens.expect(TokenType.RPAREN);\n        return new FunctionCall(identifier.value, args);\n    }\n\n    // reference => [A-Za-z]+\\d+\n    _parseReference(reference) {\n        const position = Helpers.parsePosition(reference);\n        if (position === null)\n            throw new ParsingError(`Invalid format of cell reference: ${reference}`);\n        return new Reference(position.col, position.row);\n    }\n\n    // arguments => (expression (',' expression)*)?\n    _parseArguments() {\n        const args = [];\n        while (this._tokens.peek().type !== TokenType.RPAREN) {\n            if (args.length != 0)\n                this._tokens.require(TokenType.COMMA);\n            args.push(this._parseExpression());\n        }\n        return args;\n    }\n\n    _referencesIn(expression) {\n        switch (expression.constructor) {\n            case Value:\n                return [];\n            case Reference:\n                return [Helpers.makePosition(expression.col, expression.row)];\n            case UnaryOp:\n                return this._referencesIn(expression.value);\n            case BinaryOp:\n                return [...this._referencesIn(expression.left), ...this._referencesIn(expression.right)];\n            case FunctionCall:\n                return expression.args.flatMap(arg => this._referencesIn(arg));\n            case Range:\n                return Helpers.positionsInRange(expression.from, expression.to)\n                    .map(pos => Helpers.makePosition(pos.col, pos.row));\n            default:\n                throw new NotImplementedError(`Unknown expression type: ${typeof expression}`);\n        }\n    }\n}","import { Value, Reference, BinaryOp, FunctionCall, Range, UnaryOp } from './expressions';\nimport { RuntimeError, ParsingError, CircularReferenceError, ReferencedCellError, NotImplementedError, RangeReferenceNotAllowedError, FunctionEvaluationError } from './errors';\nimport * as Helpers from './helpers';\n\nclass CircularRefInternal extends Error {\n    constructor(message, position) { super(message); this.position = position; }\n}\n\nexport default class Evaluator {\n    constructor() {\n        this.visitedCellStack = [];\n    }\n\n    evaluateCellAt(position, expression, environment) {\n        if (this.visitedCellStack.includes(position))\n            throw new CircularRefInternal(`Circular reference detected (${this.visitedCellStack.join(' -> ')} -> ${position})`, position);\n\n        this.visitedCellStack.push(position);\n        try {\n            const result = this._evaluateCell(expression, environment);\n            this.visitedCellStack.pop();\n            return result;\n        } catch (ex) {\n            this.visitedCellStack.pop()\n            // Normal errors propagate as usual, but CircularRefInternal is used\n            // only to propagate the exception to the originating cell internally\n            // (so it doesn't get reported just as an error in a referenced cell).\n            // Once the CircularRefInternal reaches back to the originating cell,\n            // we turn it into a normal CircularReferenceError.\n            if (ex instanceof CircularRefInternal && ex.position === position) {\n                throw new CircularReferenceError([...this.visitedCellStack, position]);\n            } else {\n                throw ex;\n            }\n        }\n    }\n\n    evaluateQuery(expression, environment) {\n        return this._evaluateCell(expression, environment);\n    }\n\n    _evaluateCell(expression, environment) {\n        switch (expression.constructor) {\n            case Value:\n                return expression.value;\n            case Reference:\n                return this._evaluateReference(Helpers.makePosition(expression.col, expression.row), environment);\n            case UnaryOp:\n                return this._evaluateUnary(expression.op, expression.value, environment);\n            case BinaryOp:\n                return this._evaluateBinary(expression.left, expression.op, expression.right, environment);\n            case FunctionCall:\n                return this._evaluateFunction(expression.functionName, expression.args, environment);\n            case Range:\n                throw new RangeReferenceNotAllowedError();\n            default:\n                throw new NotImplementedError(`Unknown expression type: ${typeof expression}`);\n        }\n    }\n\n    _evaluateReference(position, environment) {\n        try {\n            return environment.getValue(position);\n        } catch (ex) {\n            if (ex instanceof ParsingError || ex instanceof RuntimeError)\n                throw new ReferencedCellError(position);\n            else throw ex;\n        }\n    }\n\n    _evaluateExpression(value, environment) {\n        switch (value.constructor) {\n            case Range: return this._evaluateRange(value.from, value.to, environment);\n            default: return this._evaluateCell(value, environment);\n        }\n    }\n\n    _evaluateUnary(op, expression, environment) {\n        const value = this._evaluateCell(expression, environment);\n        switch (op) {\n            case '+': return value;\n            case '-': return -value;\n            default: throw new NotImplementedError(`Unknown unary operator: '${op}'`);\n        }\n    }\n\n    _evaluateBinary(left, op, right, environment) {\n        const leftValue = this._evaluateCell(left, environment);\n        const rightValue = this._evaluateCell(right, environment);\n        switch (op) {\n            case '+': return leftValue + rightValue;\n            case '-': return leftValue - rightValue;\n            case '*': return leftValue * rightValue;\n            case '/': return leftValue / rightValue;\n            default: throw new NotImplementedError(`Unknown binary operator: '${op}'`);\n        }\n    }\n\n    _evaluateFunction(functionName, args, environment) {\n        let func = environment.getFunction(functionName);\n        func = func instanceof Function ? { isMacro: false, function: func } : func;\n        return (func.isMacro === true) ?\n            this._evaluateMacro(functionName, func, args, environment) :\n            this._evaluateSpreadsheetFunction(functionName, func, args, environment);\n    }\n\n    _evaluateSpreadsheetFunction(functionName, func, args, environment) {\n        const argumentValues = args.map(arg => this._evaluateExpression(arg, environment));\n        try {\n            return func.function(...argumentValues);\n        } catch (ex) {\n            throw new FunctionEvaluationError(functionName, ex);\n        }\n    }\n\n    _evaluateMacro(macroName, macro, args, environment) {\n        const argsLazyValues = args.map(arg => () => this._evaluateExpression(arg, environment));\n        try {\n            return macro.function(...argsLazyValues);\n        } catch (ex) {\n            throw new FunctionEvaluationError(macroName, ex);\n        }\n    }\n\n    _evaluateRange(from, to, environment) {\n        return Helpers.positionsInRange(from, to)\n            .map(pos => Helpers.makePosition(pos.col, pos.row))\n            .map(pos => this._evaluateReference(pos, environment));\n    }\n}\n","export default class ReferencesMap {\n    constructor() {\n        this._referencesFrom = new Map();\n        this._referencesTo = new Map();\n    }\n\n    addReferences(positionFrom, referencesTo) {\n        if (!this._referencesFrom.has(positionFrom))\n            this._referencesFrom.set(positionFrom, new Set(referencesTo));\n\n        for (let referenceTo of referencesTo) {\n            this._referencesFrom.get(positionFrom).add(referenceTo);\n\n            if (!this._referencesTo.has(referenceTo))\n                this._referencesTo.set(referenceTo, new Set());\n            this._referencesTo.get(referenceTo).add(positionFrom);\n        }\n    }\n\n    removeReferencesFrom(position) {\n        // TODO: test this code works properly\n        const targetNodes = this._referencesFrom.get(position);\n        if (targetNodes) {\n            for (let target of targetNodes)\n                this._referencesTo.get(target).delete(position);\n            this._referencesFrom.delete(position);\n        }\n    }\n\n    cellsDependingOn(position) {\n        const visited = new Set();\n        const toVisitStack = [position];\n        while (toVisitStack.length > 0) {\n            const current = toVisitStack.pop();\n            visited.add(current);\n            const neighbors = this._referencesTo.has(current) ?\n                [...this._referencesTo.get(current)].filter(n => !visited.has(n)) : [];\n            const newNeighbors = neighbors.filter(n => !visited.has(n));\n            toVisitStack.push(...newNeighbors);\n        }\n        return visited;\n    }\n}\n","import { Tokenizer } from './tokenizer';\nimport Parser from './parser';\nimport Evaluator from './evaluator';\nimport { RuntimeError } from './errors';\nimport ReferencesMap from './referencesMap';\n\nexport class Environment {\n    constructor(cells, functions, cellsChangedListener) {\n        this.cells = cells;\n        this.functions = functions;\n        this.onCellsChanged = cellsChangedListener;\n        this._parser = new Parser(new Tokenizer());\n        this._evaluator = new Evaluator();\n\n        this._expressionsCache = new Map(); // { position => expression tree (AST) }\n        this._valuesCache = new Map(); // { position => value; }\n        this._referencesMap = new ReferencesMap();\n    }\n\n    getText(position) {\n        return this.cells.has(position) ? this.cells.get(position).toString() : \"\";\n    }\n\n    setText(position, value) {\n        this.cells.set(position, value);\n\n        const affectedCells = this._referencesMap.cellsDependingOn(position);\n        for (let pos of affectedCells)\n            this._valuesCache.delete(pos);\n\n        this._expressionsCache.delete(position);\n        this._referencesMap.removeReferencesFrom(position);\n\n        this.onCellsChanged([...affectedCells]); // TODO: should this remain a Set?\n    }\n\n    getExpression(position) {\n        if (this._expressionsCache.has(position))\n            return this._expressionsCache.get(position);\n\n        const text = this.cells.has(position) ? this.cells.get(position) : null;\n        const { parsed, references } = this._parser.parse(text);\n        this._expressionsCache.set(position, parsed);\n        this._referencesMap.addReferences(position, references);\n        return parsed;\n    }\n\n    getValue(position) {\n        if (this._valuesCache.has(position))\n            return this._valuesCache.get(position);\n\n        const result = this._evaluator.evaluateCellAt(position, this.getExpression(position), this);\n        this._valuesCache.set(position, result);\n        return result;\n    }\n\n    evaluateQuery(expression) {\n        const { parsed, _ } = this._parser.parse(expression);\n        return this._evaluator.evaluateQuery(parsed, this);\n    }\n\n    getFunction(name) {\n        if (!this.functions.has(name))\n            throw new RuntimeError(`Unknown function: ${name}`);\n        return this.functions.get(name);\n    }\n}","import { Environment } from './environment';\nimport * as Helpers from './helpers';\nexport { Helpers };\nexport { SpreadsheetError, RuntimeError, ParsingError } from './errors';\n\nexport class Spreadsheet {\n    constructor(cells = new Map(), functions = new Map(), onCellsChanged = (() => { })) {\n        this.cells = cells instanceof Map ? cells : new Map(Object.entries(cells));\n        this.functions = functions instanceof Map ? functions : new Map(Object.entries(functions));\n        this._environment = new Environment(this.cells, this.functions, onCellsChanged);\n    }\n\n    text(position) {\n        return this._environment.getText(position);\n    }\n\n    set(position, text) {\n        this._environment.setText(position, text);\n    }\n\n    value(position) {\n        return this._environment.getValue(position);\n    }\n\n    query(expression) {\n        return this._environment.evaluateQuery(expression);\n    }\n}"],"names":["NotImplementedError","Error","[object Object]","message","super","this","SpreadsheetError","ParsingError","RuntimeError","ReferencedCellError","cell","CircularReferenceError","cells","join","FunctionEvaluationError","functionName","error","RangeReferenceNotAllowedError","TokenStream","tokens","_tokens","_currentPos","types","token","peek","includes","type","expect","description","map","sym","TokenType","Object","freeze","EOF","Symbol","WHITESPACE","PLUS","MINUS","STAR","SLASH","LPAREN","RPAREN","COLON","EQUALS","COMMA","NUMBER","STRING","IDENTIFIER","Tokenizer","_rules","pattern","_operators"," ","\t","\r","\n","+","-","*","/","(",")","=",":",",","text","remaining","length","_nextToken","push","slice","value","filter","firstChar","operator","undefined","rule","match","Expression","Value","constructor","String","Reference","col","row","BinaryOp","left","op","right","UnaryOp","FunctionCall","args","Range","from","to","positionsInRange","positions","_range","columnIndex","columnLetter","Array","_","i","parsePosition","position","positionParts","parseInt","makePosition","colLetter","charCodeAt","colIndex","fromCharCode","Parser","tokenizer","_tokenizer","parsed","references","tokenize","require","_parseExpression","_referencesIn","parseFloat","_parseTerm","operation","_parseFactor","_parseRange","_parseUnary","_parseValue","_finishParenthesized","number","string","_parseString","identifier","_finishRangeReference","_finishFunctionCall","_parseReference","contents","escapedString","substring","replace","start","end","_parseArguments","reference","Helpers.parsePosition","expression","Helpers.makePosition","flatMap","arg","Helpers.positionsInRange","pos","CircularRefInternal","Evaluator","visitedCellStack","environment","result","_evaluateCell","pop","ex","_evaluateReference","_evaluateUnary","_evaluateBinary","_evaluateFunction","getValue","_evaluateRange","leftValue","rightValue","func","getFunction","Function","isMacro","function","_evaluateMacro","_evaluateSpreadsheetFunction","argumentValues","_evaluateExpression","macroName","macro","argsLazyValues","ReferencesMap","_referencesFrom","Map","_referencesTo","positionFrom","referencesTo","has","set","Set","referenceTo","get","add","targetNodes","target","delete","visited","toVisitStack","current","newNeighbors","n","Environment","functions","cellsChangedListener","onCellsChanged","_parser","_evaluator","_expressionsCache","_valuesCache","_referencesMap","toString","affectedCells","cellsDependingOn","removeReferencesFrom","parse","addReferences","evaluateCellAt","getExpression","evaluateQuery","name","Spreadsheet","entries","_environment","getText","setText"],"mappings":"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"}