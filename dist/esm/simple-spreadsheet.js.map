{"version":3,"file":"simple-spreadsheet.js","sources":["../../src/spreadsheet/errors.js","../../src/spreadsheet/tokenStream.js","../../src/spreadsheet/tokenizer.js","../../src/spreadsheet/expressions.js","../../src/spreadsheet/helpers.js","../../src/spreadsheet/parser.js","../../src/spreadsheet/evaluator.js","../../src/spreadsheet/referencesMap.js","../../src/spreadsheet/environment.js","../../src/spreadsheet/spreadsheet.js"],"sourcesContent":["export class NotImplementedError extends Error {\r\n    constructor(message) { super(message); }\r\n    toString() { return `Not implemented: ${this.message}` }\r\n}\r\n\r\nexport class SpreadsheetError extends Error { }\r\n\r\nexport class ParsingError extends SpreadsheetError {\r\n    constructor(message) { super(message); }\r\n    toString() { return `Syntax error: ${this.message}`; }\r\n}\r\n\r\nexport class RuntimeError extends SpreadsheetError {\r\n    constructor(message) { super(message); }\r\n    toString() { return `Evaluation error: ${this.message}`; }\r\n}\r\n\r\nexport class ReferencedCellError extends RuntimeError {\r\n    constructor(cell) {\r\n        super(`Error in referenced cell: ${cell}`);\r\n        this.cell = cell;\r\n    }\r\n}\r\n\r\nexport class CircularReferenceError extends RuntimeError {\r\n    constructor(cells) {\r\n        super(`Circular reference detected: ${cells.join(' -> ')}`);\r\n        this.cells = cells;\r\n    }\r\n}\r\n\r\nexport class FunctionEvaluationError extends RuntimeError {\r\n    constructor(functionName, error) {\r\n        super(`Error in function ${functionName}: ${error}`)\r\n        this.functionName = functionName;\r\n        this.error = error;\r\n    }\r\n}\r\n\r\nexport class RangeReferenceNotAllowedError extends RuntimeError {\r\n    constructor() { super(`Range references are allowed only as references to functions`); }\r\n}\r\n\r\nexport class UnknownFunctionError extends RuntimeError {\r\n    constructor(functionName) {\r\n        super(`Unknown function: ${functionName}`);\r\n        this.functionName = functionName;\r\n    }\r\n}","import { ParsingError } from \"./errors\";\r\n\r\nexport default class TokenStream {\r\n    constructor(tokens) {\r\n        this._tokens = tokens;\r\n        this._currentPos = 0;\r\n    }\r\n\r\n    peek() {\r\n        return this._tokens[this._currentPos] || null;\r\n    }\r\n\r\n    expect(...types) {\r\n        const token = this.peek();\r\n        if (token !== null && types.includes(token.type)) {\r\n            this._currentPos++;\r\n            return token;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    require(...types) {\r\n        const token = this.expect(...types);\r\n        if (token === null)\r\n            throw new ParsingError(`Unexpected ${this.peek().type.description}, expected ${types.map(sym => sym.description).join(' or ')}`);\r\n        return token;\r\n    }\r\n}","import { ParsingError } from './errors';\r\nimport TokenStream from './tokenStream';\r\n\r\nexport const TokenType = Object.freeze({\r\n    // Note: strings must be unique, because they are used for comparison\r\n    EOF: Symbol('end of formula'),\r\n    WHITESPACE: Symbol('whitespace'),\r\n    PLUS: Symbol('+'),\r\n    MINUS: Symbol('-'),\r\n    STAR: Symbol('*'),\r\n    SLASH: Symbol('/'),\r\n    LPAREN: Symbol('opening parenthesis'),\r\n    RPAREN: Symbol('closing parenthesis'),\r\n    COLON: Symbol(':'),\r\n    EQUALS: Symbol('='),\r\n    COMMA: Symbol('comma'),\r\n    NUMBER: Symbol('number'),\r\n    STRING: Symbol('string'),\r\n    IDENTIFIER: Symbol('identifier'),\r\n});\r\n\r\nexport class Tokenizer {\r\n    constructor() {\r\n        this._rules = [\r\n            // NUMBER and IDENTIFIER are used the most so keep them at the top (for performance reasons - it makes a difference, I measured it)\r\n            // Patterns usually start with ^ so they match the start of the remaining\r\n            // string, not anywhere in the middle.\r\n            { pattern: /^\\d+(?:\\.\\d+)?/, type: TokenType.NUMBER },\r\n            { pattern: /^[a-zA-Z]\\w+/, type: TokenType.IDENTIFIER },\r\n            { pattern: /^\"(?:[^\"\\\\]|\\\\.)*\"/, type: TokenType.STRING },\r\n            { pattern: /^$/, type: TokenType.EOF },\r\n        ];\r\n\r\n        this._operators = {\r\n            ' ': TokenType.WHITESPACE,\r\n            '\\t': TokenType.WHITESPACE,\r\n            '\\r': TokenType.WHITESPACE,\r\n            '\\n': TokenType.WHITESPACE,\r\n            '+': TokenType.PLUS,\r\n            '-': TokenType.MINUS,\r\n            '*': TokenType.STAR,\r\n            '/': TokenType.SLASH,\r\n            '(': TokenType.LPAREN,\r\n            ')': TokenType.RPAREN,\r\n            '=': TokenType.EQUALS,\r\n            ':': TokenType.COLON,\r\n            ',': TokenType.COMMA,\r\n        }\r\n    }\r\n\r\n    tokenize(text) {\r\n        const tokens = [];\r\n        let remaining = text;\r\n        while (remaining.length > 0) {\r\n            const token = this._nextToken(remaining);\r\n            tokens.push(token);\r\n            remaining = remaining.slice(token.value.length);\r\n        }\r\n        tokens.push({ type: TokenType.EOF, value: '' });\r\n        return new TokenStream(tokens.filter(token => token.type !== TokenType.WHITESPACE));\r\n    }\r\n\r\n    _nextToken(text) {\r\n        const firstChar = text[0];\r\n        const operator = this._operators[firstChar];\r\n        if (operator !== undefined) return { type: operator, value: firstChar };\r\n\r\n        for (let rule of this._rules) {\r\n            const match = text.match(rule.pattern);\r\n            if (match !== null)\r\n                return { type: rule.type, value: match[0] };\r\n        }\r\n        throw new ParsingError(`Unknown token at '${text}'`);\r\n    }\r\n}\r\n","export class Expression { }\r\n\r\nexport class Value extends Expression {\r\n    constructor(value) { super(); this.value = value; }\r\n    toString() { return this.value.constructor === String ? `\"${this.value}\"` : `${this.value}`; }\r\n}\r\n\r\nexport class Reference extends Expression {\r\n    // TODO: Maybe refactor to only hold single property?\r\n    // Normalize position?\r\n    constructor(col, row) { super(); this.col = col; this.row = row; }\r\n    toString() { return `${this.col}${this.row}`; }\r\n}\r\n\r\nexport class BinaryOp extends Expression {\r\n    constructor(left, op, right) { super(); this.left = left; this.op = op; this.right = right; }\r\n    toString() { return `(${this.left} ${this.op} ${this.right})`; }\r\n}\r\n\r\nexport class UnaryOp extends Expression {\r\n    constructor(op, value) { super(); this.op = op; this.value = value; }\r\n    toString() { return `${this.op}${this.value}`; }\r\n}\r\n\r\nexport class FunctionCall extends Expression {\r\n    constructor(functionName, args) { super(); this.functionName = functionName; this.args = args; }\r\n    toString() { return `${this.functionName}(${this.args.join(', ')})`; }\r\n}\r\n\r\nexport class Range extends Expression {\r\n    constructor(from, to) { super(); this.from = from; this.to = to; }\r\n    toString() { return `${this.from}:${this.to}`; }\r\n}","export function positionsInRange(from, to) {\r\n    const positions = [];\r\n    // TODO: Use flatMap?\r\n    for (let col of _range(columnIndex(from.col), columnIndex(to.col)))\r\n        for (let row of _range(from.row, to.row))\r\n            positions.push({ col: columnLetter(col), row: row });\r\n    return positions;\r\n}\r\n\r\nfunction _range(from, to) {\r\n    return from <= to\r\n        ? Array.from({ length: to - from + 1 }, (_, i) => i + from)\r\n        : Array.from({ length: from - to + 1 }, (_, i) => from - i);\r\n}\r\n\r\nexport function parsePosition(position) {\r\n    const positionParts = position.match(/^([A-Za-z]+)(\\d+)$/);\r\n    return positionParts &&\r\n        { col: positionParts[1], row: parseInt(positionParts[2]) };\r\n}\r\n\r\nexport function makePosition(col, row) {\r\n    return `${col}${row}`;\r\n}\r\n\r\nexport function columnIndex(colLetter) {\r\n    return colLetter.charCodeAt(0) - 65;\r\n}\r\n\r\nexport function columnLetter(colIndex) {\r\n    return String.fromCharCode(colIndex + 65);\r\n}","import { TokenType } from './tokenizer';\r\nimport { ParsingError, NotImplementedError } from './errors';\r\nimport { Value, Reference, BinaryOp, UnaryOp, Range, FunctionCall } from './expressions';\r\nimport * as Helpers from './helpers';\r\n\r\nexport default class Parser {\r\n    constructor(tokenizer) {\r\n        this._tokenizer = tokenizer;\r\n        this._tokens = null;\r\n    }\r\n\r\n    // cell => empty | '=' expression EOF | number | string\r\n    parse(text) {\r\n        const needsParsing = text !== null && text !== undefined && text.constructor === String;\r\n        if (!needsParsing)\r\n            return { parsed: new Value(text), references: [] };\r\n\r\n        const isFormula = text[0] === '='; // TODO: add test with and without whitespace\r\n        if (isFormula) {\r\n            this._tokens = this._tokenizer.tokenize(text);\r\n            this._tokens.require(TokenType.EQUALS);\r\n            const parsed = this._parseExpression();\r\n            this._tokens.require(TokenType.EOF);\r\n            const references = this._referencesIn(parsed);\r\n            return { parsed, references };\r\n        }\r\n\r\n        // number\r\n        if (text.match(/^[+-]?\\d+(?:\\.\\d+)?$/))\r\n            return { parsed: new Value(parseFloat(text)), references: [] };\r\n\r\n        // string\r\n        return { parsed: new Value(text), references: [] };\r\n    }\r\n\r\n    // expression => term\r\n    _parseExpression() {\r\n        return this._parseTerm();\r\n    }\r\n\r\n    // term => factor (('+'|'-') factor)*\r\n    _parseTerm() {\r\n        let left = this._parseFactor();\r\n        let operation;\r\n        while ((operation = this._tokens.expect(TokenType.PLUS, TokenType.MINUS)) !== null) {\r\n            left = new BinaryOp(left, operation.value, this._parseFactor());\r\n        }\r\n        return left;\r\n    }\r\n\r\n    // factor => unary (('*'|'/') unary)*\r\n    _parseFactor() {\r\n        let left = this._parseRange();\r\n        let operation;\r\n        while ((operation = this._tokens.expect(TokenType.STAR, TokenType.SLASH)) !== null) {\r\n            left = new BinaryOp(left, operation.value, this._parseRange());\r\n        }\r\n        return left;\r\n    }\r\n\r\n    // range => unary (':' unary)*\r\n    _parseRange() {\r\n        // TODO: Make ranges first-class\r\n        return this._parseUnary();\r\n    }\r\n\r\n    // unary => ('+'|'-') unary | call\r\n    _parseUnary() {\r\n        const operation = this._tokens.expect(TokenType.PLUS, TokenType.MINUS);\r\n        return operation !== null\r\n            ? new UnaryOp(operation.value, this._parseUnary())\r\n            : this._parseValue();\r\n    }\r\n\r\n    // value => number | string | rangeReference | reference | parenthesized | functionCall\r\n    _parseValue() {\r\n        if (this._tokens.expect(TokenType.LPAREN))\r\n            return this._finishParenthesized();\r\n\r\n        const number = this._tokens.expect(TokenType.NUMBER)\r\n        if (number !== null)\r\n            return new Value(parseFloat(number.value));\r\n\r\n        const string = this._tokens.expect(TokenType.STRING);\r\n        if (string !== null)\r\n            return this._parseString(string);\r\n\r\n\r\n        const identifier = this._tokens.expect(TokenType.IDENTIFIER);\r\n        if (identifier !== null) {\r\n            if (this._tokens.expect(TokenType.COLON))\r\n                return this._finishRangeReference(identifier);\r\n\r\n            if (this._tokens.expect(TokenType.LPAREN))\r\n                return this._finishFunctionCall(identifier);\r\n\r\n            return this._parseReference(identifier.value);\r\n        }\r\n        throw new ParsingError(`Unexpected ${this._tokens.peek().type.description}, expected an expression or value`)\r\n    }\r\n\r\n    // parenthesized => '(' expression ')'\r\n    _finishParenthesized() {\r\n        const contents = this._parseExpression();\r\n        this._tokens.require(TokenType.RPAREN);\r\n        return contents;\r\n    }\r\n\r\n    _parseString(string) {\r\n        const withoutQuotes = string.value.substring(1, string.value.length - 1);\r\n        const escapedString = withoutQuotes.replace(/\\\\(.)/g, '$1'); // TODO: check escaped characters are escapable\r\n        return new Value(escapedString);\r\n    }\r\n\r\n    // rangeReference => IDENTIFIER ':' IDENTIFIER\r\n    _finishRangeReference(start) {\r\n        // start identifier and : are already parsed\r\n        const end = this._tokens.require(TokenType.IDENTIFIER);\r\n        const from = this._parseReference(start.value);\r\n        const to = this._parseReference(end.value);\r\n        return new Range(from, to);\r\n    }\r\n\r\n    // functionCall => IDENTIFIER ('(' arguments ')')*\r\n    _finishFunctionCall(identifier) {\r\n        // TODO: Test or remove nested function calls such as FOO()()\r\n        // Or check for function return types at runtime?\r\n\r\n        const args = this._parseArguments();\r\n        this._tokens.expect(TokenType.RPAREN);\r\n        return new FunctionCall(identifier.value, args);\r\n    }\r\n\r\n    // reference => [A-Za-z]+\\d+\r\n    _parseReference(reference) {\r\n        const position = Helpers.parsePosition(reference);\r\n        if (position === null)\r\n            throw new ParsingError(`Invalid format of cell reference: ${reference}`);\r\n        return new Reference(position.col, position.row);\r\n    }\r\n\r\n    // arguments => (expression (',' expression)*)?\r\n    _parseArguments() {\r\n        const args = [];\r\n        while (this._tokens.peek().type !== TokenType.RPAREN) {\r\n            if (args.length != 0)\r\n                this._tokens.require(TokenType.COMMA);\r\n            args.push(this._parseExpression());\r\n        }\r\n        return args;\r\n    }\r\n\r\n    _referencesIn(expression) {\r\n        switch (expression.constructor) {\r\n            case Value:\r\n                return [];\r\n            case Reference:\r\n                return [Helpers.makePosition(expression.col, expression.row)];\r\n            case UnaryOp:\r\n                return this._referencesIn(expression.value);\r\n            case BinaryOp:\r\n                return [...this._referencesIn(expression.left), ...this._referencesIn(expression.right)];\r\n            case FunctionCall:\r\n                return expression.args.flatMap(arg => this._referencesIn(arg));\r\n            case Range:\r\n                return Helpers.positionsInRange(expression.from, expression.to)\r\n                    .map(pos => Helpers.makePosition(pos.col, pos.row));\r\n            default:\r\n                throw new NotImplementedError(`Unknown expression type: ${typeof expression}`);\r\n        }\r\n    }\r\n}","import { Value, Reference, BinaryOp, FunctionCall, Range, UnaryOp } from './expressions';\r\nimport { RuntimeError, ParsingError, CircularReferenceError, ReferencedCellError, NotImplementedError, RangeReferenceNotAllowedError, FunctionEvaluationError } from './errors';\r\nimport * as Helpers from './helpers';\r\n\r\nclass CircularRefInternal extends Error {\r\n    constructor(position, circlePositions) { super(); this.position = position; this.circlePositions = circlePositions; }\r\n}\r\n\r\nexport default class Evaluator {\r\n    constructor() {\r\n        this.visitedCellStack = [];\r\n    }\r\n\r\n    evaluateCellAt(position, expression, environment) {\r\n        if (this.visitedCellStack.includes(position))\r\n            throw new CircularRefInternal(position, [...this.visitedCellStack, position]);\r\n\r\n        this.visitedCellStack.push(position);\r\n        try {\r\n            const result = this._evaluateCell(expression, environment);\r\n            this.visitedCellStack.pop();\r\n            return result;\r\n        } catch (ex) {\r\n            this.visitedCellStack.pop()\r\n            // Normal errors propagate as usual, but CircularRefInternal is used\r\n            // only to propagate the exception to the originating cell internally\r\n            // (so it doesn't get reported just as an error in a referenced cell).\r\n            // Once the CircularRefInternal reaches back to the originating cell,\r\n            // we turn it into a normal CircularReferenceError.\r\n            if (ex instanceof CircularRefInternal && ex.position === position) {\r\n                throw new CircularReferenceError(ex.circlePositions);\r\n            } else {\r\n                throw ex;\r\n            }\r\n        }\r\n    }\r\n\r\n    evaluateQuery(expression, environment) {\r\n        return this._evaluateCell(expression, environment);\r\n    }\r\n\r\n    _evaluateCell(expression, environment) {\r\n        switch (expression.constructor) {\r\n            case Value:\r\n                return expression.value;\r\n            case Reference:\r\n                return this._evaluateReference(Helpers.makePosition(expression.col, expression.row), environment);\r\n            case UnaryOp:\r\n                return this._evaluateUnary(expression.op, expression.value, environment);\r\n            case BinaryOp:\r\n                return this._evaluateBinary(expression.left, expression.op, expression.right, environment);\r\n            case FunctionCall:\r\n                return this._evaluateFunction(expression.functionName, expression.args, environment);\r\n            case Range:\r\n                throw new RangeReferenceNotAllowedError();\r\n            default:\r\n                throw new NotImplementedError(`Unknown expression type: ${typeof expression}`);\r\n        }\r\n    }\r\n\r\n    _evaluateReference(position, environment) {\r\n        try {\r\n            return environment.getValue(position);\r\n        } catch (ex) {\r\n            if (ex instanceof ParsingError || ex instanceof RuntimeError)\r\n                throw new ReferencedCellError(position);\r\n            else throw ex;\r\n        }\r\n    }\r\n\r\n    _evaluateExpression(value, environment) {\r\n        switch (value.constructor) {\r\n            case Range: return this._evaluateRange(value.from, value.to, environment);\r\n            default: return this._evaluateCell(value, environment);\r\n        }\r\n    }\r\n\r\n    _evaluateUnary(op, expression, environment) {\r\n        const value = this._evaluateCell(expression, environment);\r\n        switch (op) {\r\n            case '+': return value;\r\n            case '-': return -value;\r\n            default: throw new NotImplementedError(`Unknown unary operator: '${op}'`);\r\n        }\r\n    }\r\n\r\n    _evaluateBinary(left, op, right, environment) {\r\n        const leftValue = this._evaluateCell(left, environment);\r\n        const rightValue = this._evaluateCell(right, environment);\r\n        switch (op) {\r\n            case '+': return leftValue + rightValue;\r\n            case '-': return leftValue - rightValue;\r\n            case '*': return leftValue * rightValue;\r\n            case '/': return leftValue / rightValue;\r\n            default: throw new NotImplementedError(`Unknown binary operator: '${op}'`);\r\n        }\r\n    }\r\n\r\n    _evaluateFunction(functionName, args, environment) {\r\n        let func = environment.getFunction(functionName);\r\n        func = func instanceof Function ? { isMacro: false, function: func } : func;\r\n        return (func.isMacro === true) ?\r\n            this._evaluateMacro(functionName, func, args, environment) :\r\n            this._evaluateSpreadsheetFunction(functionName, func, args, environment);\r\n    }\r\n\r\n    _evaluateSpreadsheetFunction(functionName, func, args, environment) {\r\n        const argumentValues = args.map(arg => this._evaluateExpression(arg, environment));\r\n        try {\r\n            return func.function(...argumentValues);\r\n        } catch (ex) {\r\n            throw new FunctionEvaluationError(functionName, ex);\r\n        }\r\n    }\r\n\r\n    _evaluateMacro(macroName, macro, args, environment) {\r\n        const argsLazyValues = args.map(arg => () => this._evaluateExpression(arg, environment));\r\n        try {\r\n            return macro.function(...argsLazyValues);\r\n        } catch (ex) {\r\n            throw new FunctionEvaluationError(macroName, ex);\r\n        }\r\n    }\r\n\r\n    _evaluateRange(from, to, environment) {\r\n        return Helpers.positionsInRange(from, to)\r\n            .map(pos => Helpers.makePosition(pos.col, pos.row))\r\n            .map(pos => this._evaluateReference(pos, environment));\r\n    }\r\n}\r\n","export default class ReferencesMap {\r\n    constructor() {\r\n        this._referencesFrom = new Map(); // { position => Set(referencesFrom) }\r\n        this._referencesTo = new Map(); // { position => Set(referencedBy) }\r\n    }\r\n\r\n    addReferences(positionFrom, referencesTo) {\r\n        if (!this._referencesFrom.has(positionFrom))\r\n            this._referencesFrom.set(positionFrom, new Set(referencesTo));\r\n\r\n        for (let referenceTo of referencesTo) {\r\n            this._referencesFrom.get(positionFrom).add(referenceTo);\r\n\r\n            if (!this._referencesTo.has(referenceTo))\r\n                this._referencesTo.set(referenceTo, new Set());\r\n            this._referencesTo.get(referenceTo).add(positionFrom);\r\n        }\r\n    }\r\n\r\n    removeReferencesFrom(position) {\r\n        // TODO: test this code works properly\r\n        const targetNodes = this._referencesFrom.get(position);\r\n        if (targetNodes) {\r\n            for (let target of targetNodes)\r\n                this._referencesTo.get(target).delete(position);\r\n            this._referencesFrom.delete(position);\r\n        }\r\n    }\r\n\r\n    cellsDependingOn(position) {\r\n        const visited = new Set();\r\n        const toVisitStack = [position];\r\n        while (toVisitStack.length > 0) {\r\n            const current = toVisitStack.pop();\r\n            visited.add(current);\r\n            const neighbors = this._referencesTo.has(current) ?\r\n                [...this._referencesTo.get(current)].filter(n => !visited.has(n)) : [];\r\n            const newNeighbors = neighbors.filter(n => !visited.has(n));\r\n            toVisitStack.push(...newNeighbors);\r\n        }\r\n        return visited;\r\n    }\r\n}\r\n","import { Tokenizer } from './tokenizer';\r\nimport Parser from './parser';\r\nimport Evaluator from './evaluator';\r\nimport { UnknownFunctionError, RuntimeError, ParsingError } from './errors';\r\nimport ReferencesMap from './referencesMap';\r\n\r\nexport class Environment {\r\n    constructor(cells, functions, cellsChangedListener) {\r\n        this.cells = cells; // { position => formula text }\r\n        this.functions = functions; // { name => function or macro }\r\n        this.onCellsChanged = cellsChangedListener;\r\n        this._parser = new Parser(new Tokenizer());\r\n        this._evaluator = new Evaluator();\r\n\r\n        this._expressionsCache = new Map(); // { position => expression tree (AST) }\r\n        this._valuesCache = new Map(); // { position => value; }\r\n        this._errorsCache = new Map(); // { position => error; }\r\n        this._referencesMap = new ReferencesMap(); // tracks references between cells\r\n    }\r\n\r\n    getText(position) {\r\n        return this.cells.has(position) ? this.cells.get(position).toString() : \"\";\r\n    }\r\n\r\n    setText(position, text) {\r\n        this.cells.set(position, text);\r\n\r\n        // affectedCells also contains `position`\r\n        const affectedCells = this._referencesMap.cellsDependingOn(position);\r\n        for (let pos of affectedCells) {\r\n            this._valuesCache.delete(pos);\r\n            this._errorsCache.delete(pos);\r\n        }\r\n\r\n        this._expressionsCache.delete(position);\r\n        this._referencesMap.removeReferencesFrom(position);\r\n\r\n        this.onCellsChanged([...affectedCells]); // TODO: should this remain a Set?\r\n    }\r\n\r\n    getExpression(position) {\r\n        if (this._expressionsCache.has(position))\r\n            return this._expressionsCache.get(position);\r\n\r\n        if (this._errorsCache.has(position))\r\n            throw this._errorsCache.get(position);\r\n\r\n        const text = this.cells.has(position) ? this.cells.get(position) : null;\r\n        try {\r\n            const { parsed, references } = this._parser.parse(text);\r\n            this._expressionsCache.set(position, parsed);\r\n            this._referencesMap.addReferences(position, references);\r\n            return parsed;\r\n        } catch (ex) {\r\n            if (ex instanceof ParsingError)\r\n                this._errorsCache.set(position, ex);\r\n            throw ex;\r\n        }\r\n    }\r\n\r\n    getValue(position) {\r\n        if (this._valuesCache.has(position))\r\n            return this._valuesCache.get(position);\r\n\r\n        if (this._errorsCache.has(position))\r\n            throw this._errorsCache.get(position);\r\n\r\n        try {\r\n            const result = this._evaluator.evaluateCellAt(position, this.getExpression(position), this);\r\n            this._valuesCache.set(position, result);\r\n            return result;\r\n        } catch (ex) {\r\n            if (ex instanceof RuntimeError)\r\n                this._errorsCache.set(position, ex);\r\n            throw ex;\r\n        }\r\n    }\r\n\r\n    evaluateQuery(expression) {\r\n        const { parsed, _ } = this._parser.parse(expression);\r\n        return this._evaluator.evaluateQuery(parsed, this);\r\n    }\r\n\r\n    getFunction(name) {\r\n        if (!this.functions.has(name))\r\n            throw new UnknownFunctionError(name);\r\n        return this.functions.get(name);\r\n    }\r\n}","import { Environment } from './environment';\r\nimport * as Helpers from './helpers';\r\nexport { Helpers };\r\nexport * from './errors';\r\n\r\nexport class Spreadsheet {\r\n    constructor(cells = new Map(), functions = new Map(), onCellsChanged = (() => { })) {\r\n        this.cells = cells instanceof Map ? cells : new Map(Object.entries(cells));\r\n        this.functions = functions instanceof Map ? functions : new Map(Object.entries(functions));\r\n        this._environment = new Environment(this.cells, this.functions, onCellsChanged);\r\n    }\r\n\r\n    text(position) {\r\n        return this._environment.getText(position);\r\n    }\r\n\r\n    set(position, text) {\r\n        this._environment.setText(position, text);\r\n    }\r\n\r\n    value(position) {\r\n        return this._environment.getValue(position);\r\n    }\r\n\r\n    query(expression) {\r\n        return this._environment.evaluateQuery(expression);\r\n    }\r\n}"],"names":["Helpers.parsePosition","Helpers.makePosition","Helpers.positionsInRange"],"mappings":"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"}