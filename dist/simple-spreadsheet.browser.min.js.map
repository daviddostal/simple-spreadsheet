{"version":3,"file":"simple-spreadsheet.browser.min.js","sources":["../src/errors.js","../src/tokenStream.js","../src/tokenizer.js","../src/expressions.js","../src/helpers.js","../src/parser.js","../src/evaluator.js","../src/referencesMap.js","../src/environment.js","../src/builtinValues.js","../src/spreadsheet.js"],"sourcesContent":["export class SpreadsheetError extends Error { }\n\nexport class ParsingError extends SpreadsheetError {\n    constructor(message) { super(message); }\n    toString() { return `Syntax error: ${this.message}`; }\n}\n\nexport class RuntimeError extends SpreadsheetError {\n    constructor(message) { super(message); }\n    toString() { return `Evaluation error: ${this.message}`; }\n}\n","import { ParsingError } from \"./errors\";\n\nexport default class TokenStream {\n    constructor(tokens) {\n        this._tokens = tokens;\n        this._currentPos = 0;\n    }\n\n    peek() {\n        return this._tokens[this._currentPos] || null;\n    }\n\n    expect(...types) {\n        const token = this.peek();\n        if (token !== null && types.includes(token.type)) {\n            this._currentPos++;\n            return token;\n        }\n        return null;\n    }\n\n    require(...types) {\n        const token = this.expect(...types);\n        if (token === null)\n            throw new ParsingError(`Expected ${types.join(' or ')}, got ${this.peek().type} instead.`);\n        return token;\n    }\n}","import { ParsingError } from './errors';\nimport TokenStream from './tokenStream';\n\nexport const TokenType = Object.freeze({\n    EOF: 'EOF',\n    WHITESPACE: 'WHITESPACE',\n    PLUS: 'PLUS',\n    MINUS: 'MINUS',\n    STAR: 'STAR',\n    SLASH: 'SLASH',\n    LPAREN: 'LPAREN',\n    RPAREN: 'RPAREN',\n    COLON: 'COLON',\n    EQUALS: 'EQUALS',\n    COMMA: 'COMMA',\n    NUMBER: 'NUMBER',\n    STRING: 'STRING',\n    REFERENCE: 'REFERENCE',\n    IDENTIFIER: 'IDENTIFIER',\n});\n\nexport class Tokenizer {\n    constructor() {\n        this._rules = {\n            // NUMBER, REFERENCE and IDENTIFIER are used the most so keep them at the top\n            '\\\\d+(?:\\\\.\\\\d+)?': TokenType.NUMBER,\n            '[A-Za-z]+\\\\d+': TokenType.REFERENCE,\n            '[a-zA-Z]\\\\w+': TokenType.IDENTIFIER,\n            '\\\\s+': TokenType.WHITESPACE,\n            '\\\\+': TokenType.PLUS,\n            '-': TokenType.MINUS,\n            '\\\\*': TokenType.STAR,\n            '\\\\/': TokenType.SLASH,\n            '\\\\(': TokenType.LPAREN,\n            '\\\\)': TokenType.RPAREN,\n            '=': TokenType.EQUALS,\n            ':': TokenType.COLON,\n            ',': TokenType.COMMA,\n            '\\\\\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\\\\\"': TokenType.STRING,\n            '$': TokenType.EOF,\n        };\n    }\n\n    tokenize(text) {\n        const tokens = [];\n        let remaining = text;\n        while (remaining.length > 0) {\n            const token = this._nextToken(remaining);\n            tokens.push(token);\n            remaining = remaining.slice(token.value.length);\n        }\n        tokens.push({ type: TokenType.EOF, value: '' });\n        return new TokenStream(tokens.filter(token => token.type !== TokenType.WHITESPACE));\n    }\n\n    _nextToken(text) {\n        for (let rule in this._rules) {\n            const match = text.match(new RegExp('^' + rule));\n            if (match !== null)\n                return { type: this._rules[rule], value: match[0] };\n        }\n        throw new ParsingError(`Unknown token at '${text}'`);\n    }\n}\n","export class Expression { }\n\nexport class Value extends Expression {\n    constructor(value) { super(); this.value = value; }\n    toString() { return this.value.constructor === String ? `\"${this.value}\"` : `${this.value}`; }\n}\n\nexport class CellReference extends Expression {\n    constructor(position) { super(); this.position = position }\n    toString() { return `CellReference(${this.position})`; }\n}\n\nexport class Reference extends Expression {\n    constructor(name) { super(); this.name = name }\n    toString() { return `Reference(${this.name})`; }\n}\n\nexport class BinaryOp extends Expression {\n    constructor(left, op, right) { super(); this.left = left; this.op = op; this.right = right; }\n    toString() { return `BinaryOp(${this.left} ${this.op} ${this.right})`; }\n}\n\nexport class UnaryOp extends Expression {\n    constructor(op, value) { super(); this.op = op; this.value = value; }\n    toString() { return `UnaryOp(${this.op} ${this.value})`; }\n}\n\nexport class FunctionCall extends Expression {\n    constructor(functionValue, args) { super(); this.functionValue = functionValue; this.args = args; }\n    toString() { return `FunctionCall(${this.functionValue}, ${this.args.join(', ')})`; }\n}\n\nexport class Range extends Expression {\n    constructor(from, to) { super(); this.from = from; this.to = to; }\n    toString() { return `Range(${this.from}, ${this.to})`; }\n}","export function positionsInRange(from, to) {\n    const positions = [];\n    const fromPos = parsePosition(from);\n    const toPos = parsePosition(to);\n    for (let col of _range(columnIndex(fromPos.col), columnIndex(toPos.col)))\n        for (let row of _range(fromPos.row, toPos.row))\n            positions.push({ col: columnLetter(col), row: row });\n    return positions;\n}\n\nfunction _range(from, to) {\n    return from <= to\n        ? Array.from({ length: to - from + 1 }, (_, i) => i + from)\n        : Array.from({ length: from - to + 1 }, (_, i) => from - i);\n}\n\nexport function parseRange(range) {\n    const [from, to] = range.split(':');\n    return { from: parsePosition(from), to: parsePosition(to) };\n}\n\nexport function makeRange(from, to) {\n    return `${from}:${to}`;\n}\n\nexport function parsePosition(position) {\n    const positionParts = position.match(/^([A-Za-z]+)(\\d+)$/);\n    return positionParts === null ? null :\n        { col: positionParts[1], row: parseInt(positionParts[2]) };\n}\n\nexport function makePosition(col, row) {\n    return `${col}${row}`;\n}\n\nexport function columnIndex(colLetter) {\n    return colLetter.charCodeAt(0) - 65;\n}\n\nexport function columnLetter(colIndex) {\n    return String.fromCharCode(colIndex + 65);\n}","import { TokenType } from './tokenizer';\nimport { ParsingError } from './errors';\nimport { Value, CellReference, BinaryOp, UnaryOp, Range, FunctionCall, Reference } from './expressions';\nimport * as Helpers from './helpers';\n\nexport default class Parser {\n    constructor(tokenizer) {\n        this._tokenizer = tokenizer;\n        this._tokens = null;\n    }\n\n    // cell => empty | '=' expression EOF | number | string\n    parse(text) {\n        // empty cell or other value\n        if (text === null || text === undefined || text.constructor !== String)\n            return { parsed: new Value(text), references: [] };\n\n        // formula\n        if (text.trimStart().startsWith('=')) {\n            this._tokens = this._tokenizer.tokenize(text);\n            this._tokens.require(TokenType.EQUALS);\n            const parsed = this._parseExpression();\n            this._tokens.require(TokenType.EOF);\n            const references = [...new Set(this._getCellReferences(parsed))];\n            return { parsed, references };\n        }\n\n        // number\n        if (text.match(/^[+-]?\\d+(?:\\.\\d+)?$/))\n            return { parsed: new Value(parseFloat(text)), references: [] };\n\n        // string\n        return { parsed: new Value(text), references: [] };\n    }\n\n    // expression => term\n    _parseExpression() {\n        return this._parseTerm();\n    }\n\n    // term => factor (('+'|'-') factor)*\n    _parseTerm() {\n        let left = this._parseFactor();\n        let operation;\n        while ((operation = this._tokens.expect(TokenType.PLUS, TokenType.MINUS)) !== null) {\n            left = new BinaryOp(left, operation.value, this._parseFactor());\n        }\n        return left;\n    }\n\n    // factor => unary (('*'|'/') unary)*\n    _parseFactor() {\n        let left = this._parseRange();\n        let operation;\n        while ((operation = this._tokens.expect(TokenType.STAR, TokenType.SLASH)) !== null) {\n            left = new BinaryOp(left, operation.value, this._parseRange());\n        }\n        return left;\n    }\n\n    // range => unary (':' unary)*\n    _parseRange() {\n        // TODO: Make ranges first-class\n        return this._parseUnary();\n    }\n\n    // unary => ('+'|'-') unary | call\n    _parseUnary() {\n        const operation = this._tokens.expect(TokenType.PLUS, TokenType.MINUS);\n        return operation !== null\n            ? new UnaryOp(operation.value, this._parseUnary())\n            : this._parseCall();\n    }\n\n    // call => value ('(' arguments ')')*\n    _parseCall() {\n        let value = this._parseValue();\n        while (this._tokens.expect(TokenType.LPAREN)) {\n            const args = this._parseArguments();\n            this._tokens.expect(TokenType.RPAREN);\n            value = new FunctionCall(value, args);\n        }\n        return value;\n    }\n\n    // value => number | string | rangeReference | reference | parenthesized\n    _parseValue() {\n        const number = this._tokens.expect(TokenType.NUMBER)\n        if (number !== null)\n            return this._parseNumber(number);\n\n        const string = this._tokens.expect(TokenType.STRING);\n        if (string !== null)\n            return this._parseString(string);\n\n        const reference = this._tokens.expect(TokenType.REFERENCE);\n        if (reference != null && this._tokens.expect(TokenType.COLON))\n            return this._parseRangeReference(reference);\n        else if (reference != null)\n            return this._parseCellReference(reference);\n\n        const identifier = this._tokens.expect(TokenType.IDENTIFIER);\n        if (identifier !== null)\n            return new Reference(identifier.value);\n\n        if (this._tokens.expect(TokenType.LPAREN))\n            return this._parseParenthesized();\n\n        throw new ParsingError(`Unexpected ${this._tokens.peek().type}, expected an expression or value`)\n    }\n\n    // parenthesized => '(' expression ')'\n    _parseParenthesized() {\n        // ( is already parsed by parseValue\n        const contents = this._parseExpression();\n        this._tokens.require(TokenType.RPAREN);\n        return contents;\n    }\n\n    _parseNumber(number) {\n        return new Value(parseFloat(number.value));\n    }\n\n    _parseString(string) {\n        const withoutQuotes = string.value.substring(1, string.value.length - 1);\n        const escapedString = withoutQuotes.replace(/\\\\(.)/g, '$1');\n        return new Value(escapedString);\n    }\n\n    // rangeReference => IDENTIFIER ':' IDENTIFIER\n    _parseRangeReference(fromReference) {\n        // start identifier and : are already parsed\n        const toReference = this._tokens.require(TokenType.REFERENCE);\n        const from = new CellReference(fromReference.value);\n        const to = new CellReference(toReference.value);\n        return new Range(from, to);\n    }\n\n    _parseCellReference(reference) {\n        // TODO: make nicer, maybe drop helper functions altogether.\n        const parsedPos = Helpers.parsePosition(reference.value);\n        const position = Helpers.makePosition(parsedPos.col, parsedPos.row);\n        return new CellReference(position);\n    }\n\n    // arguments => (expression (',' expression)*)?\n    _parseArguments() {\n        const args = [];\n        while (this._tokens.peek().type !== TokenType.RPAREN) {\n            if (args.length != 0)\n                this._tokens.require(TokenType.COMMA);\n            args.push(this._parseExpression());\n        }\n        return args;\n    }\n\n    _expectAny(...types) {\n        const current = this._next();\n        if (types.includes(current.type)) {\n            this.tokens.next();\n            return current;\n        } else {\n            return null;\n        }\n    }\n\n    _require(type) {\n        const next = this._expectAny(type);\n        if (next === null)\n            throw new ParsingError(`Expected ${type}, got ${this.tokens.peek().type} instead`);\n        else\n            return next;\n    }\n\n    _next() {\n        let current = this.tokens.peek();\n        while (current.type === TokenType.WHITESPACE) {\n            this.tokens.next();\n            current = this.tokens.peek();\n        }\n        return current;\n    }\n\n    _getCellReferences(expression) {\n        switch (expression.constructor) {\n            case Value:\n                return [];\n            case CellReference:\n                return [expression.position];\n            case Reference:\n                return [];\n            case UnaryOp:\n                return this._getCellReferences(expression.value);\n            case BinaryOp:\n                return [...this._getCellReferences(expression.left), ...this._getCellReferences(expression.right)];\n            case FunctionCall:\n                return expression.args.flatMap(arg => this._getCellReferences(arg));\n            case Range:\n                return Helpers.positionsInRange(expression.from.position, expression.to.position)\n                    .map(pos => Helpers.makePosition(pos.col, pos.row));\n            default:\n                throw new ParsingError(`Unknown expression type: ${typeof expression}`);\n        }\n    }\n}","import { Value, Reference, BinaryOp, FunctionCall, Range, UnaryOp, CellReference } from './expressions';\nimport { RuntimeError, ParsingError } from './errors';\nimport * as Helpers from './helpers';\n\nexport default class Evaluator {\n    constructor() {\n        this.visitedCellStack = [];\n    }\n\n    evaluateCellAt(position, cell, environment) {\n        if (this.visitedCellStack.includes(position))\n            throw new RuntimeError(`Circular reference detected (${this.visitedCellStack.join(' -> ')} -> ${position})`);\n\n        this.visitedCellStack.push(position);\n        const result = this._evaluateCell(cell, environment);\n        this.visitedCellStack.pop();\n        return result;\n    }\n\n    evaluateQuery(cell, environment) {\n        return this._evaluateCell(cell, environment);\n    }\n\n    _evaluateCell(cell, environment) {\n        switch (cell.constructor) {\n            case Value:\n                return cell.value;\n            case CellReference:\n                return this._evaluateCellReference(cell.position, environment);\n            case Reference:\n                return this._evaluateReference(cell.name, environment);\n            case UnaryOp:\n                return this._evaluateUnary(cell.op, cell.value, environment);\n            case BinaryOp:\n                return this._evaluateBinary(cell.left, cell.op, cell.right, environment);\n            case FunctionCall:\n                return this._evaluateFunction(cell.functionValue, cell.args, environment);\n            case Range:\n                throw new RuntimeError(`Range references are allowed only as arguments of functions`);\n            default:\n                throw new RuntimeError(`Unknown expression type: ${typeof cell}`);\n        }\n    }\n\n    _evaluateCellReference(position, environment) {\n        try {\n            return environment.getValue(position);\n        } catch (e) {\n            if (e instanceof ParsingError)\n                throw new RuntimeError(`Error in referenced cell: ${position}`);\n            else throw e;\n        }\n    }\n\n    _evaluateReference(identifier, environment) {\n        try {\n            return environment.getGlobal(identifier);\n        } catch (e) {\n            if (e instanceof ParsingError)\n                throw new RuntimeError(`Error in referenced value: ${identifier}`);\n            else throw e;\n        }\n    }\n\n    _evaluateExpression(value, environment) {\n        switch (value.constructor) {\n            case Range: return this._evaluateRange(value.from, value.to, environment);\n            default: return this._evaluateCell(value, environment);\n        }\n    }\n\n    _evaluateUnary(op, expression, environment) {\n        const value = this._evaluateCell(expression, environment);\n        switch (op) {\n            case '+': return value;\n            case '-': return -value;\n            default: throw new RuntimeError(`Unknown unary operator: '${op}'`);\n        }\n    }\n\n    _evaluateBinary(left, op, right, environment) {\n        const leftValue = this._evaluateCell(left, environment);\n        const rightValue = this._evaluateCell(right, environment);\n        switch (op) {\n            case '+': return leftValue + rightValue;\n            case '-': return leftValue - rightValue;\n            case '*': return leftValue * rightValue;\n            case '/': return leftValue / rightValue;\n            default: throw new RuntimeError(`Unknown binary operator: '${op}'`);\n        }\n    }\n\n    _evaluateFunction(functionValue, args, environment) {\n        const func = this._evaluateCell(functionValue, environment);\n        if (typeof func !== 'function')\n            throw new RuntimeError(`'${functionValue}' is called like a function, but is not a function.`);\n        const argumentValues = args.map(arg => this._evaluateExpression(arg, environment));\n        try {\n            return func(...argumentValues);\n        } catch (ex) {\n            throw new RuntimeError(`Error in function ${functionValue}: ${ex}`);\n        }\n    }\n\n    _evaluateRange(from, to, environment) {\n        return Helpers.positionsInRange(from.position, to.position)\n            .map(pos => Helpers.makePosition(pos.col, pos.row))\n            .map(pos => this._evaluateCellReference(pos, environment));\n    }\n}","export default class ReferencesMap {\n    constructor() {\n        this._referencesFrom = {};\n        this._referencesTo = {};\n    }\n\n    getReferencesFrom(position) { return this._referencesFrom[position]; }\n    getReferencesTo(position) { return this._referencesTo[position]; }\n\n    addReference(positionFrom, referenceTo) {\n        if (!this._referencesFrom[positionFrom])\n            this._referencesFrom[positionFrom] = [];\n        this._referencesFrom[positionFrom].push(referenceTo);\n\n        if (!this._referencesTo[referenceTo])\n            this._referencesTo[referenceTo] = [];\n        this._referencesTo[referenceTo].push(positionFrom);\n    }\n\n    removeReferencesFrom(position) {\n        const targetNodes = this._referencesFrom[position];\n        for (let target of targetNodes) {\n            const valueIndex = this._referencesTo[target].indexOf(position);\n            if (valueIndex > -1) this._referencesTo[target].splice(valueIndex, 1);\n        }\n        delete this._referencesFrom[position];\n    }\n\n    getAffectedCells(position) {\n        // TODO: maybe optimize using stack and for loop\n        const referencesTo = this.getReferencesTo(position);\n        if (!referencesTo) return [];\n\n        const recursiveReferences = referencesTo.flatMap(this.getAffectedCells.bind(this));\n        return [...referencesTo, ...recursiveReferences];\n    }\n}","import { Tokenizer } from './tokenizer';\nimport Parser from './parser';\nimport Evaluator from './evaluator';\nimport { RuntimeError } from './errors';\nimport ReferencesMap from './referencesMap';\n\nexport class Environment {\n    constructor(cells = {}, globals = {}, cellsChangedListener = (() => { })) {\n        this.cells = cells;\n        this.globals = globals;\n        this.cellsChangedListener = cellsChangedListener;\n        this._parser = new Parser(new Tokenizer());\n        this._evaluator = new Evaluator();\n\n        this._expressionsCache = {}; // position => expression tree\n        this._valuesCache = {}; // position => value;\n        this._referencesMap = new ReferencesMap();\n    }\n\n    getText(position) {\n        return this.cells.hasOwnProperty(position) ? this.cells[position].toString() : \"\";\n    }\n\n    setText(position, value) {\n        this.cells[position] = value;\n\n        const affectedCells = [position, ...this._referencesMap.getAffectedCells(position)];\n        for (let pos of affectedCells)\n            delete this._valuesCache[pos];\n\n        delete this._expressionsCache[position];\n        if (this._referencesMap.getReferencesFrom(position))\n            this._referencesMap.removeReferencesFrom(position);\n\n        this.cellsChangedListener(affectedCells);\n    }\n\n    getExpression(position) {\n        if (this._expressionsCache.hasOwnProperty(position))\n            return this._expressionsCache[position];\n\n        const text = this.cells.hasOwnProperty(position) ? this.cells[position] : null;\n        const { parsed, references } = this._parser.parse(text);\n        this._expressionsCache[position] = parsed;\n\n        for (let reference of references)\n            this._referencesMap.addReference(position, reference);\n\n        return parsed;\n    }\n\n    getValue(position) {\n        if (this._valuesCache.hasOwnProperty(position))\n            return this._valuesCache[position];\n\n        const result = this._evaluator.evaluateCellAt(position, this.getExpression(position), this);\n        this._valuesCache[position] = result;\n        return result;\n    }\n\n    evaluateQuery(expression) {\n        const { parsed, _ } = this._parser.parse(expression);\n        return this._evaluator.evaluateQuery(parsed, this);\n    }\n\n    getGlobal(name) {\n        if (this.globals[name] === undefined)\n            throw new RuntimeError(`Unknown global value: ${name}`);\n        return this.globals[name];\n    }\n};","export const builtinValues = {\n    SUM: (...args) => {\n        let sum = 0;\n        for (let arg of args.flat()) {\n            if (typeof (arg) === 'number')\n                sum += arg;\n            else if (!(arg === null || arg === undefined))\n                throw new Error(`${typeof (arg)} is not a valid argument to SUM(). Expected number, number[], null or undefined.`);\n        }\n        return sum;\n    },\n\n    AVERAGE: (...args) => {\n        let sum = 0;\n        let count = 0;\n        for (let arg of args.flat()) {\n            if (typeof (arg) === 'number') {\n                sum += arg;\n                count++;\n            } else if (!(arg === null || arg === undefined)) {\n                throw new Error(`${typeof (arg)} is not a valid argument to AVERAGE().`);\n            }\n        }\n        return sum / count;\n    },\n};","import { Environment } from './environment';\nimport { builtinValues } from './builtinValues';\nimport * as Helpers from './helpers';\nexport { Helpers };\nexport { SpreadsheetError, RuntimeError, ParsingError } from './errors';\nexport { builtinValues };\n\nexport class Spreadsheet {\n    constructor(cells = {}, globals = builtinValues, cellsChangedListener) {\n        this.cells = cells;\n        this._environment = new Environment(this.cells, globals, cellsChangedListener);\n    }\n\n    text(position) {\n        return this._environment.getText(position);\n    }\n\n    set(position, text) {\n        this._environment.setText(position, text);\n    }\n\n    value(position) {\n        return this._environment.getValue(position);\n    }\n\n    query(expression) {\n        return this._environment.evaluateQuery(expression);\n    }\n}"],"names":["SpreadsheetError","Error","ParsingError","[object Object]","message","super","this","RuntimeError","TokenStream","tokens","_tokens","_currentPos","types","token","peek","includes","type","expect","join","TokenType","Object","freeze","EOF","WHITESPACE","PLUS","MINUS","STAR","SLASH","LPAREN","RPAREN","COLON","EQUALS","COMMA","NUMBER","STRING","REFERENCE","IDENTIFIER","Tokenizer","_rules","\\d+(?:\\.\\d+)?","[A-Za-z]+\\d+","[a-zA-Z]\\w+","\\s+","\\+","-","\\*","\\/","\\(","\\)","=",":",",","\\\"(?:[^\"\\\\]|\\\\.)*\\\"","$","text","remaining","length","_nextToken","push","slice","value","filter","rule","match","RegExp","Expression","Value","constructor","String","CellReference","position","Reference","name","BinaryOp","left","op","right","UnaryOp","FunctionCall","functionValue","args","Range","from","to","positionsInRange","positions","fromPos","parsePosition","toPos","col","_range","columnIndex","row","columnLetter","Array","_","i","positionParts","parseInt","makePosition","colLetter","charCodeAt","colIndex","fromCharCode","range","split","Parser","tokenizer","_tokenizer","parsed","references","trimStart","startsWith","tokenize","require","_parseExpression","Set","_getCellReferences","parseFloat","_parseTerm","operation","_parseFactor","_parseRange","_parseUnary","_parseCall","_parseValue","_parseArguments","number","_parseNumber","string","_parseString","reference","_parseRangeReference","_parseCellReference","identifier","_parseParenthesized","contents","escapedString","substring","replace","fromReference","toReference","parsedPos","Helpers.parsePosition","Helpers.makePosition","current","_next","next","_expectAny","expression","flatMap","arg","Helpers.positionsInRange","map","pos","Evaluator","visitedCellStack","cell","environment","result","_evaluateCell","pop","_evaluateCellReference","_evaluateReference","_evaluateUnary","_evaluateBinary","_evaluateFunction","getValue","e","getGlobal","_evaluateRange","leftValue","rightValue","func","argumentValues","_evaluateExpression","ex","ReferencesMap","_referencesFrom","_referencesTo","positionFrom","referenceTo","targetNodes","target","valueIndex","indexOf","splice","referencesTo","getReferencesTo","recursiveReferences","getAffectedCells","bind","Environment","cells","globals","cellsChangedListener","_parser","_evaluator","_expressionsCache","_valuesCache","_referencesMap","hasOwnProperty","toString","affectedCells","getReferencesFrom","removeReferencesFrom","parse","addReference","evaluateCellAt","getExpression","evaluateQuery","undefined","builtinValues","SUM","sum","flat","AVERAGE","count","Spreadsheet","_environment","getText","setText"],"mappings":"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"}