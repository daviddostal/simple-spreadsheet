class SpreadsheetError extends Error{}class ParsingError extends SpreadsheetError{constructor(e){super(e)}toString(){return`Syntax error: ${this.message}`}}class RuntimeError extends SpreadsheetError{constructor(e){super(e)}toString(){return`Evaluation error: ${this.message}`}}class TokenStream{constructor(e){this._tokens=e,this._currentPos=0}peek(){return this._tokens[this._currentPos]||null}expect(...e){const r=this.peek();return null!==r&&e.includes(r.type)?(this._currentPos++,r):null}require(...e){const r=this.expect(...e);if(null===r)throw new ParsingError(`Expected ${e.join(" or ")}, got ${this.peek().type} instead.`);return r}}const e=Object.freeze({EOF:"EOF",WHITESPACE:"WHITESPACE",PLUS:"PLUS",MINUS:"MINUS",STAR:"STAR",SLASH:"SLASH",LPAREN:"LPAREN",RPAREN:"RPAREN",COLON:"COLON",EQUALS:"EQUALS",COMMA:"COMMA",NUMBER:"NUMBER",STRING:"STRING",REFERENCE:"REFERENCE",IDENTIFIER:"IDENTIFIER"});class Tokenizer{constructor(){this._rules={"\\d+(?:\\.\\d+)?":e.NUMBER,"[A-Za-z]+\\d+":e.REFERENCE,"[a-zA-Z]\\w+":e.IDENTIFIER,"\\s+":e.WHITESPACE,"\\+":e.PLUS,"-":e.MINUS,"\\*":e.STAR,"\\/":e.SLASH,"\\(":e.LPAREN,"\\)":e.RPAREN,"=":e.EQUALS,":":e.COLON,",":e.COMMA,'\\"(?:[^"\\\\]|\\\\.)*\\"':e.STRING,$:e.EOF}}tokenize(r){const t=[];let s=r;for(;s.length>0;){const e=this._nextToken(s);t.push(e),s=s.slice(e.value.length)}return t.push({type:e.EOF,value:""}),new TokenStream(t.filter(r=>r.type!==e.WHITESPACE))}_nextToken(e){for(let r in this._rules){const t=e.match(new RegExp("^"+r));if(null!==t)return{type:this._rules[r],value:t[0]}}throw new ParsingError(`Unknown token at '${e}'`)}}class Expression{}class Value extends Expression{constructor(e){super(),this.value=e}toString(){return this.value.constructor===String?`"${this.value}"`:`${this.value}`}}class CellReference extends Expression{constructor(e){super(),this.position=e}toString(){return`CellReference(${this.position})`}}class Reference extends Expression{constructor(e){super(),this.name=e}toString(){return`Reference(${this.name})`}}class BinaryOp extends Expression{constructor(e,r,t){super(),this.left=e,this.op=r,this.right=t}toString(){return`BinaryOp(${this.left} ${this.op} ${this.right})`}}class UnaryOp extends Expression{constructor(e,r){super(),this.op=e,this.value=r}toString(){return`UnaryOp(${this.op} ${this.value})`}}class FunctionCall extends Expression{constructor(e,r){super(),this.functionValue=e,this.args=r}toString(){return`FunctionCall(${this.functionValue}, [${this.args.join(", ")}])`}}class Range extends Expression{constructor(e,r){super(),this.from=e,this.to=r}toString(){return`Range(${this.from}, ${this.to})`}}function r(e,r){const n=[],a=s(e),l=s(r);for(let e of t(o(a.col),o(l.col)))for(let r of t(a.row,l.row))n.push({col:i(e),row:r});return n}function t(e,r){return e<=r?Array.from({length:r-e+1},(r,t)=>t+e):Array.from({length:e-r+1},(r,t)=>e-t)}function s(e){const r=e.match(/^([A-Za-z]+)(\d+)$/);return null===r?null:{col:r[1],row:parseInt(r[2])}}function n(e,r){return`${e}${r}`}function o(e){return e.charCodeAt(0)-65}function i(e){return String.fromCharCode(e+65)}var a=Object.freeze({positionsInRange:r,parsePosition:s,makePosition:n,columnIndex:o,columnLetter:i});class Parser{constructor(e){this._tokenizer=e,this._tokens=null}parse(r){if(null==r||r.constructor!==String)return{parsed:new Value(r),references:[]};if(r.trimStart().startsWith("=")){this._tokens=this._tokenizer.tokenize(r),this._tokens.require(e.EQUALS);const t=this._parseExpression();return this._tokens.require(e.EOF),{parsed:t,references:[...new Set(this._getCellReferences(t))]}}return r.match(/^[+-]?\d+(?:\.\d+)?$/)?{parsed:new Value(parseFloat(r)),references:[]}:{parsed:new Value(r),references:[]}}_parseExpression(){return this._parseTerm()}_parseTerm(){let r,t=this._parseFactor();for(;null!==(r=this._tokens.expect(e.PLUS,e.MINUS));)t=new BinaryOp(t,r.value,this._parseFactor());return t}_parseFactor(){let r,t=this._parseRange();for(;null!==(r=this._tokens.expect(e.STAR,e.SLASH));)t=new BinaryOp(t,r.value,this._parseRange());return t}_parseRange(){return this._parseUnary()}_parseUnary(){const r=this._tokens.expect(e.PLUS,e.MINUS);return null!==r?new UnaryOp(r.value,this._parseUnary()):this._parseCall()}_parseCall(){let r=this._parseValue();for(;this._tokens.expect(e.LPAREN);){const t=this._parseArguments();this._tokens.expect(e.RPAREN),r=new FunctionCall(r,t)}return r}_parseValue(){const r=this._tokens.expect(e.NUMBER);if(null!==r)return this._parseNumber(r);const t=this._tokens.expect(e.STRING);if(null!==t)return this._parseString(t);const s=this._tokens.expect(e.REFERENCE);if(null!=s&&this._tokens.expect(e.COLON))return this._finishRangeReference(s);if(null!=s)return this._parseCellReference(s);const n=this._tokens.expect(e.IDENTIFIER);if(null!==n)return new Reference(n.value);if(this._tokens.expect(e.LPAREN))return this._finishParenthesized();throw new ParsingError(`Unexpected ${this._tokens.peek().type}, expected an expression or value`)}_finishParenthesized(){const r=this._parseExpression();return this._tokens.require(e.RPAREN),r}_parseNumber(e){return new Value(parseFloat(e.value))}_parseString(e){const r=e.value.substring(1,e.value.length-1).replace(/\\(.)/g,"$1");return new Value(r)}_finishRangeReference(r){const t=this._tokens.require(e.REFERENCE),s=new CellReference(r.value),n=new CellReference(t.value);return new Range(s,n)}_parseCellReference(e){const r=s(e.value),t=n(r.col,r.row);return new CellReference(t)}_parseArguments(){const r=[];for(;this._tokens.peek().type!==e.RPAREN;)0!=r.length&&this._tokens.require(e.COMMA),r.push(this._parseExpression());return r}_getCellReferences(e){switch(e.constructor){case Value:return[];case CellReference:return[e.position];case Reference:return[];case UnaryOp:return this._getCellReferences(e.value);case BinaryOp:return[...this._getCellReferences(e.left),...this._getCellReferences(e.right)];case FunctionCall:return e.args.flatMap(e=>this._getCellReferences(e));case Range:return r(e.from.position,e.to.position).map(e=>n(e.col,e.row));default:throw new ParsingError(`Unknown expression type: ${typeof e}`)}}}class Evaluator{constructor(){this.visitedCellStack=[]}evaluateCellAt(e,r,t){if(this.visitedCellStack.includes(e))throw new RuntimeError(`Circular reference detected (${this.visitedCellStack.join(" -> ")} -> ${e})`);this.visitedCellStack.push(e);const s=this._evaluateCell(r,t);return this.visitedCellStack.pop(),s}evaluateQuery(e,r){return this._evaluateCell(e,r)}_evaluateCell(e,r){switch(e.constructor){case Value:return e.value;case CellReference:return this._evaluateCellReference(e.position,r);case Reference:return this._evaluateReference(e.name,r);case UnaryOp:return this._evaluateUnary(e.op,e.value,r);case BinaryOp:return this._evaluateBinary(e.left,e.op,e.right,r);case FunctionCall:return this._evaluateFunction(e.functionValue,e.args,r);case Range:throw new RuntimeError("Range references are allowed only as arguments of functions");default:throw new RuntimeError(`Unknown expression type: ${typeof e}`)}}_evaluateCellReference(e,r){try{return r.getValue(e)}catch(r){throw r instanceof ParsingError?new RuntimeError(`Error in referenced cell: ${e}`):r}}_evaluateReference(e,r){try{return r.getGlobal(e)}catch(r){throw r instanceof ParsingError?new RuntimeError(`Error in referenced value: ${e}`):r}}_evaluateExpression(e,r){switch(e.constructor){case Range:return this._evaluateRange(e.from,e.to,r);default:return this._evaluateCell(e,r)}}_evaluateUnary(e,r,t){const s=this._evaluateCell(r,t);switch(e){case"+":return s;case"-":return-s;default:throw new RuntimeError(`Unknown unary operator: '${e}'`)}}_evaluateBinary(e,r,t,s){const n=this._evaluateCell(e,s),o=this._evaluateCell(t,s);switch(r){case"+":return n+o;case"-":return n-o;case"*":return n*o;case"/":return n/o;default:throw new RuntimeError(`Unknown binary operator: '${r}'`)}}_evaluateFunction(e,r,t){const s=this._evaluateCell(e,t);if("function"!=typeof s)throw new RuntimeError(`'${e}' is called like a function, but is not a function.`);const n=r.map(e=>this._evaluateExpression(e,t));try{return s(...n)}catch(r){throw new RuntimeError(`Error in function ${e}: ${r}`)}}_evaluateRange(e,t,s){return r(e.position,t.position).map(e=>n(e.col,e.row)).map(e=>this._evaluateCellReference(e,s))}}class ReferencesMap{constructor(){this._referencesFrom={},this._referencesTo={}}getReferencesFrom(e){return this._referencesFrom[e]}getReferencesTo(e){return this._referencesTo[e]}addReference(e,r){this._referencesFrom[e]||(this._referencesFrom[e]=[]),this._referencesFrom[e].push(r),this._referencesTo[r]||(this._referencesTo[r]=[]),this._referencesTo[r].push(e)}removeReferencesFrom(e){const r=this._referencesFrom[e];for(let t of r){const r=this._referencesTo[t].indexOf(e);r>-1&&this._referencesTo[t].splice(r,1)}delete this._referencesFrom[e]}getAffectedCells(e){const r=this.getReferencesTo(e);if(!r)return[];const t=r.flatMap(this.getAffectedCells.bind(this));return[...r,...t]}}class Environment{constructor(e={},r={},t=(()=>{})){this.cells=e,this.globals=r,this.cellsChangedListener=t,this._parser=new Parser(new Tokenizer),this._evaluator=new Evaluator,this._expressionsCache={},this._valuesCache={},this._referencesMap=new ReferencesMap}getText(e){return this.cells.hasOwnProperty(e)?this.cells[e].toString():""}setText(e,r){this.cells[e]=r;const t=[e,...this._referencesMap.getAffectedCells(e)];for(let e of t)delete this._valuesCache[e];delete this._expressionsCache[e],this._referencesMap.getReferencesFrom(e)&&this._referencesMap.removeReferencesFrom(e),this.cellsChangedListener(t)}getExpression(e){if(this._expressionsCache.hasOwnProperty(e))return this._expressionsCache[e];const r=this.cells.hasOwnProperty(e)?this.cells[e]:null,{parsed:t,references:s}=this._parser.parse(r);this._expressionsCache[e]=t;for(let r of s)this._referencesMap.addReference(e,r);return t}getValue(e){if(this._valuesCache.hasOwnProperty(e))return this._valuesCache[e];const r=this._evaluator.evaluateCellAt(e,this.getExpression(e),this);return this._valuesCache[e]=r,r}evaluateQuery(e){const{parsed:r,_:t}=this._parser.parse(e);return this._evaluator.evaluateQuery(r,this)}getGlobal(e){if(void 0===this.globals[e])throw new RuntimeError(`Unknown global value: ${e}`);return this.globals[e]}}const l={SUM:(...e)=>{let r=0;for(let t of e.flat())if("number"==typeof t)r+=t;else if(null!=t)throw new Error(`${typeof t} is not a valid argument to SUM(). Expected number, number[], null or undefined.`);return r},AVERAGE:(...e)=>{let r=0,t=0;for(let s of e.flat())if("number"==typeof s)r+=s,t++;else if(null!=s)throw new Error(`${typeof s} is not a valid argument to AVERAGE().`);return r/t}};class Spreadsheet{constructor(e={},r=l,t){this.cells=e,this._environment=new Environment(this.cells,r,t)}text(e){return this._environment.getText(e)}set(e,r){this._environment.setText(e,r)}value(e){return this._environment.getValue(e)}query(e){return this._environment.evaluateQuery(e)}}export{a as Helpers,ParsingError,RuntimeError,Spreadsheet,SpreadsheetError,l as builtinValues};
//# sourceMappingURL=simple-spreadsheet.min.mjs.map
