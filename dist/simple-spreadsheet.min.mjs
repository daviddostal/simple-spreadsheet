class SpreadsheetError extends Error{}class ParsingError extends SpreadsheetError{constructor(e){super(e)}toString(){return`Syntax error: ${this.message}`}}class RuntimeError extends SpreadsheetError{constructor(e){super(e)}toString(){return`Evaluation error: ${this.message}`}}const e=Object.freeze({EOF:"EOF",WHITESPACE:"WHITESPACE",PLUS:"PLUS",MINUS:"MINUS",STAR:"STAR",SLASH:"SLASH",LPAREN:"LPAREN",RPAREN:"RPAREN",COLON:"COLON",EQUALS:"EQUALS",COMMA:"COMMA",NUMBER:"NUMBER",STRING:"STRING",IDENTIFIER:"IDENTIFIER"});class Tokenizer{constructor(){this.rules={"\\d+(?:\\.\\d+)?":e.NUMBER,"[a-zA-Z]\\w+":e.IDENTIFIER,"\\s+":e.WHITESPACE,"\\+":e.PLUS,"-":e.MINUS,"\\*":e.STAR,"\\/":e.SLASH,"\\(":e.LPAREN,"\\)":e.RPAREN,"=":e.EQUALS,":":e.COLON,",":e.COMMA,'\\"(?:[^"\\\\]|\\\\.)*\\"':e.STRING,$:e.EOF}}begin(e){return this.remaining=e,this}next(){const e=this.peek();return this.remaining=this.remaining.slice(e.value.length),e}peek(){for(let e in this.rules){const t=this.remaining.match(new RegExp("^"+e));if(null!==t)return{type:this.rules[e],value:t[0]}}throw new ParsingError(`Unknown token '${this.remaining}'`)}rest(){const e=this.remaining;return this.remaining="",e}}class Expression{}class Value extends Expression{constructor(e){super(),this.value=e}toString(){return this.value.constructor===String?`"${this.value}"`:`${this.value}`}}class Reference extends Expression{constructor(e,t){super(),this.col=e,this.row=t}toString(){return`Reference(${this.col}${this.row})`}}class BinaryOp extends Expression{constructor(e,t,r){super(),this.left=e,this.op=t,this.right=r}toString(){return`BinaryOp(${this.left} ${this.op} ${this.right})`}}class UnaryOp extends Expression{constructor(e,t){super(),this.op=e,this.value=t}toString(){return`UnaryOp(${this.op} ${this.value})`}}class FunctionCall extends Expression{constructor(e,t){super(),this.functionName=e,this.args=t}toString(){return`FunctionCall(${this.functionName}, ${this.args.join(", ")})`}}class Range extends Expression{constructor(e,t){super(),this.from=e,this.to=t}toString(){return`Range(${this.from}, ${this.to})`}}function t(e,t){const n=[];for(let s of r(i(e.col),i(t.col)))for(let i of r(e.row,t.row))n.push({col:a(s),row:i});return n}function r(e,t){return e<=t?Array.from({length:t-e+1},(t,r)=>r+e):Array.from({length:e-t+1},(t,r)=>e-r)}function n(e){const t=e.match(/^([A-Za-z]+)(\d+)$/);return null===t?null:{col:t[1],row:parseInt(t[2])}}function s(e,t){return`${e}${t}`}function i(e){return e.charCodeAt(0)-65}function a(e){return String.fromCharCode(e+65)}var o=Object.freeze({positionsInRange:t,parseRange:function(e){const[t,r]=e.split(":");return{from:n(t),to:n(r)}},makeRange:function(e,t){return`${e}:${t}`},parsePosition:n,makePosition:s,columnIndex:i,columnLetter:a});class Parser{constructor(e){this.tokens=e}parse(e){if(null==e||e.constructor!==String)return new Value(e);return this.tokens.begin(e),this.parseCell()}parseCell(){if(this.tokens.remaining.startsWith("=")){this._expectAny(e.EQUALS);const t=this.parseExpression();return this._require(e.EOF),t}{const e=this.tokens.rest();return e.match(/^[+-]?\d+(?:\.\d+)?$/)?new Value(parseFloat(e)):new Value(e)}}parseExpression(){return this.parseTerm()}parseTerm(){let t,r=this.parseFactor();for(;null!==(t=this._expectAny(e.PLUS,e.MINUS));)r=new BinaryOp(r,t.value,this.parseFactor());return r}parseFactor(){let t,r=this.parseUnary();for(;null!==(t=this._expectAny(e.STAR,e.SLASH));)r=new BinaryOp(r,t.value,this.parseUnary());return r}parseUnary(){let t=this._expectAny(e.PLUS,e.MINUS);return null!==t?new UnaryOp(t.value,this.parseUnary()):this.parseValue()}parseValue(){if(this._expectAny(e.LPAREN)){const t=this.parseExpression();return this._require(e.RPAREN),t}const t=this._expectAny(e.NUMBER);if(null!==t)return new Value(parseFloat(t.value));const r=this._expectAny(e.STRING);if(null!==r){const e=r.value.substring(1,r.value.length-1).replace(/\\(.)/g,"$1");return new Value(e)}const n=this._require(e.IDENTIFIER);if(null!==n&&this._expectAny(e.COLON)){const t=this._require(e.IDENTIFIER),r=this._parseReference(n.value),s=this._parseReference(t.value);return new Range(r,s)}if(this._expectAny(e.LPAREN)){let t=n.value;do{const e=this.parseArguments();t=new FunctionCall(t,e)}while(this._expectAny(e.LPAREN));return t}return this._parseReference(n.value)}_parseReference(e){const t=n(e);if(null===t)throw new ParsingError(`Invalid format of cell reference: ${e}`);return new Reference(t.col,t.row)}parseArguments(){const t=[];for(;!this._expectAny(e.RPAREN);)0!=t.length&&this._require(e.COMMA),t.push(this.parseExpression());return t}_expectAny(...e){const t=this._next();return e.includes(t.type)?(this.tokens.next(),t):null}_require(e){const t=this._expectAny(e);if(null===t)throw new ParsingError(`Expected ${e}, got ${this.tokens.peek().type} instead`);return t}_next(){let t=this.tokens.peek();for(;t.type===e.WHITESPACE;)this.tokens.next(),t=this.tokens.peek();return t}}class Evaluator{evaluateCell(e,t){switch(e.constructor){case Value:return e.value;case Reference:return this.evaluateReference(s(e.col,e.row),t);case UnaryOp:return this.evaluateUnary(e.op,e.value,t);case BinaryOp:return this.evaluateBinary(e.left,e.op,e.right,t);case FunctionCall:return this.evaluateFunction(e.functionName,e.args,t);case Range:throw new RuntimeError("Range references are allowed only as arguments of functions");default:throw new RuntimeError(`Unknown expression type: ${typeof e}`)}}evaluateReference(e,t){try{const r=t.getExpression(e)||new Value(null);return this.evaluateCell(r,t)}catch(t){throw t instanceof ParsingError?new RuntimeError(`Error in referenced cell: ${e}`):t}}evaluateExpression(e,t){switch(e.constructor){case Range:return this.evaluateRange(e.from,e.to,t);default:return this.evaluateCell(e,t)}}evaluateUnary(e,t,r){const n=this.evaluateCell(t,r);switch(e){case"+":return n;case"-":return-n;default:throw new RuntimeError(`Unknown unary operator: '${e}'`)}}evaluateBinary(e,t,r,n){const s=this.evaluateCell(e,n),i=this.evaluateCell(r,n);switch(t){case"+":return s+i;case"-":return s-i;case"*":return s*i;case"/":return s/i;default:throw new RuntimeError(`Unknown binary operator: '${t}'`)}}evaluateFunction(e,t,r){const n=t.map(e=>this.evaluateExpression(e,r)),s=r.getFunction(e);try{return s(...n)}catch(t){throw new RuntimeError(`Error in function ${e}: ${t}`)}}evaluateRange(e,r,n){return t(e,r).map(e=>new Reference(e.col,e.row)).map(e=>this.evaluateCell(e,n))}}class Environment{constructor(e={},t={}){this.cells=e,this.functions=t,this._parser=new Parser(new Tokenizer),this._evaluator=new Evaluator,this._expressionsCache={},this._valuesCache={}}getText(e){return this.cells.hasOwnProperty(e)?this.cells[e].toString():""}getExpression(e){if(this._expressionsCache.hasOwnProperty(e))return this._expressionsCache[e];const t=this.cells.hasOwnProperty(e)?this.cells[e]:null,r=this._parser.parse(t);return this._expressionsCache[e]=r,r}getValue(e){if(this._valuesCache.hasOwnProperty(e))return this._valuesCache[e];const t=this._evaluator.evaluateCell(this.getExpression(e),this);return this._valuesCache[e]=t,t}evaluateExpression(e){const t=this._parser.parse(e);return this._evaluator.evaluateCell(t,this)}getFunction(e){if(void 0===this.functions[e])throw new RuntimeError(`Unknown function: ${e} is not a function`);return this.functions[e]}}const u={SUM:(...e)=>e.flat().reduce((e,t)=>e+t,0),AVERAGE:(...e)=>e.flat().reduce((e,t)=>e+t,0)/e.flat().length};class Spreadsheet{constructor(e={},t=u){this.cells=e,this.builtinFunctions=t,this.environment=new Environment(this.cells,this.builtinFunctions)}text(e){return this.environment.getText(e)}value(e){return this.environment.getValue(e)}query(e){return this.environment.evaluateExpression(e)}}export{o as Helpers,u as builtinFunctions,Spreadsheet,SpreadsheetError,RuntimeError,ParsingError};
//# sourceMappingURL=simple-spreadsheet.min.mjs.map
