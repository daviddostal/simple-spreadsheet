{"version":3,"file":"simple-spreadsheet.min.js","sources":["../src/errors.js","../src/tokenizer.js","../src/expressions.js","../src/helpers.js","../src/parser.js","../src/evaluator.js","../src/referencesMap.js","../src/environment.js","../src/functions.js","../src/spreadsheet.js"],"sourcesContent":["export class SpreadsheetError extends Error { }\n\nexport class ParsingError extends SpreadsheetError {\n    constructor(message) { super(message); }\n    toString() { return `Syntax error: ${this.message}`; }\n}\n\nexport class RuntimeError extends SpreadsheetError {\n    constructor(message) { super(message); }\n    toString() { return `Evaluation error: ${this.message}`; }\n}\n","import { ParsingError } from './errors';\n\nexport const TokenType = Object.freeze({\n    EOF: 'EOF',\n    WHITESPACE: 'WHITESPACE',\n    PLUS: 'PLUS',\n    MINUS: 'MINUS',\n    STAR: 'STAR',\n    SLASH: 'SLASH',\n    LPAREN: 'LPAREN',\n    RPAREN: 'RPAREN',\n    COLON: 'COLON',\n    EQUALS: 'EQUALS',\n    COMMA: 'COMMA',\n    NUMBER: 'NUMBER',\n    STRING: 'STRING',\n    IDENTIFIER: 'IDENTIFIER',\n});\n\nexport class Tokenizer {\n    constructor() {\n        this.rules = {\n            // NUMBER and IDENTIFIER are used the most so keep them at the top\n            '\\\\d+(?:\\\\.\\\\d+)?': TokenType.NUMBER,\n            '[a-zA-Z]\\\\w+': TokenType.IDENTIFIER,\n            '\\\\s+': TokenType.WHITESPACE,\n            '\\\\+': TokenType.PLUS,\n            '-': TokenType.MINUS,\n            '\\\\*': TokenType.STAR,\n            '\\\\/': TokenType.SLASH,\n            '\\\\(': TokenType.LPAREN,\n            '\\\\)': TokenType.RPAREN,\n            '=': TokenType.EQUALS,\n            ':': TokenType.COLON,\n            ',': TokenType.COMMA,\n            '\\\\\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\\\\\"': TokenType.STRING,\n            '$': TokenType.EOF,\n        };\n    }\n\n    begin(str) {\n        this.remaining = str;\n        return this;\n    }\n\n    next() {\n        const next = this.peek();\n        this.remaining = this.remaining.slice(next.value.length);\n        return next;\n    }\n\n    peek() {\n        for (let rule in this.rules) {\n            const match = this.remaining.match(new RegExp('^' + rule));\n            if (match !== null) {\n                return { type: this.rules[rule], value: match[0] };\n            }\n        }\n        throw new ParsingError(`Unknown token '${this.remaining}'`);\n    }\n\n    rest() {\n        const rest = this.remaining;\n        this.remaining = \"\";\n        return rest;\n    }\n}\n","export class Expression { }\n\nexport class Value extends Expression {\n    constructor(value) { super(); this.value = value; }\n    toString() { return this.value.constructor === String ? `\"${this.value}\"` : `${this.value}`; }\n}\n\nexport class Reference extends Expression {\n    constructor(col, row) { super(); this.col = col; this.row = row; }\n    toString() { return `Reference(${this.col}${this.row})`; }\n}\n\nexport class BinaryOp extends Expression {\n    constructor(left, op, right) { super(); this.left = left; this.op = op; this.right = right; }\n    toString() { return `BinaryOp(${this.left} ${this.op} ${this.right})`; }\n}\n\nexport class UnaryOp extends Expression {\n    constructor(op, value) { super(); this.op = op; this.value = value; }\n    toString() { return `UnaryOp(${this.op} ${this.value})`; }\n}\n\nexport class FunctionCall extends Expression {\n    constructor(functionName, args) { super(); this.functionName = functionName; this.args = args; }\n    toString() { return `FunctionCall(${this.functionName}, ${this.args.join(', ')})`; }\n}\n\nexport class Range extends Expression {\n    constructor(from, to) { super(); this.from = from; this.to = to; }\n    toString() { return `Range(${this.from}, ${this.to})`; }\n}","export function positionsInRange(from, to) {\n    const positions = [];\n    for (let col of _range(columnIndex(from.col), columnIndex(to.col)))\n        for (let row of _range(from.row, to.row))\n            positions.push({ col: columnLetter(col), row: row });\n    return positions;\n}\n\nfunction _range(from, to) {\n    return from <= to\n        ? Array.from({ length: to - from + 1 }, (_, i) => i + from)\n        : Array.from({ length: from - to + 1 }, (_, i) => from - i);\n}\n\nexport function parseRange(range) {\n    const [from, to] = range.split(':');\n    return { from: parsePosition(from), to: parsePosition(to) };\n}\n\nexport function makeRange(from, to) {\n    return `${from}:${to}`;\n}\n\nexport function parsePosition(position) {\n    const positionParts = position.match(/^([A-Za-z]+)(\\d+)$/);\n    return positionParts === null ? null :\n        { col: positionParts[1], row: parseInt(positionParts[2]) };\n}\n\nexport function makePosition(col, row) {\n    return `${col}${row}`;\n}\n\nexport function columnIndex(colLetter) {\n    return colLetter.charCodeAt(0) - 65;\n}\n\nexport function columnLetter(colIndex) {\n    return String.fromCharCode(colIndex + 65);\n}","import { TokenType } from './tokenizer';\nimport { ParsingError } from './errors';\nimport { Value, Reference, BinaryOp, UnaryOp, Range, FunctionCall } from './expressions';\nimport * as Helpers from './helpers';\n\nexport default class Parser {\n    constructor(tokenizer) {\n        this.tokens = tokenizer;\n    }\n\n    parse(text) {\n        if (text === null || text === undefined || text.constructor !== String)\n            return { parsed: new Value(text), references: [] }; // if there is nothing to parse, return the value.\n\n        this.tokens.begin(text);\n        const parsed = this._parseCell();\n        return { parsed, references: [...new Set(this._getReferences(parsed))] };\n    }\n\n    // Cell => '=' Expression | SimpleValue\n    _parseCell() {\n        if (this.tokens.remaining.startsWith('=')) {\n            this._expectAny(TokenType.EQUALS);\n            const result = this._parseExpression();\n            this._require(TokenType.EOF);\n            return result;\n        } else {\n            return this._parseSimpleValue();\n        }\n    }\n\n    // SimpleValue => number | text\n    _parseSimpleValue() {\n        const value = this.tokens.rest();\n        if (value.match(/^[+-]?\\d+(?:\\.\\d+)?$/)) return new Value(parseFloat(value));\n        else return new Value(value);\n    }\n\n    // Expression => Term\n    _parseExpression() {\n        return this._parseTerm();\n    }\n\n    // Term => Factor ([+-] Factor)*\n    _parseTerm() {\n        let left = this._parseFactor();\n        let operation;\n        while ((operation = this._expectAny(TokenType.PLUS, TokenType.MINUS)) !== null) {\n            left = new BinaryOp(left, operation.value, this._parseFactor());\n        }\n        return left;\n    }\n\n    // Factor => Unary ([*/] Unary)*\n    _parseFactor() {\n        let left = this._parseUnary();\n        let operation;\n        while ((operation = this._expectAny(TokenType.STAR, TokenType.SLASH)) !== null) {\n            left = new BinaryOp(left, operation.value, this._parseUnary());\n        }\n        return left;\n    }\n\n    // Unary => [+-] Unary | Value\n    _parseUnary() {\n        let operation = this._expectAny(TokenType.PLUS, TokenType.MINUS);\n        return operation !== null\n            ? new UnaryOp(operation.value, this._parseUnary())\n            : this._parseValue();\n    }\n\n    // Value => Parenthesized | number | string | RangeReference | FunctionCall | Reference\n    _parseValue() {\n        if (this._expectAny(TokenType.LPAREN))\n            return this._parseParenthesized();\n\n        const number = this._expectAny(TokenType.NUMBER)\n        if (number !== null)\n            return this._parseNumber(number);\n\n        const string = this._expectAny(TokenType.STRING);\n        if (string !== null)\n            return this._parseString(string);\n\n\n        const identifier = this._require(TokenType.IDENTIFIER);\n\n        if (identifier !== null && this._expectAny(TokenType.COLON))\n            return this._parseRangeReference(identifier);\n\n        if (this._expectAny(TokenType.LPAREN))\n            return this._parseFunctionCall(identifier);\n\n        return this._parseReference(identifier.value);\n    }\n\n    // Parenthesized => ( Expression )\n    _parseParenthesized() {\n        // ( is already parsed by parseValue\n        const contents = this._parseExpression();\n        this._require(TokenType.RPAREN);\n        return contents;\n    }\n\n    _parseNumber(number) {\n        return new Value(parseFloat(number.value));\n    }\n\n    _parseString(string) {\n        const withoutQuotes = string.value.substring(1, string.value.length - 1);\n        const escapedString = withoutQuotes.replace(/\\\\(.)/g, '$1');\n        return new Value(escapedString);\n    }\n\n    // RangeReference => identifier ':' identifier\n    _parseRangeReference(identifier) {\n        // start identifier and : are already parsed\n        const endIdentifier = this._require(TokenType.IDENTIFIER);\n        const from = this._parseReference(identifier.value);\n        const to = this._parseReference(endIdentifier.value);\n        return new Range(from, to);\n    }\n\n    // FunctionCall => identifier ( '(' Arguments ')' )*\n    _parseFunctionCall(identifier) {\n        // function name identifier is already parsed\n        let value = identifier.value;\n        do {\n            const args = this._parseArguments();\n            value = new FunctionCall(value, args);\n        } while (this._expectAny(TokenType.LPAREN))\n        return value;\n    }\n\n    // Reference => [A-Za-z]+\\d+\n    _parseReference(reference) {\n        const position = Helpers.parsePosition(reference);\n        if (position === null)\n            throw new ParsingError(`Invalid format of cell reference: ${reference}`);\n        return new Reference(position.col, position.row);\n    }\n\n    // Arguments => (Expression (',' Expression)*)?\n    _parseArguments() {\n        const args = [];\n        while (!this._expectAny(TokenType.RPAREN)) {\n            if (args.length != 0)\n                this._require(TokenType.COMMA);\n            args.push(this._parseExpression());\n        }\n        return args;\n    }\n\n    _expectAny(...types) {\n        const current = this._next();\n        if (types.includes(current.type)) {\n            this.tokens.next();\n            return current;\n        } else {\n            return null;\n        }\n    }\n\n    _require(type) {\n        const next = this._expectAny(type);\n        if (next === null)\n            throw new ParsingError(`Expected ${type}, got ${this.tokens.peek().type} instead`);\n        else\n            return next;\n    }\n\n    _next() {\n        let current = this.tokens.peek();\n        while (current.type === TokenType.WHITESPACE) {\n            this.tokens.next();\n            current = this.tokens.peek();\n        }\n        return current;\n    }\n\n    _getReferences(expression) {\n        switch (expression.constructor) {\n            case Value:\n                return [];\n            case Reference:\n                return [Helpers.makePosition(expression.col, expression.row)];\n            case UnaryOp:\n                return this._getReferences(expression.value);\n            case BinaryOp:\n                return [...this._getReferences(expression.left), ...this._getReferences(expression.right)];\n            case FunctionCall:\n                return expression.args.flatMap(arg => this._getReferences(arg));\n            case Range:\n                return Helpers.positionsInRange(expression.from, expression.to)\n                    .map(pos => Helpers.makePosition(pos.col, pos.row));\n            default:\n                throw new ParsingError(`Unknown expression type: ${typeof expression}`);\n        }\n    }\n}","import { Value, Reference, BinaryOp, FunctionCall, Range, UnaryOp } from './expressions';\nimport { RuntimeError, ParsingError } from './errors';\nimport * as Helpers from './helpers';\n\nexport default class Evaluator {\n    constructor() {\n        this.visitedCellStack = [];\n    }\n\n    evaluateCellAt(position, cell, environment) {\n        if (this.visitedCellStack.includes(position))\n            throw new RuntimeError(`Circular reference detected (${this.visitedCellStack.join(' -> ')} -> ${position})`);\n\n        this.visitedCellStack.push(position);\n        const result = this._evaluateCell(cell, environment);\n        this.visitedCellStack.pop();\n        return result;\n    }\n\n    evaluateQuery(cell, environment) {\n        return this._evaluateCell(cell, environment);\n    }\n\n    _evaluateCell(cell, environment) {\n        switch (cell.constructor) {\n            case Value:\n                return cell.value;\n            case Reference:\n                return this._evaluateReference(Helpers.makePosition(cell.col, cell.row), environment);\n            case UnaryOp:\n                return this._evaluateUnary(cell.op, cell.value, environment);\n            case BinaryOp:\n                return this._evaluateBinary(cell.left, cell.op, cell.right, environment);\n            case FunctionCall:\n                return this._evaluateFunction(cell.functionName, cell.args, environment);\n            case Range:\n                throw new RuntimeError(`Range references are allowed only as arguments of functions`);\n            default:\n                throw new RuntimeError(`Unknown expression type: ${typeof cell}`);\n        }\n    }\n\n    _evaluateReference(position, environment) {\n        try {\n            return environment.getValue(position);\n        } catch (e) {\n            if (e instanceof ParsingError)\n                throw new RuntimeError(`Error in referenced cell: ${position}`);\n            else throw e;\n        }\n    }\n\n    _evaluateExpression(value, environment) {\n        switch (value.constructor) {\n            case Range: return this._evaluateRange(value.from, value.to, environment);\n            default: return this._evaluateCell(value, environment);\n        }\n    }\n\n    _evaluateUnary(op, expression, environment) {\n        const value = this._evaluateCell(expression, environment);\n        switch (op) {\n            case '+': return value;\n            case '-': return -value;\n            default: throw new RuntimeError(`Unknown unary operator: '${op}'`);\n        }\n    }\n\n    _evaluateBinary(left, op, right, environment) {\n        const leftValue = this._evaluateCell(left, environment);\n        const rightValue = this._evaluateCell(right, environment);\n        switch (op) {\n            case '+': return leftValue + rightValue;\n            case '-': return leftValue - rightValue;\n            case '*': return leftValue * rightValue;\n            case '/': return leftValue / rightValue;\n            default: throw new RuntimeError(`Unknown binary operator: '${op}'`);\n        }\n    }\n\n    _evaluateFunction(functionName, args, environment) {\n        const argumentValues = args.map(arg => this._evaluateExpression(arg, environment));\n        const func = environment.getFunction(functionName);\n        try {\n            return func(...argumentValues);\n        } catch (ex) {\n            throw new RuntimeError(`Error in function ${functionName}: ${ex}`);\n        }\n    }\n\n    _evaluateRange(from, to, environment) {\n        return Helpers.positionsInRange(from, to)\n            .map(pos => Helpers.makePosition(pos.col, pos.row))\n            .map(pos => this._evaluateReference(pos, environment));\n    }\n}\n","export default class ReferencesMap {\n    constructor() {\n        this._referencesFrom = {};\n        this._referencesTo = {};\n    }\n\n    getReferencesFrom(position) { return this._referencesFrom[position]; }\n    getReferencesTo(position) { return this._referencesTo[position]; }\n\n    addReference(positionFrom, referenceTo) {\n        if (!this._referencesFrom[positionFrom])\n            this._referencesFrom[positionFrom] = [];\n        this._referencesFrom[positionFrom].push(referenceTo);\n\n        if (!this._referencesTo[referenceTo])\n            this._referencesTo[referenceTo] = [];\n        this._referencesTo[referenceTo].push(positionFrom);\n    }\n\n    removeReferencesFrom(position) {\n        const targetNodes = this._referencesFrom[position];\n        for (let target of targetNodes) {\n            const valueIndex = this._referencesTo[target].indexOf(position);\n            if (valueIndex > -1) this._referencesTo[target].splice(valueIndex, 1);\n        }\n        delete this._referencesFrom[position];\n    }\n\n    getAffectedCells(position) {\n        // TODO: maybe optimize using stack and for loop\n        const referencesTo = this.getReferencesTo(position);\n        if (!referencesTo) return [];\n\n        const recursiveReferences = referencesTo.flatMap(this.getAffectedCells.bind(this));\n        return [...referencesTo, ...recursiveReferences];\n    }\n}","import { Tokenizer } from './tokenizer';\nimport Parser from './parser';\nimport Evaluator from './evaluator';\nimport { RuntimeError } from './errors';\nimport ReferencesMap from './referencesMap';\n\nexport class Environment {\n    constructor(cells = {}, builtinFunctions = {}) {\n        this.cells = cells;\n        this.functions = builtinFunctions;\n        this._parser = new Parser(new Tokenizer());\n        this._evaluator = new Evaluator();\n\n        this._expressionsCache = {}; // position => expression tree\n        this._valuesCache = {}; // position => value;\n        this._referencesMap = new ReferencesMap();\n    }\n\n    getText(position) {\n        return this.cells.hasOwnProperty(position) ? this.cells[position].toString() : \"\";\n    }\n\n    setText(position, value) {\n        this.cells[position] = value;\n\n        delete this._valuesCache[position];\n        for (let pos of this._referencesMap.getAffectedCells(position))\n            delete this._valuesCache[pos];\n\n        delete this._expressionsCache[position];\n        if (this._referencesMap.getReferencesFrom(position))\n            this._referencesMap.removeReferencesFrom(position);\n    }\n\n    getExpression(position) {\n        if (this._expressionsCache.hasOwnProperty(position))\n            return this._expressionsCache[position];\n\n        const text = this.cells.hasOwnProperty(position) ? this.cells[position] : null;\n        const { parsed, references } = this._parser.parse(text);\n        this._expressionsCache[position] = parsed;\n\n        for (let reference of references)\n            this._referencesMap.addReference(position, reference);\n\n        return parsed;\n    }\n\n    getValue(position) {\n        if (this._valuesCache.hasOwnProperty(position))\n            return this._valuesCache[position];\n\n        const result = this._evaluator.evaluateCellAt(position, this.getExpression(position), this);\n        this._valuesCache[position] = result;\n        return result;\n    }\n\n    evaluateQuery(expression) {\n        const { parsed, _ } = this._parser.parse(expression);\n        return this._evaluator.evaluateQuery(parsed, this);\n    }\n\n    getFunction(name) {\n        if (this.functions[name] === undefined)\n            throw new RuntimeError(`Unknown function: ${name} is not a function`);\n        return this.functions[name];\n    }\n};","export const builtinFunctions = {\n    SUM: (...args) => {\n        let sum = 0;\n        for (let arg of args.flat()) {\n            if (typeof (arg) === 'number')\n                sum += arg;\n            else if (!(arg === null || arg === undefined))\n                throw new Error(`${typeof (arg)} is not a valid argument to SUM(). Expected number, number[], null or undefined.`);\n        }\n        return sum;\n    },\n\n    AVERAGE: (...args) => {\n        let sum = 0;\n        let count = 0;\n        for (let arg of args.flat()) {\n            if (typeof (arg) === 'number') {\n                sum += arg;\n                count++;\n            } else if (!(arg === null || arg === undefined)) {\n                throw new Error(`${typeof (arg)} is not a valid argument to AVERAGE().`);\n            }\n        }\n        return sum / count;\n    },\n};","import { Environment } from './environment';\nimport { builtinFunctions } from './functions';\nimport * as Helpers from './helpers';\nexport { Helpers };\nexport { SpreadsheetError, RuntimeError, ParsingError } from './errors';\nexport { builtinFunctions };\n\nexport class Spreadsheet {\n    constructor(cells = {}, functions = builtinFunctions) {\n        this.cells = cells;\n        this._environment = new Environment(this.cells, functions);\n    }\n\n    text(position) {\n        return this._environment.getText(position);\n    }\n\n    set(position, text) {\n        this._environment.setText(position, text);\n    }\n\n    value(position) {\n        return this._environment.getValue(position);\n    }\n\n    query(expression) {\n        return this._environment.evaluateQuery(expression);\n    }\n}"],"names":["SpreadsheetError","Error","ParsingError","[object Object]","message","super","this","RuntimeError","TokenType","Object","freeze","EOF","WHITESPACE","PLUS","MINUS","STAR","SLASH","LPAREN","RPAREN","COLON","EQUALS","COMMA","NUMBER","STRING","IDENTIFIER","Tokenizer","rules","\\d+(?:\\.\\d+)?","[a-zA-Z]\\w+","\\s+","\\+","-","\\*","\\/","\\(","\\)","=",":",",","\\\"(?:[^\"\\\\]|\\\\.)*\\\"","$","str","remaining","next","peek","slice","value","length","rule","match","RegExp","type","rest","Expression","Value","constructor","String","Reference","col","row","BinaryOp","left","op","right","UnaryOp","FunctionCall","functionName","args","join","Range","from","to","positionsInRange","positions","_range","columnIndex","push","columnLetter","Array","_","i","parsePosition","position","positionParts","parseInt","makePosition","colLetter","charCodeAt","colIndex","fromCharCode","range","split","Parser","tokenizer","tokens","text","parsed","references","begin","_parseCell","Set","_getReferences","startsWith","_expectAny","result","_parseExpression","_require","_parseSimpleValue","parseFloat","_parseTerm","operation","_parseFactor","_parseUnary","_parseValue","_parseParenthesized","number","_parseNumber","string","_parseString","identifier","_parseRangeReference","_parseFunctionCall","_parseReference","contents","escapedString","substring","replace","endIdentifier","_parseArguments","reference","Helpers.parsePosition","types","current","_next","includes","expression","Helpers.makePosition","flatMap","arg","Helpers.positionsInRange","map","pos","Evaluator","visitedCellStack","cell","environment","_evaluateCell","pop","_evaluateReference","_evaluateUnary","_evaluateBinary","_evaluateFunction","getValue","e","_evaluateRange","leftValue","rightValue","argumentValues","_evaluateExpression","func","getFunction","ex","ReferencesMap","_referencesFrom","_referencesTo","positionFrom","referenceTo","targetNodes","target","valueIndex","indexOf","splice","referencesTo","getReferencesTo","recursiveReferences","getAffectedCells","bind","Environment","cells","builtinFunctions","functions","_parser","_evaluator","_expressionsCache","_valuesCache","_referencesMap","hasOwnProperty","toString","getReferencesFrom","removeReferencesFrom","parse","addReference","evaluateCellAt","getExpression","evaluateQuery","name","undefined","SUM","sum","flat","AVERAGE","count","Spreadsheet","_environment","getText","setText"],"mappings":"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"}